Metadata-Version: 2.1
Name: py-ucan
Version: 0.5.0
Summary: Python Ucan
Home-page: https://github.com/fileverse/py-ucan
Author: Subham Agarwal
Author-email: subhamagr@users.noreply.github.com
Requires-Python: >=3.10,<4.0
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Requires-Dist: base58 (==2.1.1)
Requires-Dist: cryptography (==42.0.5)
Requires-Dist: pydantic (==2.7.1)
Requires-Dist: pyjwt (==2.8.0)
Requires-Dist: typing_extensions (==4.11.0)
Project-URL: Bug Tracker, https://github.com/fileverse/py-ucan/issues
Project-URL: Documentation, https://github.com/fileverse/py-ucan
Project-URL: Repository, https://github.com/fileverse/py-ucan
Description-Content-Type: text/markdown

# py-ucan

This is a Python library to help the web applications make use
of UCANs in their authorization flows. To learn more about UCANs and how you
might use them in your application, visit [ucan website](https://ucan.xyz) or
read the [spec](https://github.com/ucan-wg/spec).


## Installation

```
pip install -U py-ucan
```

## Usage

### Ucan objects

NOTE: Ojects can be instantiated with field names in camel case, but to access those fields, you need to use their snake case names.

#### ucan.ResourcePointer

```py

# -- from string
resource = ResourcePointer.decode("fileverse://solo.fileverse.io")
print(resource.scheme, resource.hier_part)
# output: fileverse //solo.fileverse.io

# -- from json: snake case
resource = ResourcePointer.model_validate({"scheme": "fileverse", "hier_part": "//solo.fileverse.io"})
print(resource.scheme, resource.hier_part)
# output: fileverse //solo.fileverse.io

# -- from json: camel case
resource = ResourcePointer.model_validate({"scheme": "fileverse", "hierPart": "//solo.fileverse.io"})
print(resource.scheme, resource.hier_part)
# output: fileverse //solo.fileverse.io

# -- from kwargs: snake case
resource = ResourcePointer(scheme="fileverse", hier_part="//solo.fileverse.io")
print(resource.scheme, resource.hier_part)
# output: fileverse //solo.fileverse.io

# -- from kwargs: camel case
resource = ResourcePointer(scheme="fileverse", hierPart="//solo.fileverse.io")
print(resource.scheme, resource.hier_part)
# output: fileverse //solo.fileverse.io

# dump to json
# all the objects above will dump to json with camel case fields
resource = ResourcePointer(scheme="fileverse", hier_part="//solo.fileverse.io").model_dump()
# output: {"scheme": "fileverse", "hierPart": "//solo.fileverse.io"}

```


### Validating UCAN Tokens

To validate a token, you need to use the `validate` function.

```py

import ucan

# receive the token from user request.
encoded_token = "eyJhbG..."  # request.headers.get("Authorization") or similar
# parse and validate the token

try:
    # here `parsed_token` is an instance of `ucan.Ucan`.
    parsed_token = await ucan.validate(encoded_token)

except Exception as e:
    # Invalid token
    pass

```

### Verifying UCAN Invocations

Using a UCAN to authorize an action is called "invocation".

To verify invocations, you need to use the `verify` function.

```py

import ucan

# receive the token from user request.
encoded_token = "eyJhbG..."  # request.headers.get("Authorization") or similar

# generate service keypair
service_key = ucan.EdKeypair.generate()
service_did = service_key.did()  # will return "did:key:zabcde..."

# known resource and user to validate against
doc_id = "some-id"
user_did = "did:key:z6Mk..."

result = await ucan.verify(
    encoded_token,
    # to make sure we're the intended recipient of this UCAN
    audience=service_did,
    # capabilities required for this invocation & which owner we expect for each capability
    required_capabilities=[
        ucan.RequiredCapability(
            capability=ucan.Capability(
                with_=ucan.ResourcePointer(
                    scheme="fileverse", hier_part="//portal.fileverse.io"
                ),
                can=ucan.Ability(namespace=doc_id, segments=["EDIT", "VIEW"]),
            ),
            # check against a known owner of the `doc_id` resource
            root_issuer=user_did,
        ),
    ],
)

# result will be one of the following:
# error: ucan.VerifyResultError(ok=False, errors=[Exception("...")]
# success: ucan.VerifyResultOk(ok=True, value=[ucan.Verification(..)])

if isinstance(result, ucan.VerifyResultOk):
    # The UCAN authorized the user
    pass

else:
    # Unauthorized
    pass
```

