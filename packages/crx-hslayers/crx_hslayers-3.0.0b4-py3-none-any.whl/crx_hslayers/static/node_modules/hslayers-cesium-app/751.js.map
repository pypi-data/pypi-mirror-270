{"version":3,"file":"751.js","mappings":"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","names":["i0","ctx_r1","hsLegendService","legendValid","layer_r3","title","_c0","$event","_r1","titleSearch","refreshList","HsLegendComponent_div_0_span_6_Template","HsLegendComponent_div_0_li_8_Template","rebuildLegends","panelWidthClass","noLayerExists","filterDescriptors","legendFilter","HsLegendComponent","HsPanelBaseComponent","constructor","hsMapService","hsLayerUtilsService","hsUtilsService","hsQueuesService","hsLanguageService","super","this","layerDescriptors","name","end","Subject","item","RegExp","test","ngOnDestroy","next","complete","ngOnInit","loaded","then","map","getLayers","on","e","layerAdded","removeLayerFromLegends","element","buildLegendsForLayers","addLayerToLegends","layer","_this","_asyncToGenerator","descriptor","getLayerLegendDescriptor","source","getSource","instOf","InterpolatedSource","colorMapChanged","pipe","takeUntil","subscribe","layerSourcePropChanged","target","push","layerVisibilityChanged","isLayerWMS","debounce","getMap","filter","check","visible","length","i","lyr","splice","forEach","_this2","ensureQueue","_ref","cb","_x","apply","arguments","findLayerDescriptor","getVisible","findLayerDescriptorBySource","newDescriptor","subLayerLegends","isLayerIDW","indexOf","find","ld","found","Array","from","static","t","i1","i2","i3","i4","i5","core","VBU","selectors","features","decls","vars","consts","template","rf","ctx","HsLegendComponent_div_0_Template","isVisible$","HsLegendModule","$C","G2t","CommonModule","FormsModule","HttpClientModule","HsPanelHelpersModule","HsPanelHeaderComponent","ctx_r0","layerLegend","legendImage","svgContent","HsLegendLayerStaticComponent","hsLegendLayerStaticService","getLegends","Object","assign","fillContent","lastLegendImage","_angular_core__WEBPACK_IMPORTED_MODULE_2__","inputs","HsLegendLayerStaticComponent_img_0_Template","HsLegendLayerStaticComponent_div_1_Template","legendType","HsLegendLayerStaticService","sanitizer","isArray","bypassSecurityTrustHtml","bypassSecurityTrustResourceUrl","_angular_core__WEBPACK_IMPORTED_MODULE_1__","jDH","factory","ɵfac","providedIn","HsLegendLayerVectorComponent","_angular_core__WEBPACK_IMPORTED_MODULE_0__","svg","HsLegendLayerComponent_div_2_img_1_Template","category_r3","color","HsLegendLayerComponent_div_3_p_1_Template","tmp_1_0","legend_categories","HsLegendLayerComponent","hsStylerService","onSet","setSvg","_angular_core__WEBPACK_IMPORTED_MODULE_4__","HsLegendLayerComponent_hs_legend_vector_layer_1_Template","HsLegendLayerComponent_div_2_Template","HsLegendLayerComponent_div_3_Template","HsLegendLayerComponent_hs_legend_layer_static_4_Template","type","autoLegend","HsLegendService","hsLayerSelectorService","layerSelected","undefined","getVectorLayerLegendSvg","currentLayer","getStyle","parser","SLDParser","default","sldObject","sld","getSld","readStyle","output","layerStyle","Feature","rules","symbolizers","OlStyleParser","getSymbolizersFromOlStyle","defaultStyle","fixOpacity","legendOpts","styles","size","hideRect","legendRenderer","LegendRenderer","el","document","createElement","render","innerHTML","ex","rule","symbol","kind","fillOpacity","opacity","getLegendUrl","layer_name","version","getLayerParams","VERSION","source_url","getURL","getParamsFromUrl","OWSURL","getEnableProxy","proxify","_this3","generateInterpolatedLayerLegend","getTitle","generateSVGGradientForColorMap","_this4","getBase","LAYERS","split","VectorLayer","getShowInLayerManager","ImageLayer","Static","XYZ","getAutoLegend","_angular_core__WEBPACK_IMPORTED_MODULE_15__"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["webpack:///./projects/hslayers/components/legend/legend.component.html","webpack:///./projects/hslayers/components/legend/legend.component.ts","webpack:///./projects/hslayers/components/legend/legend.module.ts","webpack:///./projects/hslayers/components/legend/legend-layer-static/legend-layer-static.component.html","webpack:///./projects/hslayers/components/legend/legend-layer-static/legend-layer-static.component.ts","webpack:///./projects/hslayers/components/legend/legend-layer-static/legend-layer-static.service.ts","webpack:///./projects/hslayers/components/legend/legend-layer-vector/legend-layer-vector.component.ts","webpack:///./projects/hslayers/components/legend/legend-layer-vector/legend-layer-vector.component.html","webpack:///./projects/hslayers/components/legend/legend-layer/legend-layer.component.html","webpack:///./projects/hslayers/components/legend/legend-layer/legend-layer.component.ts","webpack:///./projects/hslayers/components/legend/legend.service.ts"],"sourcesContent":["<div class=\"card hs-main-panel\" *ngIf=\"isVisible$ | async\" [ngClass]=\"panelWidthClass\">\n    <hs-panel-header name=\"legend\" [panelTabs]=\"'LEGEND'\">\n    </hs-panel-header>\n    <div class=\"card-body\">\n        <p><input type=\"text\" class=\"form-control hs-filter\" [placeholder]=\"'COMMON.filter' | translateHs\"\n                [(ngModel)]=\"titleSearch\" (input)=\"refreshList()\"></p>\n        <span *ngIf=\"noLayerExists()\">\n            <p style=\"text-align: center\">{{'LEGEND.noLegendExists' | translateHs }}</p>\n        </span>\n        <ul class=\"list-group\">\n            <li *ngFor=\"let layer of filterDescriptors() | filter:legendFilter\" class=\"list-group-item\"\n                [hidden]=\"!hsLegendService.legendValid(layer)\"><!-- TODO: Remove function call from template -->\n                <div>\n                    {{layer.title | translateHs : {module: 'LAYERS'} }}\n                    <hs-legend-layer-directive [layer]=\"layer\"></hs-legend-layer-directive>\n                </div>\n\n            </li>\n        </ul>\n        <div class=\"row justify-content-center\">\n            <div class=\"col col-md-2 d-flex justify-content-center\">\n                <button type=\"button\" class=\"btn btn-light btn-outline ng-scope\" [title]=\"'COMMON.reload' | translateHs\"\n                    (click)=\"rebuildLegends()\">\n                    <i class=\"icon-refresh\"></i>\n                </button>\n            </div>\n        </div>\n    </div>\n</div>","import {Component, OnDestroy, OnInit} from '@angular/core';\nimport {Subject, takeUntil} from 'rxjs';\n\nimport BaseLayer from 'ol/layer/Base';\nimport {Layer} from 'ol/layer';\nimport {Map} from 'ol';\nimport {Source} from 'ol/source';\n\nimport {HsLanguageService} from 'hslayers-ng/services/language';\nimport {HsLayerUtilsService} from 'hslayers-ng/services/utils';\nimport {HsLegendDescriptor} from './legend-descriptor.interface';\nimport {HsLegendService} from './legend.service';\nimport {HsMapService} from 'hslayers-ng/services/map';\nimport {HsPanelBaseComponent} from 'hslayers-ng/common/panels';\nimport {HsQueuesService} from 'hslayers-ng/services/queues';\nimport {HsUtilsService} from 'hslayers-ng/services/utils';\nimport {InterpolatedSource} from 'hslayers-ng/common/layers';\n\n@Component({\n  selector: 'hs-legend',\n  templateUrl: './legend.component.html',\n})\nexport class HsLegendComponent\n  extends HsPanelBaseComponent\n  implements OnInit, OnDestroy\n{\n  layerDescriptors = [];\n  titleSearch = '';\n  name = 'legend';\n  private end = new Subject<void>();\n  constructor(\n    public hsLegendService: HsLegendService,\n    public hsMapService: HsMapService,\n    public hsLayerUtilsService: HsLayerUtilsService,\n    public hsUtilsService: HsUtilsService,\n    public hsQueuesService: HsQueuesService,\n    public hsLanguageService: HsLanguageService,\n  ) {\n    super();\n  }\n  ngOnDestroy(): void {\n    this.end.next();\n    this.end.complete();\n  }\n\n  ngOnInit(): void {\n    this.hsMapService.loaded().then((map) => {\n      map.getLayers().on('add', (e) => this.layerAdded(e));\n      map.getLayers().on('remove', (e) => {\n        this.removeLayerFromLegends(e.element);\n      });\n      this.buildLegendsForLayers(map);\n    });\n    super.ngOnInit();\n  }\n\n  /**\n   * Add selected layer to the list of layers in legend (with event listener\n   * to display/hide legend item when layer visibility change)\n   * @param layer - Layer to add legend for\n   */\n  async addLayerToLegends(layer: Layer<Source>): Promise<void> {\n    const descriptor =\n      await this.hsLegendService.getLayerLegendDescriptor(layer);\n    if (descriptor) {\n      const source: any = layer.getSource();\n      if (this.hsUtilsService.instOf(source, InterpolatedSource)) {\n        (source as InterpolatedSource).colorMapChanged\n          .pipe(takeUntil(this.end))\n          .subscribe(() => {\n            this.layerSourcePropChanged({target: source});\n          });\n      }\n      this.layerDescriptors.push(descriptor);\n      this.refreshList();\n      layer.on('change:visible', (e) => this.layerVisibilityChanged(e));\n      if (this.hsLayerUtilsService.isLayerWMS(layer)) {\n        layer.getSource()?.on('change', (e) => {\n          this.hsUtilsService.debounce(\n            this.layerSourcePropChanged(e),\n            100,\n            false,\n            this,\n          );\n        });\n      }\n    }\n  }\n\n  rebuildLegends(): void {\n    this.layerDescriptors = [];\n    this.buildLegendsForLayers(this.hsMapService.getMap());\n  }\n\n  filterDescriptors(): any[] {\n    return this.layerDescriptors;\n  }\n\n  legendFilter = (item): boolean => {\n    const r = new RegExp(this.titleSearch, 'i');\n    return r.test(item.title);\n  };\n\n  /**\n   * Check if there is any visible layer\n   * @returns Returns true if no layers with legend exist\n   */\n  noLayerExists(): boolean {\n    const visibleLayers = this.layerDescriptors.filter(\n      (check) => check.visible,\n    );\n    return visibleLayers.length == 0;\n  }\n\n  /**\n   * Remove selected layer from legend items\n   * @param layer - Layer to remove from legend\n   */\n  removeLayerFromLegends(layer: BaseLayer): void {\n    for (let i = 0; i < this.layerDescriptors.length; i++) {\n      if (this.layerDescriptors[i].lyr == layer) {\n        this.layerDescriptors.splice(i, 1);\n        this.refreshList();\n        break;\n      }\n    }\n  }\n\n  buildLegendsForLayers(map: Map): void {\n    map.getLayers().forEach((lyr) => {\n      this.layerAdded({\n        element: lyr,\n      });\n    });\n  }\n\n  /**\n   * (PRIVATE) Callback function for adding layer to map, add layers legend\n   * @param e - Event object, should have element property\n   */\n  layerAdded(e): void {\n    const que = this.hsQueuesService.ensureQueue('addLayerToLegends', 3, 10000);\n    que.push(async (cb) => {\n      await this.addLayerToLegends(e.element);\n      cb(null);\n    });\n  }\n\n  /**\n   * @param e - event description\n   */\n  layerVisibilityChanged(e): void {\n    const descriptor = this.findLayerDescriptor(e.target);\n    if (descriptor) {\n      descriptor.visible = e.target.getVisible();\n    }\n  }\n\n  /**\n   * @param e - event description\n   */\n  layerSourcePropChanged(e): void {\n    const descriptor = this.findLayerDescriptorBySource(e.target);\n    if (descriptor) {\n      this.hsLegendService\n        .getLayerLegendDescriptor(descriptor.lyr)\n        .then((newDescriptor) => {\n          if (\n            newDescriptor.subLayerLegends != descriptor.subLayerLegends ||\n            newDescriptor.title != descriptor.title ||\n            this.hsLayerUtilsService.isLayerIDW(descriptor.lyr)\n          ) {\n            this.layerDescriptors[this.layerDescriptors.indexOf(descriptor)] =\n              newDescriptor;\n            this.refreshList();\n          }\n        });\n    }\n  }\n  /**\n   * Finds layer descriptor for OpenLayers layer\n   * @param layer - OpenLayers layer\n   * @returns Object describing the legend\n   */\n  findLayerDescriptor(layer: Layer<Source>): HsLegendDescriptor {\n    return this.layerDescriptors.find((ld) => ld.lyr == layer);\n  }\n\n  /**\n   * @param source -\n   */\n  findLayerDescriptorBySource(source: Source): any {\n    const found = this.layerDescriptors.filter(\n      (ld) => ld.lyr.getSource() == source,\n    );\n    if (found.length > 0) {\n      return found[0];\n    }\n  }\n\n  refreshList(): void {\n    this.layerDescriptors = Array.from(this.layerDescriptors);\n  }\n}\n","import {CUSTOM_ELEMENTS_SCHEMA, NgModule} from '@angular/core';\nimport {CommonModule} from '@angular/common';\nimport {FilterPipe} from 'hslayers-ng/common/pipes';\nimport {FormsModule} from '@angular/forms';\nimport {HsLegendComponent} from './legend.component';\nimport {HsLegendLayerComponent} from './legend-layer/legend-layer.component';\nimport {HsLegendLayerStaticComponent} from './legend-layer-static/legend-layer-static.component';\nimport {HsLegendLayerVectorComponent} from './legend-layer-vector/legend-layer-vector.component';\nimport {HsPanelHeaderComponent} from 'hslayers-ng/common/panels';\nimport {HsPanelHelpersModule} from 'hslayers-ng/common/panels';\nimport {HttpClientModule} from '@angular/common/http';\nimport {TranslateCustomPipe} from 'hslayers-ng/services/language';\n@NgModule({\n  schemas: [CUSTOM_ELEMENTS_SCHEMA],\n  declarations: [\n    HsLegendComponent,\n    HsLegendLayerComponent,\n    HsLegendLayerVectorComponent,\n    HsLegendLayerStaticComponent,\n  ],\n  imports: [\n    CommonModule,\n    FormsModule,\n    HttpClientModule,\n    HsPanelHelpersModule,\n    FilterPipe,\n    TranslateCustomPipe,\n    HsPanelHeaderComponent,\n  ],\n  exports: [HsLegendComponent, HsLegendLayerComponent],\n})\nexport class HsLegendModule {}\n","<img *ngIf=\"layerLegend.legendType === 'image'\" [src]=\"layerLegend.legendImage\">\n<div *ngIf=\"layerLegend.legendType === 'svg'\" [innerHtml]=\"layerLegend.svgContent\">\n</div>","import {Component, Input, OnInit} from '@angular/core';\n\nimport {HsLegendLayerStaticService} from './legend-layer-static.service';\nimport {LayerLegend} from './types/layer-legend.type';\nimport {getLegends} from 'hslayers-ng/common/extensions';\n\n@Component({\n  selector: 'hs-legend-layer-static',\n  templateUrl: './legend-layer-static.component.html',\n})\nexport class HsLegendLayerStaticComponent implements OnInit {\n  @Input() layer: any;\n  layerLegend: LayerLegend = {};\n\n  constructor(private hsLegendLayerStaticService: HsLegendLayerStaticService) {}\n\n  ngOnInit(): void {\n    if (getLegends(this.layer.lyr)) {\n      Object.assign(\n        this.layerLegend,\n        this.hsLegendLayerStaticService.fillContent(this.layer.lyr),\n      );\n    }\n    this.layer.lyr.on('change', (e) => {\n      //TODO: Maybe rewrite this to something more fancy like Observable\n      if (getLegends(this.layer.lyr) != this.layerLegend.lastLegendImage) {\n        this.hsLegendLayerStaticService.fillContent(this.layer.lyr);\n      }\n    });\n  }\n}\n","import {DomSanitizer} from '@angular/platform-browser';\nimport {Injectable} from '@angular/core';\n\nimport {Layer} from 'ol/layer';\nimport {Source} from 'ol/source';\n\nimport {LayerLegend} from './types/layer-legend.type';\nimport {getLegends} from 'hslayers-ng/common/extensions';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class HsLegendLayerStaticService {\n  constructor(private sanitizer: DomSanitizer) {}\n\n  fillContent(lyr: Layer<Source>): LayerLegend {\n    const layerLegend: LayerLegend = {};\n    let legendImage = getLegends(lyr);\n    if (Array.isArray(legendImage)) {\n      legendImage = legendImage[0];\n    }\n    if (legendImage) {\n      layerLegend.lastLegendImage = legendImage;\n      if (legendImage.indexOf('<svg') > -1) {\n        layerLegend.legendType = 'svg';\n        layerLegend.svgContent =\n          this.sanitizer.bypassSecurityTrustHtml(legendImage);\n      } else {\n        layerLegend.legendType = 'image';\n        layerLegend.legendImage =\n          this.sanitizer.bypassSecurityTrustResourceUrl(legendImage);\n      }\n    }\n    return layerLegend;\n  }\n}\n","import {Component, Input} from '@angular/core';\n\n@Component({\n  selector: 'hs-legend-vector-layer',\n  templateUrl: './legend-layer-vector.component.html',\n})\nexport class HsLegendLayerVectorComponent {\n  @Input() svg: string;\n\n  constructor() {}\n}\n","<div class=\"hs-vector-layer-legend\" [innerHtml]=\"svg\"></div>","<div>\n    <hs-legend-vector-layer *ngIf=\"layer.type === 'vector' && layer.autoLegend\" [svg]=\"layer.svg\">\n    </hs-legend-vector-layer>\n    <div *ngIf=\"layer.type === 'wms'\">\n        <img *ngFor=\"let sublayer of layer.subLayerLegends\" [src]=\"sublayer\"\n            onerror=\" this.parentNode.removeChild(this); \"\n            onload=\"if(this.height<6) { this.parentNode.removeChild(this); }\">\n    </div>\n    <div *ngIf=\"layer.type === 'vector'\">\n        <p *ngFor=\"let category of layer.lyr.getSource()?.legend_categories\"><!-- TODO: Remove function call from template --><span\n                [ngStyle]=\"{'background-color': category.color}\">&nbsp;&nbsp;&nbsp;</span>&nbsp;{{category.name}}\n        </p>\n    </div>\n    <hs-legend-layer-static *ngIf=\"layer.type === 'static'\" [layer]=\"layer\"></hs-legend-layer-static>\n</div>\n","import {Component, Input, OnDestroy} from '@angular/core';\nimport {SafeHtml} from '@angular/platform-browser';\n\nimport {Subject, takeUntil} from 'rxjs';\n\nimport {HsLegendService} from '../legend.service';\nimport {HsStylerService} from 'hslayers-ng/services/styler';\nimport {HsUtilsService} from 'hslayers-ng/services/utils';\n\n@Component({\n  selector: 'hs-legend-layer-directive',\n  templateUrl: './legend-layer.component.html',\n})\nexport class HsLegendLayerComponent implements OnDestroy {\n  @Input() layer: any;\n\n  svg: SafeHtml;\n  private end = new Subject<void>();\n  constructor(\n    public hsUtilsService: HsUtilsService,\n    public hsLegendService: HsLegendService,\n    public hsStylerService: HsStylerService,\n  ) {\n    this.hsStylerService.onSet\n      .pipe(takeUntil(this.end))\n      .subscribe(async (layer) => {\n        if (this.layer.lyr == layer) {\n          this.layer.svg = await this.hsLegendService.setSvg(layer);\n        }\n      });\n  }\n\n  ngOnDestroy(): void {\n    this.end.next();\n    this.end.complete();\n  }\n}\n","import {DomSanitizer, SafeHtml} from '@angular/platform-browser';\nimport {Injectable} from '@angular/core';\n\nimport LegendRenderer from 'geostyler-legend/dist/LegendRenderer/LegendRenderer';\nimport {Feature} from 'ol';\nimport {Style as GeoStylerStyle} from 'geostyler-style';\nimport {Image as ImageLayer, Layer, Vector as VectorLayer} from 'ol/layer';\nimport {OlStyleParser} from 'geostyler-openlayers-parser';\nimport {SldStyleParser as SLDParser} from 'geostyler-sld-parser';\nimport {\n  Source,\n  ImageStatic as Static,\n  Vector as VectorSource,\n  XYZ,\n} from 'ol/source';\nimport {Style} from 'ol/style';\n\nimport {HsLayerSelectorService} from 'hslayers-ng/services/layer-manager';\nimport {HsLayerUtilsService} from 'hslayers-ng/services/utils';\nimport {HsLegendDescriptor} from './legend-descriptor.interface';\nimport {HsStylerService} from 'hslayers-ng/services/styler';\nimport {HsUtilsService} from 'hslayers-ng/services/utils';\nimport {InterpolatedSource} from 'hslayers-ng/common/layers';\nimport {defaultStyle} from 'hslayers-ng/services/styler';\nimport {filter} from 'rxjs';\nimport {\n  getAutoLegend,\n  getBase,\n  getEnableProxy,\n  getLegends,\n  getShowInLayerManager,\n  getSld,\n  getTitle,\n} from 'hslayers-ng/common/extensions';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class HsLegendService {\n  constructor(\n    public hsUtilsService: HsUtilsService,\n    public hsStylerService: HsStylerService,\n    private hsLayerUtilsService: HsLayerUtilsService,\n    public hsLayerSelectorService: HsLayerSelectorService,\n    private sanitizer: DomSanitizer,\n  ) {\n    this.hsLayerSelectorService.layerSelected\n      .pipe(filter((layer) => !!layer))\n      .subscribe(async (layer) => {\n        await this.getLayerLegendDescriptor(layer.layer);\n      });\n  }\n\n  /**\n   * Test if layer is visible and has supported type (conditions for displaying legend)\n   * @param layer - Layer to test\n   * @returns Return if legend might exist for layer and layer is visible\n   */\n  legendValid(layer: HsLegendDescriptor): boolean {\n    if (layer === undefined || layer.type == undefined) {\n      return false;\n    }\n    if (\n      ['vector', 'wms', 'static'].indexOf(layer.type) > -1 &&\n      layer.lyr.getVisible()\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Get legend graphics for a vector layer based on sld attribute. If no SLD exists, try to generate it from OL style.\n   * @param currentLayer - Layer of interest\n   * @returns Image as SVG string\n   */\n  async getVectorLayerLegendSvg(\n    currentLayer: VectorLayer<VectorSource>,\n  ): Promise<string> {\n    try {\n      if (currentLayer === undefined) {\n        return;\n      }\n      if (!currentLayer.getStyle()) {\n        return;\n      }\n      const parser = (SLDParser as any).default\n        ? new (SLDParser as any).default()\n        : new SLDParser();\n      let sld = getSld(currentLayer);\n      let sldObject: GeoStylerStyle;\n      if (!sld) {\n        let layerStyle = currentLayer.getStyle();\n        if (typeof layerStyle == 'function') {\n          layerStyle = <Style | Style[]>layerStyle(new Feature(), 1);\n        }\n        const symbolizers = new OlStyleParser().getSymbolizersFromOlStyle(\n          Array.isArray(layerStyle) ? layerStyle : [layerStyle],\n        );\n        sldObject = {\n          name: '',\n          rules: [\n            {\n              name: '',\n              symbolizers,\n            },\n          ],\n        };\n      } else {\n        sldObject = (await parser.readStyle(sld)).output;\n      }\n\n      //In case SLD was not valid for parser, create a new one from default style\n      if (!sldObject) {\n        sld = defaultStyle;\n        sldObject = (await parser.readStyle(sld)).output;\n      }\n      this.fixOpacity(sldObject);\n      const legendOpts: any = {\n        styles: [sldObject],\n        size: [300, 200],\n        hideRect: true,\n      };\n      const legendRenderer = (LegendRenderer as any).default\n        ? new (LegendRenderer as any).default(legendOpts)\n        : new LegendRenderer(legendOpts);\n      const el = document.createElement('div');\n      await legendRenderer.render(el);\n      return el.innerHTML;\n    } catch (ex) {\n      throw ex;\n    }\n  }\n\n  private fixOpacity(sldObject: GeoStylerStyle) {\n    for (const rule of sldObject.rules) {\n      for (const symbol of rule.symbolizers) {\n        if (symbol.kind == 'Fill' && symbol.fillOpacity && !symbol.opacity) {\n          symbol.opacity = symbol.fillOpacity;\n        }\n      }\n    }\n  }\n\n  /**\n   * Generate url for GetLegendGraphic request of WMS service for selected layer\n   * @param source - Source of wms layer\n   * @param layer_name - Name of layer for which legend is requested\n   * @param layer - Layer to get legend for\n   * @returns Url of the legend graphics\n   */\n  getLegendUrl(\n    source: Source,\n    layer_name: string,\n    layer: Layer<Source>,\n  ): string {\n    if (!this.hsLayerUtilsService.isLayerWMS(layer)) {\n      return '';\n    }\n    const params = this.hsLayerUtilsService.getLayerParams(layer);\n    const version = params.VERSION || '1.3.0';\n    let source_url = this.hsLayerUtilsService.getURL(layer);\n    if (source_url.indexOf('proxy4ows') > -1) {\n      const params = this.hsUtilsService.getParamsFromUrl(source_url);\n      source_url = params.OWSURL;\n    }\n    const legendImage = getLegends(layer);\n    if (\n      legendImage === undefined ||\n      (Array.isArray(legendImage) && legendImage.length == 0)\n    ) {\n      source_url +=\n        (source_url.indexOf('?') > 0 ? '' : '?') +\n        '&version=' +\n        version +\n        '&service=WMS&request=GetLegendGraphic&sld_version=1.1.0&layer=' +\n        layer_name +\n        '&format=image%2Fpng';\n      if (\n        getEnableProxy(layer) === undefined ||\n        getEnableProxy(layer) == true\n      ) {\n        source_url = this.hsUtilsService.proxify(source_url);\n      }\n      return source_url;\n    } else {\n      if (typeof legendImage == 'string') {\n        return legendImage;\n      }\n      if (Array.isArray(legendImage)) {\n        return legendImage[0];\n      }\n    }\n  }\n\n  async setSvg(layer: Layer<Source>): Promise<SafeHtml> {\n    return this.sanitizer.bypassSecurityTrustHtml(\n      await this.getVectorLayerLegendSvg(layer as VectorLayer<VectorSource>),\n    );\n  }\n\n  /**\n   * Generate SVG linear gradient for layers colormap\n   */\n  generateInterpolatedLayerLegend(layer: Layer<any>) {\n    return {\n      autoLegend: true,\n      title: getTitle(layer),\n      lyr: layer,\n      type: 'vector',\n      visible: layer.getVisible(),\n      svg: this.hsStylerService.generateSVGGradientForColorMap(layer),\n    };\n  }\n\n  /**\n   * (PRIVATE) Generate url for GetLegendGraphic request of WMS service for selected layer\n   * @param layer - OpenLayers layer\n   * @returns Description of layer to be used for creating the legend. It contains type of layer, sublayer legends, title, visibility etc.\n   */\n  async getLayerLegendDescriptor(\n    layer: Layer<Source>,\n  ): Promise<HsLegendDescriptor | undefined> {\n    if (getBase(layer)) {\n      return;\n    }\n    if (this.hsLayerUtilsService.isLayerWMS(layer)) {\n      const subLayerLegends = this.hsLayerUtilsService\n        .getLayerParams(layer)\n        .LAYERS?.split(',');\n      for (let i = 0; i < subLayerLegends.length; i++) {\n        subLayerLegends[i] = this.getLegendUrl(\n          layer.getSource(),\n          subLayerLegends[i],\n          layer,\n        );\n      }\n      return {\n        title: getTitle(layer),\n        lyr: layer,\n        type: 'wms',\n        subLayerLegends: subLayerLegends,\n        visible: layer.getVisible(),\n      };\n    } else if (\n      this.hsUtilsService.instOf(layer, VectorLayer) &&\n      (getShowInLayerManager(layer) === undefined ||\n        getShowInLayerManager(layer) == true)\n    ) {\n      return {\n        autoLegend: getAutoLegend(layer) ?? true,\n        title: getTitle(layer),\n        lyr: layer,\n        type: 'vector',\n        visible: layer.getVisible(),\n        svg: await this.setSvg(layer),\n      };\n    } else if (\n      this.hsUtilsService.instOf(layer, ImageLayer) &&\n      this.hsUtilsService.instOf(layer.getSource(), Static)\n    ) {\n      return {\n        title: getTitle(layer),\n        lyr: layer,\n        type: 'static',\n        visible: layer.getVisible(),\n      };\n    } else if (this.hsUtilsService.instOf(layer.getSource(), XYZ)) {\n      return {\n        title: getTitle(layer),\n        lyr: layer,\n        type: 'static',\n        visible: layer.getVisible(),\n      };\n    } else if (\n      this.hsUtilsService.instOf(layer.getSource(), InterpolatedSource)\n    ) {\n      return this.generateInterpolatedLayerLegend(layer);\n    } else {\n      return undefined;\n    }\n  }\n}\n"],"x_google_ignoreList":[]}