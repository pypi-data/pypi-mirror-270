from __future__ import annotations
import numpy
import pybind11_stubgen.typing_ext
import typing
from . import trajectory_functions
__all__ = ['CartesianSample', 'CoordinateSystemWrapper', 'CurviLinearSample', 'InvalidCovarianceMatrixError', 'PoseWithCovariance', 'PredictedObject', 'QuarticTrajectory', 'QuinticTrajectory', 'TrajectoryHandler', 'TrajectorySample', 'trajectory_functions']
class CartesianSample:
    is_initialized: bool
    def __getstate__(self) -> dict:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, x: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable], y: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable], theta_gl: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable], v: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable], a: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable], kappa_gl: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable], kappa_dot: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable]) -> None:
        ...
    def __setstate__(self, arg0: dict) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def a(self) -> typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable]:
        ...
    @a.setter
    def a(self, arg1: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1)]) -> None:
        ...
    @property
    def kappa(self) -> typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable]:
        ...
    @kappa.setter
    def kappa(self, arg1: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1)]) -> None:
        ...
    @property
    def kappa_dot(self) -> typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable]:
        ...
    @kappa_dot.setter
    def kappa_dot(self, arg1: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1)]) -> None:
        ...
    @property
    def theta(self) -> typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable]:
        ...
    @theta.setter
    def theta(self, arg1: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1)]) -> None:
        ...
    @property
    def v(self) -> typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable]:
        ...
    @v.setter
    def v(self, arg1: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1)]) -> None:
        ...
    @property
    def x(self) -> typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable]:
        ...
    @x.setter
    def x(self, arg1: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1)]) -> None:
        ...
    @property
    def y(self) -> typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable]:
        ...
    @y.setter
    def y(self, arg1: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1)]) -> None:
        ...
class CoordinateSystemWrapper:
    ref_line: list[typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.FixedSize(2, 1)]]
    def __getstate__(self) -> dict:
        ...
    def __init__(self, ref_path: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 'n'), numpy.ndarray.flags.writeable, numpy.ndarray.flags.c_contiguous]) -> None:
        ...
    def __setstate__(self, arg0: dict) -> None:
        ...
    @property
    def ref_curv(self) -> typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable]:
        ...
    @ref_curv.setter
    def ref_curv(self, arg1: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1)]) -> None:
        ...
    @property
    def ref_curv_d(self) -> typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable]:
        ...
    @ref_curv_d.setter
    def ref_curv_d(self, arg1: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1)]) -> None:
        ...
    @property
    def ref_curv_dd(self) -> typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable]:
        ...
    @ref_curv_dd.setter
    def ref_curv_dd(self, arg1: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1)]) -> None:
        ...
    @property
    def ref_pos(self) -> typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable]:
        ...
    @ref_pos.setter
    def ref_pos(self, arg1: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1)]) -> None:
        ...
    @property
    def ref_theta(self) -> typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable]:
        ...
    @ref_theta.setter
    def ref_theta(self, arg1: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1)]) -> None:
        ...
class CurviLinearSample:
    is_initialized: bool
    def __getstate__(self) -> dict:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, s: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable], d: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable], theta_gl: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable], dd: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable], ddd: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable], ss: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable], sss: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable]) -> None:
        ...
    def __setstate__(self, arg0: dict) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def d(self) -> typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable]:
        ...
    @d.setter
    def d(self, arg1: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1)]) -> None:
        ...
    @property
    def d_ddot(self) -> typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable]:
        ...
    @d_ddot.setter
    def d_ddot(self, arg1: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1)]) -> None:
        ...
    @property
    def d_dot(self) -> typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable]:
        ...
    @d_dot.setter
    def d_dot(self, arg1: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1)]) -> None:
        ...
    @property
    def s(self) -> typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable]:
        ...
    @s.setter
    def s(self, arg1: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1)]) -> None:
        ...
    @property
    def s_ddot(self) -> typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable]:
        ...
    @s_ddot.setter
    def s_ddot(self, arg1: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1)]) -> None:
        ...
    @property
    def s_dot(self) -> typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable]:
        ...
    @s_dot.setter
    def s_dot(self, arg1: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1)]) -> None:
        ...
    @property
    def theta(self) -> typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable]:
        ...
    @theta.setter
    def theta(self, arg1: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1)]) -> None:
        ...
class InvalidCovarianceMatrixError(ValueError):
    pass
class PoseWithCovariance:
    def __init__(self, arg0: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.FixedSize(3, 1)], arg1: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.FixedSize(4, 1)], arg2: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.FixedSize(6, 6)]) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def covariance(self) -> typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.FixedSize(6, 6)]:
        ...
    @property
    def orientation(self) -> typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.FixedSize(4, 1), numpy.ndarray.flags.writeable]:
        ...
    @property
    def position(self) -> typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.FixedSize(3, 1)]:
        ...
class PredictedObject:
    def __init__(self, arg0: int, arg1: list[PoseWithCovariance], arg2: float, arg3: float) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def length(self) -> float:
        ...
    @property
    def object_id(self) -> int:
        ...
    @property
    def predictedPath(self) -> list[PoseWithCovariance]:
        ...
    @property
    def width(self) -> float:
        ...
class QuarticTrajectory:
    def __call__(self, arg0: typing.Annotated[numpy.ndarray, numpy.float64], arg1: typing.Annotated[numpy.ndarray, numpy.float64]) -> typing.Any:
        ...
    def __getstate__(self) -> dict:
        ...
    def __init__(self, tau_0: float, delta_tau: float, x_0: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.FixedSize(3, 1)], x_d: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.FixedSize(2, 1)], x_0_order: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.FixedSize(3, 1)] = ..., x_d_order: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.FixedSize(2, 1)] = ...) -> None:
        ...
    def __setstate__(self, arg0: dict) -> None:
        ...
    def squared_jerk_integral(self, arg0: float) -> float:
        ...
    @property
    def coeffs(self) -> typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.FixedSize(5, 1)]:
        ...
    @property
    def delta_tau(self) -> float:
        ...
class QuinticTrajectory:
    def __call__(self, arg0: typing.Annotated[numpy.ndarray, numpy.float64], arg1: typing.Annotated[numpy.ndarray, numpy.float64]) -> typing.Any:
        ...
    def __getstate__(self) -> dict:
        ...
    def __init__(self, tau_0: float, delta_tau: float, x_0: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.FixedSize(3, 1)], x_d: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.FixedSize(3, 1)], x_0_order: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.FixedSize(3, 1)] = ..., x_d_order: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.FixedSize(3, 1)] = ...) -> None:
        ...
    def __setstate__(self, arg0: dict) -> None:
        ...
    def squared_jerk_integral(self, arg0: float) -> float:
        ...
    @property
    def coeffs(self) -> typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.FixedSize(6, 1)]:
        ...
    @property
    def delta_tau(self) -> float:
        ...
class TrajectoryHandler:
    def __init__(self, dt: float) -> None:
        ...
    def add_cost_function(self, arg0: trajectory_functions.CostStrategy) -> None:
        ...
    def add_feasability_function(self, arg0: trajectory_functions.FeasabilityStrategy) -> None:
        ...
    def add_function(self, arg0: trajectory_functions.TrajectoryStrategy) -> None:
        ...
    def clear_cost_functions(self) -> None:
        """
        Clears all cost functions.
        """
    def evaluate_all_current_functions(self, calculateAllCosts: bool = False) -> None:
        ...
    def evaluate_all_current_functions_concurrent(self, calculateAllCosts: bool = False) -> None:
        ...
    def generate_trajectories(self, samplingMatrix: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 'n'), numpy.ndarray.flags.writeable, numpy.ndarray.flags.c_contiguous], lowVelocityMode: bool) -> None:
        ...
    def get_cost_functions(self) -> typing.Iterator:
        ...
    def get_feasability_functions(self) -> typing.Iterator:
        ...
    def get_other_functions(self) -> typing.Iterator:
        ...
    def get_sorted_trajectories(self) -> typing.Iterator:
        ...
    def reset_Trajectories(self) -> None:
        """
        Resets the trajectories container.
        """
    def set_all_cost_weights_to_zero(self) -> None:
        """
        Sets all cost function weights to zero.
        """
    def sort(self) -> None:
        ...
class TrajectorySample:
    _coll_detected: bool | None
    _cost: float
    _ego_risk: float | None
    _harm_occ_module: float | None
    _obst_risk: float | None
    boundary_harm: float | None
    cartesian: CartesianSample
    cost: float
    costMap: dict[str, tuple[float, float]]
    curvilinear: CurviLinearSample
    dt: float
    feasabilityMap: dict[str, float]
    feasible: bool
    harm_occ_module: float | None
    trajectory_lat: QuinticTrajectory
    trajectory_long: QuarticTrajectory
    uniqueId: int | None
    valid: bool
    def __getstate__(self) -> dict:
        ...
    @typing.overload
    def __init__(self, dt: float, trajectoryLongitudinal: QuarticTrajectory, trajectoryLateral: QuinticTrajectory, uniqueId: int) -> None:
        ...
    @typing.overload
    def __init__(self, x0: float, y0: float, orientation0: float, acceleration0: float, velocity0: float) -> None:
        ...
    def __setstate__(self, arg0: dict) -> None:
        ...
    def add_cost_value_to_list(self, cost_function_name: str, cost: float, weighted_costs: float) -> None:
        """
        Add a cost value to the list of cost values. This includes the weighted and unweighted cost.
        """
    @property
    def sampling_parameters(self) -> typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1), numpy.ndarray.flags.writeable]:
        ...
    @sampling_parameters.setter
    def sampling_parameters(self, arg1: typing.Annotated[numpy.ndarray, numpy.float64, pybind11_stubgen.typing_ext.DynamicSize('m', 1)]) -> None:
        ...
