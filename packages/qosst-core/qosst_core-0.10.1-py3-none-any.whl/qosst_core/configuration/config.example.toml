# QOSST configuration file.
# This is an example configuration file that can be inputted
# to the configuration parser.
# Please refer to the documentation for more details.

# The label of your config
# in case you have different configuration
# Default : Example config
label = "Example config"

# Serial number
# Default : ""
serial_number = ""

[logs]

# If true, logs are saved in a file. If false
# logs are not saved in a file.
# This does not concern console or GUI logs.
# Default : true
logging = true

# The path where to save the logs.
# Default : "qosst.log"
path = "qosst.log"

# Log level. Choices are (in ascending order): debug, info, warning, 
# error, critical.
# Any level includes the logs of the level and above (for instance
# warning includes warning, error and critical).
# Default : "info"
level = "info"

[notifications]

# Notify
# If true, notifications will be enabled. If false,
# they will be disabled.
# Default : false
notify = false

# Notifier class.
# The notifier should be a valid class, inheriting from 
# qosst_core.notifications.QOSSTNofitier.
# Default : "qosst_core.notifications.FakeNotifier"
notifier_class = "qosst_core.notifications.FakeNotifier"

# Notifier args.
# to pass to initiate the notifier. For instance, using 
# {token = "plop"} would call the notifier with Notifier(token="plop")
# Default : {}
notifier_args = {}

[authentication]
# Authentication class
# The authenticator should be a valid class, inheriting from
# qosst_core.authentication.base.BaseAuthenticator.
# Default : "qosst_core.authentication.NoneAuthenticator"
authentication_class = "qosst_core.authentication.NoneAuthenticator"

# Authentication params
# You can use the special from_file to read values from a file
# Example : {secret_key = "from_file()", remote_public_key = "from_file()"}
# Default : {}
authentication_params = {}

[clock]
# Assume physical clock sharing or not ?
# Default : false
sharing = false

# Clock master.
# The clock master is the one emitting the clock reference.
# Valid choices are "alice" and "bob"
# Default : "alice"
master = "alice"

[local_oscillator]
# Is the local oscillator shared between Alice and Bob ?
# Default : false
shared = false

[channel]

[channel.voa]

# Use VOA to emulate a channel.
# Default : false
use = false

# Applier
# This can be either Alice or Bob. The other party will ignore this section.
# It's also possible to not configure this section on the inactive party.
# Default : "alice"
applier = "alice"

# The class of the VOA to use.
# This should be a valid class, inheriting from qosst_hal.voa.GenericVOA.
# Default : "qosst_hal.voa.FakeVOA"
device = "qosst_hal.voa.FakeVOA"

# Location of the device
# Default : ""
location = ""

# Value to apply to the VOA
# Default : 0
value = 0

# Extras arguments to the VOA class.
# They will be passed as kwargs.
# For instance having extra_args = {"min_value": 0}
# would be equivalent to call the VOA with VOA(..., min_value=0)
# Default : {}
extra_args = {}


[alice]

# The conversion factor from the monitoring photodiode to 
# Alice's actual output.
# Default : 1
photodiode_to_output_conversion = 1


# Emission wavelength in m.
# This wavelength is used to compute the energy of the single
# photon when computing <n>.
# Default: 1550e-9
emission_wavelength = 1550e-9

# Artificial excess noise.
# Warning : this parameter should always be put to 0
# for most of the software operation since this parameter will add
# noise to the data generated by Alice, that will not be registered in
# Alice's symbol.
# Default : 0
artificial_excess_noise = 0

# Schema for the emission
# See the list of possible schema in qosst_core.schema.emission
# Default : "qosst_core.schema.emission.SINGLE_POLARISATION_SINGLE_SIDEBAND"
schema = "qosst_core.schema.emission.SINGLE_POLARISATION_SINGLE_SIDEBAND"

[alice.signal_generation]

# Symbols path
# Path for the symbols.
# If save_symbols is true, this will 
# be used as location to save the symbols
# If load_symbols is true, this will
# be used as the location to load the symbols from.
# Default : "symbols.npy"
symbols_path = "symbols.npy"

# Final sequence path
# Path for the final sequence.
# If save_final_sequence is true, this will
# be used as location to save the final sequence
# If load_final_sequence is true, this will
# be used as the location to load the final sequence from.
# Default : "final_sequence.npy"
final_sequence_path = "final_sequence.npy"

# Quantum sequence path.
# To be used when the quantum sequence is saved.
# Default : "quantum_sequence.npy"
quantum_sequence_path = "quantum_sequence.npy"

# Load symbols
# If true, symbols will be loaded from a numpy file and not
# the entropy source.
# The parameter symbols_path will be used.
# Default : false
load_symbols = false

# Load final sequence
# If true, the final sequence will be loaded from the numpy
# file, and the DSP will be bypassed.
# The parameter final_sequence_path will be used.
# Default : false
load_final_sequence = false

# Save symbols
# If true, symbols will be saved to a numpy file.
# The parameter symbols_path will be used.
# Default : true
save_symbols = true

# Save final sequence
# If true, the final sequence will be saved to a numpy file.
# The parameter final_sequence_path will be used.
# Default : false
save_final_sequence = false

# Save quantum sequence
# If true, the quamtum sequence (i.e. only composed of the quantum symbols
# after DSP) will be saved to a numpy file.
# The parameter quantum_sequence_path will be used.
# Default : false
save_quantum_sequence = false

[alice.network]
# The address on which Alice listens
# Default : "127.0.0.1"
bind_address = "127.0.0.1"

# The port on which alice listens
# Default : 8181
bind_port = 8181

[alice.dac]
# Rate of the DAC (in Samples/second)
# Default : 500e6
rate = 500e6

# Amplitude, in V
# The generated data by the DSP will be between +1 and -1
# If the amplitude is A, then this means that the +1 will be
# mapped to +A V and the -1 to -A V.
# For this reason, the amplitude should be between 0 V and 
# the maximum output voltage
# Default : 0
amplitude = 0

# The class of the DAC to use.
# This should be a valid class, inheriting from qosst_hal.dac.GenericDAC.
# Default : "qosst_hal.dac.FakeDAC"
device = "qosst_hal.dac.FakeDAC"

# List of channels to use.
# Default : [0,1]
channels = [0,1]

# Extras arguments to the DAC class.
# They will be passed as kwargs.
# For instance having extra_args = {"erase": true}
# would be equivalent to call the dac with DAC(..., erase=True)
# Default : {}
extra_args = {}

[alice.powermeter]

# The class of the power meter to use.
# This should be a valid class, inheriting from qosst_hal.powermeter.GenericPowerMeter.
# Default : "qosst_hal.powermeter.FakePowerMeter"
device = "qosst_hal.powermeter.FakePowerMeter"

# Location of the device
# Default : ""
location = ""

# Timeout of the device
# Default : 10
timeout = 10

[alice.voa]

# The class of the VOA to use.
# This should be a valid class, inheriting from qosst_hal.voa.GenericVOA.
# Default : "qosst_hal.voa.FakeVOA"
device = "qosst_hal.voa.FakeVOA"

# Location of the device
# Default : ""
location = ""

# Value to apply to the VOA
# Default : 0
value = 0

# Extras arguments to the VOA class.
# They will be passed as kwargs.
# For instance having extra_args = {"min_value": 0}
# would be equivalent to call the VOA with VOA(..., min_value=0)
# Default : {}
extra_args = {}

[alice.modulator_bias_control]

# The class of the bias controller to use.
# This should be a valid class, inheriting from qosst_hal.modulator_bias_controller.GenericModulatorBiasController.
# Default : "qosst_hal.modulator_bias_control.FakeModulatorBiasController"
device = "qosst_hal.modulator_bias_control.FakeModulatorBiasController"

# Location of the device
# Default : ""
location = ""

# Extras arguments to the bias controller class.
# They will be passed as kwargs.
# For instance having extra_args = {"sleep_time": 30}
# would be equivalent to call the bias controller with Controller(..., sleep_time=30)
# Default : {}
extra_args = {}

[alice.laser]

# The class of the laser to use.
# This should be a valid class, inheriting from qosst_hal.laser.GenericLaser.
# Default : "qosst_hal.laser.FakeLaser"
device = "qosst_hal.laser.FakeLaser"

# Location of the laser.
# Default : ""
location = ""

# The parameters to pass to the set_parameters method.
# This depends on the specific laser used.
# Default : {}
parameters = {}

[alice.polarisation_recovery]

# Section for polarisation recovery through the use of a motorized polarisation controller.

# Frequency of the signal to send to Bob for polarisation recovery, in Hz.
# Default : 20e6
signal_frequency = 20e6

# Amplitude of the signal to send to Bob for polarisation recovery (this does not override 
# the amplitude of the DAC, it has to be seen like the amplitude of the pilots).
# Default : 1
signal_amplitude = 1


[bob]
# Export directory
# For data and figures
# Default : export
export_directory = "export"

# Global efficiency of the receiver
# Must be between 0 and 1.
# Default : 0.8
eta = 0.8

# Automatic shot noise calibration.
# If true the client will automatically calibrate 
# the shot noise just before trigerring Alice.
# Default: false
automatic_shot_noise_calibration = false

# Schema for the detection
# See the list of possible schema in qosst_core.schema.detection
# Default : "qosst_core.schema.detection.SINGLE_POLARISATION_RF_HETERODYNE"
schema = "qosst_core.schema.detection.SINGLE_POLARISATION_RF_HETERODYNE"

[bob.network]
# Address to connect to
# Default : 127.0.0.1
server_address = "127.0.0.1"

# Port to connect to
# Default : 8181
server_port = 8181

[bob.adc]
# Rate of the ADC (in Samples/second)
# Default : 2500e6
rate = 2500e6

# Device to use as the ADC
# This should be a valid class, inheriting from qosst_hal.adc.GenericADC.
# Default : FakeADC
device = "qosst_hal.adc.FakeADC"

# List of channels to use
# Default : [0]
channels = [0]

# Location of the device
# Default : ""
location = ""

# Acquisition time in seconds.
# The acquisition time should be either a strictly
# positive number of 0. If 0 is given, then the acquisition
# time will be automatically computed from the other parameters
# Default : 0
acquisition_time = 0

# Overhead time in seconds.
# Overhead time when you automatically compute the acquisition time
# This globally is the overhead created by the classical communication
# The acquisition time would be computed as nb_samples / rate + overhead
# Default: 0
overhead_time = 0

# Extra arguments to the ADC class.
# They will be passed as kwargs.
# For instance having extra_args = {"erase": true}
# would be equivalent to call the adc with ADC(..., erase=True)
# Default : {}
extra_args = {}

# Extra acquisition parameters to the ADC class.
# They will be passed as kwargs.
# For instance having extra_args = {"paths": "test.npy"}
# would be equivalent to call the method with set_acquisition_parameters(..., paths="test.npy")
# Default : {}
extra_acquisition_parameters = {}

[bob.switch]

# Device for the switch.
# This should be a valid class, inheriting from qosst_hal.switch.GenericSwitch.
# Default : "FakeSwitch"
device = "qosst_hal.switch.FakeSwitch"

# Location of the switch.
# Default : ""
location = ""

# Timeout of the switch in seconds.
# Default : 100
timeout = 100

# State that should be used for the signal.
# Default : 1
signal_state = 1

# State that should be used for calibration.
# Default : 2
calibration_state = 2

# Switch time
# Time to wait before switching back to the signal state
# and send the trigger to Alice.
# If 0 the calibration should be done manually (the switch won't
# automatically switch in the calibration state before).
# Default : 0
switching_time = 0

[bob.laser]

# The class of the laser to use.
# This should be a valid class, inheriting from qosst_hal.laser.GenericLaser.
# Default : "qosst_hal.laser.FakeLaser"
device = "qosst_hal.laser.FakeLaser"

# Location of the laser.
# Default : ""
location = ""

# The parameters to pass to the set_parameters method.
# This depends on the specific laser used.
# Default : {}
parameters = {}

[bob.polarisation_recovery]
# Section for polarisation recovery through the use of a motorized polarisation controller.

# If true, use the polarisation recovery.
# Default : false
use = false

# Step (unit depending on the polarisation controller used) for the 
# optimal polarisation finding algorithm.
# Default : 1
step = 1

# Start course (unit depending on the polarisation controller used) for the
# optimal polarisation finding algorithm (it will start at this value and 
# will go to the end value with a the step set above).
# Default : 0
start_course = 0

# End course (unit depending on the polarisation controller used) for the 
# optimal polarisation finding algorithm (it will end at this value, excluded).
# Default : 0
end_course = 0

# Wait time in seconds between two positions.
# Default : 0
wait_time = 0

[bob.polarisation_recovery.polarisation_controller]

# The class of polarisation controller to use.
# This should be a valid class, inheriting from qosst_hal.polarisation_controller.GenericPolarisationController.
# Default : "qosst_hal.polarisation_controller.FakePolarisationController"
device = "qosst_hal.polarisation_controller.FakePolarisationController"

# Location of the polarisation controller.
# Default : ""
location = ""

[bob.polarisation_recovery.powermeter]

# The class of powermter to use.
# This should be a valid class, inheriting from qosst_hal.powermeter.GenericPowerMeter.
# Default : "qosst_hal.powermeter.FakePowerMeter"
device = "qosst_hal.powermeter.FakePowerMeter"

# Location of the powermeter
# Default : ""
location = ""

# Timeout for the powermeter
# Default : 10
timeout = 10

[bob.dsp]

# Debug mode.
# If True, a DSPDebug object is returned with additional information.
# Default : true
debug = true

# Size for the FIR filters.
# Default : 500
fir_size = 500

# Value of cutoff for the FIR filter to filter the tone.
# The cutoff means that the filter will filter between tone_freq +/- cutoff
# and have a frequency width of 2*cutoff.
# Default : 10e6
tone_filtering_cutoff = 10e6

# Set true to process the data in subframes
# Default : false
process_subframes = false

# Size of the subframes if process_subframes is true
# Default : 0
subframes_size = 0

# Abort clock recovery
# If the difference of clock mismatch (in ratio)
# is greater than this parameter, then the 
# clock recovery abort and assumes adc_rate
# is the good rate
# If this is 0, never abort.
# Default : 0
abort_clock_recovery = 0

# Alice DAC rate (Samples/second)
# Default : 500e6
alice_dac_rate = 500e6

# Exclusion zone for pilot search
# This is represented as a list of lists. The insides tuple should be a of length 2,
# where the first element is the beginning of the exclusion zone (included)
# and the second element is the end of the exclusion zone (also included).
# Default: [[0.0, 100e3]]
exclusion_zone_pilots = [[0.0, 100e3]]

# Size of filter for the phase recovery
# If not 0, the recovered phase will be filter with
# a uniform1d filter (i.e. moving average) with the size
# defined by this parameter.
# Default: 0
pilot_phase_filtering_size = 0

# Number of samples to estimate properly
# f_beat in general dsp
# Default : 100000
num_samples_fbeat_estimation = 100000

[bob.dsp.equalizer]

# If true, use the CMA equalizer.
# Default: false
equalize = false

# Length of the CMA equalizer.
# Default: 100
length = 100

# Step size for the CMA equalizer.
# Default: 0.01
step = 0.01

# P-parameter of the CMA equalizer.
# Default: 2
p = 2

# Q-parameter of the CMA equalizer.
# Default: 2
q = 2

[bob.parameters_estimation]

# Estimator to use for the estimation of the parameters.
# This should be a valid class, inheriting from 
# qosst_core.parameters_estimation.BaseEstimator.
# Default : qosst_core.parameters_estimation.NoneEstimator
estimator = "qosst_core.parameters_estimation.NoneEstimator"

# Secret key rate calculator to use.
# This should be a valid class, inheriting from 
# qosst_core.skr_computations.BaseCVQKDSKRCalculator
# Default : qosst_core.skr_computations.NoneCalculator
skr_calculator = "qosst_core.skr_computations.NoneSKRCalculator"

# Ratio for parameters estimation. 
# A ratio of 0.1 means that 10% of the data will be used to
# estimate the parameters. A ratio of 0.5 means that 50% of
# the data will be used for parameters estimation.
# Default : 0.5
ratio = 0.5

[bob.electronic_noise]

# Path of the electronic noise file (load and save)
# Default : "electronic_noise.qosst"
path = "electronic_noise.qosst"

[bob.electronic_shot_noise]

# Path of the elctronic and shot noise file (load and save)
# This should only be used of the calibration of the electronic
# and shot noise is not automatic (i.e. the switching time
# is set to 0 in bob.switch).
# Default to electronic_shot_noise.qosst
path = "electronic_shot_noise.qosst"

[frame]

# Number of zeros to add in the start
# Default : 0
num_zeros_start = 0

# Number of zeros to add in the end
# Default : 0
num_zeros_end = 0

[frame.pilots]
# Number of pilots to insert in the signal
# Default : 2
num_pilots = 2

# Frequencies, in Hz, for the pilots as a list
# Default : [200e6, 220e6]
frequencies = [200e6, 220e6]

# List of amplitudes for the pilots.
# Default : [0.4, 0.4]
amplitudes = [0.4, 0.4]

[frame.quantum]

# Number of symbols for the quantum part
# Default : 1000000
num_symbols = 1000000

# Frequency shift, in Hz, for the quantum part
# Default : 100e6
frequency_shift = 100e6

# If true, use a rectangular filter instead of a root raised cosine filter.
# In this case the roll-off value will be used as the duty cycle value/
# Default : false
pulsed = false

# Symbol rate for the symbols, in Baud.
# Default : 100e6
symbol_rate = 100e6

# Roll off factor for the Root-Raised Cosine filter.
# If using a rectangular filter (pulsed regime), this 
# is used as the duty cycle.
# Default : 0.5
roll_off = 0.5

# Variance of Alice (relative to the -1, 1 extremums)
# Default : 0.01
variance =  0.01

# Modulation type.
# This should be a valid class, inheriting from
# qosst_core.modulation.modulation.Modulation.
# Default : "qosst_core.modulation.GaussianModulation"
modulation_type = "qosst_core.modulation.GaussianModulation"

# Size of constellation
# Let 0 for Gaussian
# M should be a power of 2 for PSK
# M should be a power of 2 and a square for QAM and PCS-QAM
# Default : 0
modulation_size = 0

[frame.zadoff_chu]
# The root of the Zadoff-Chu sequence.
# This should be comprime with the length.
# Default : 5
root = 5

# The length of the Zadoff-Chu sequence.
# This should be coprime with the root.
# Default : 3989
length = 3989

# The rate of the Zadoff-Chu sequence in Samples/s.
# A rate of 0 will be understood as to use the same rate as the DAC.
# Default : 0
rate = 0