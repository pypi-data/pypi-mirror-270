def _EQhJA(f):
    def _2OEpH(*args, **kwargs):
        return f(*args, **kwargs)
    _2OEpH.__module__ = f.__module__
    _2OEpH.__name__ = f.__name__
    _2OEpH.__doc__ = f.__doc__
    _2OEpH.__dict__.update(f.__dict__)
    f.__refcalls__ = 0
    return _2OEpH

@_EQhJA
def _wxMS5():
    global _T3LOy, _IExoO, _grrTa, _0iyPu, _mgVsN, _BAF5H, _Gpcpm, _AjU9I, _h36lw, _rjv4L, _yBOr1, _NDyKX, _9tsH8, _OCXOm, _Ty7bI, _66o7T, _mrjlq, _b249k, _DQbEy, _tyls6, _95m2g, _ZvcvQ, _tZ8BM, _BPR43, _dVw0a, _wcCZj, _eQFEJ, _dP500, _gb0oR, _XstWq, _xpREk, _fDTpS, _dJwg5, _NNDtx, _ygeGB, _4jwtQ, _LX3Sc, _3ELbO, _dCvz8, _FpINc, _kzrm1, _0rSna, _YGWcK, _fDauH, _4TTtt, _W53WG
    from __future__ import annotations
    from cryptography.exceptions import InvalidSignature
    from cryptography.hazmat.primitives import hashes, serialization
    from cryptography.hazmat.primitives.asymmetric import padding
    from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PublicKey
    from cryptography.hazmat.primitives.asymmetric.rsa import RSAPublicKey
    from dataclasses import dataclass
    from datetime import datetime, timedelta, timezone
    from email.utils import parsedate_to_datetime
    from importlib import metadata
    from importlib.util import find_spec
    from pathlib import Path
    from requests import Request
    from rich.console import Console
    from rich.panel import Panel
    from rich.prompt import Confirm, Prompt
    from rich.table import Table
    from rich.text import Text
    from rich_argparse import RichHelpFormatter
    from sys import version_info
    from typing import Any, Literal, Protocol, TYPE_CHECKING
    from urllib.parse import quote, urlsplit
    from wsgiref.handlers import format_date_time
    import argparse, base64, binascii, hashlib, hmac, json, logging, machineid, multiprocessing, os, packaging.requirements, platform, platformdirs, re, requests, requests_cache, shutil, socket, sys, time, uuid
    _secv0 = Console(highlight=True)
    _3ugga = Console(stderr=True, style='yellow', highlight=False)
    _cqDx9 = Console(stderr=True, style='red', highlight=False)

    def _T3LOy(msg='', **_7pkDy):
        _secv0.print(msg, **_7pkDy)

    def _laFx0(msg):
        _3ugga.print(f'Warning: {msg}')

    def _CltWa(msg):
        _cqDx9.print(f'\nError: {msg}')

    class _IExoO(Exception):

        def __init__(self, message, code):
            super().__init__(message)
            self.code = code

        def show(self):
            _CltWa(f'{self} ({self.code})')

    class _grrTa(Exception):
        pass

    class _J6SYl(Exception):
        pass

    def _0iyPu(key_bytes):
        assert isinstance(key_bytes, bytes)
        return _hL1GA(serialization.load_pem_public_key(key_bytes))

    def _mgVsN(key_bytes):
        assert isinstance(key_bytes, bytes)
        return _hL1GA(serialization.load_der_public_key(key_bytes))

    def _C7C50(key_bytes):
        _a2RVk = _mgVsN(key_bytes)
        assert isinstance(_a2RVk, _Gpcpm)
        return _a2RVk

    def _hL1GA(key):
        if isinstance(key, Ed25519PublicKey):
            return _BAF5H(key)
        if isinstance(key, RSAPublicKey):
            return _Gpcpm(key)
        _6jnVm = 'Unknown key'
        raise ValueError(_6jnVm)

    class _ywA4V:
        pass

    class _BAF5H(_ywA4V):
        alg = 'ed25519'

        @classmethod
        def from_bytes(cls, key_bytes):
            return cls(Ed25519PublicKey.from_public_bytes(key_bytes))

        @classmethod
        def from_hex(cls, key_hex):
            return cls.from_bytes(bytes.fromhex(key_hex))

        @classmethod
        def from_base64(cls, key_b64):
            return cls.from_bytes(base64.b64decode(key_b64))

        def __init__(self, key):
            assert isinstance(key, Ed25519PublicKey)
            self.key = key

        def verify(self, sig_bytes, msg_bytes):
            try:
                self.key.verify(sig_bytes, msg_bytes)
            except InvalidSignature:
                _qdbcJ = 'SLiM: Ed25519 signature verification error. (Wrong key?)'
                raise _grrTa(_qdbcJ) from None

        def verify_response(self, res):
            try:
                _w6DFE = res.created_at.replace(tzinfo=timezone.utc)
            except AttributeError:
                _w6DFE = datetime.now(tz=timezone.utc)
            if _w6DFE < datetime(2024, 2, 7, 0, 0, tzinfo=timezone.utc):
                return
            alg, _7EJtu, _kuufB = _I6KwN(res)
            if alg.lower() != self.alg:
                _7EJtu = f'Expected alg {self.alg}, got {alg}'
                raise ValueError(_7EJtu)
            self.verify(_kuufB, _7EJtu)

    class _Gpcpm(_ywA4V):

        @classmethod
        def from_bytes(cls, key_bytes):
            return cls(RSAPublicKey.from_public_bytes(key_bytes))

        @classmethod
        def from_hex(cls, key_hex):
            return cls.from_bytes(bytes.fromhex(key_hex))

        @classmethod
        def from_base64(cls, key_b64):
            return cls.from_bytes(base64.b64decode(key_b64))

        def __init__(self, key):
            assert isinstance(key, RSAPublicKey)
            self.key = key
            self.pad_pss = padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH)
            self.pad_pkcs1v15 = padding.PKCS1v15()

        def verify(self, sig_bytes, msg_bytes, padding):
            if padding.lower() == 'pss':
                _SnGsH = self.pad_pss
            elif padding.lower() == 'pkcs1v15':
                _SnGsH = self.pad_pkcs1v15
            else:
                _ua34b = f'Unknown padding {padding}'
                raise ValueError(_ua34b)
            try:
                self.key.verify(sig_bytes, msg_bytes, _SnGsH, hashes.SHA256())
            except InvalidSignature:
                _ua34b = 'SLiM: RSA signature verification error. (Wrong key?)'
                raise _grrTa(_ua34b) from None

        def verify_response(self, *_stiQ7, **_gbTkY):
            _tFJtl, _EOEbT, _dP8rE = _I6KwN(*_stiQ7, **_gbTkY)
            if _tFJtl.lower() == 'rsa-pss-sha256':
                self.verify(_dP8rE, _EOEbT, padding='pss')
                return
            if _tFJtl.lower() == 'rsa-sha256':
                self.verify(_dP8rE, _EOEbT, padding='pkcs1v15')
                return
            _EOEbT = f'Unknown RSA alg {_tFJtl}'
            raise ValueError(_EOEbT)

    def _I6KwN(res):
        _ZmMSL = hashlib.sha256(res.content).digest()
        _fqbm1 = base64.b64encode(_ZmMSL).decode()
        if f'sha-256={_fqbm1}' != res.headers['Digest']:
            _8pBYi = 'SLiM: Invalid response digest'
            raise RuntimeError(_8pBYi)
        _I9yls = urlsplit(res.request.url)
        _bSeRV = '\n'.join([f'(request-target): {res.request.method.lower()} {res.request.path_url}', f'host: {_I9yls.netloc}', f"date: {res.headers['Date']}", f'digest: sha-256={_fqbm1}']).encode()
        _5DXh4 = _d9VlK(res.headers['Keygen-Signature'])
        return (_5DXh4['algorithm'], _bSeRV, base64.b64decode(_5DXh4['signature']))

    def _d9VlK(string):
        _hIU8C = {}
        for _IsHbu in re.split(',\\s*', string):
            _3OLZx = re.match('([^=]+)="([^"]+)"', _IsHbu)
            assert _3OLZx
            _hIU8C[_3OLZx.group(1)] = _3OLZx.group(2)
        return _hIU8C
    _wz2g0 = platformdirs.user_data_path('slim')
    _zia7O = platformdirs.user_cache_path('slim')

    def _ov8Ie(package, fallback='unknown'):
        try:
            return metadata.version(package)
        except metadata.PackageNotFoundError:
            return fallback

    def _AjU9I(dct, *_zubf1, default=None):
        for _xzjLl in _zubf1:
            try:
                dct = dct[_xzjLl]
            except (KeyError, TypeError, IndexError):
                return default
        return dct

    def _Ik2WM(obj, eps=timedelta(minutes=5)):
        if abs(obj - datetime.now(tz=timezone.utc)) > eps:
            _xwuhW = 'Error code E044'
            raise RuntimeError(_xwuhW)

    def _FdNsk(obj, eps=timedelta(minutes=5)):
        if obj > datetime.now(tz=timezone.utc) + eps:
            _LokHf = 'Error code E045'
            raise RuntimeError(_LokHf)

    def _HRray(ts, **_BPBQq):
        _FdNsk(datetime.fromtimestamp(ts, tz=timezone.utc), **_BPBQq)

    def _h36lw(res):
        _sezb4 = parsedate_to_datetime(res.headers['Date'])
        if getattr(res, 'from_cache', False):
            _FdNsk(_sezb4)
        else:
            _Ik2WM(_sezb4)

    def _wIZjh(td):
        _qbMbR = abs(td)
        if _qbMbR < timedelta(seconds=1):
            return 'just now'
        _lpOxR = td > timedelta(0)
        for _BelXO, _EdnDh, _bZ7te in [('second', _qbMbR.seconds, timedelta(minutes=1)), ('minute', round(_qbMbR.seconds / 60), timedelta(hours=1)), ('hour', round(_qbMbR.seconds / 3600), timedelta(days=1))]:
            if _qbMbR < _bZ7te:
                _GiwMa = '' if _EdnDh == 1 else 's'
                return f'in {_EdnDh} {_BelXO}{_GiwMa}' if _lpOxR else f'{_EdnDh} {_BelXO}{_GiwMa} ago'
        if _qbMbR.days < 100:
            _EdnDh = _qbMbR.days
            if _EdnDh == 0:
                return 'today'
            if _lpOxR:
                if _EdnDh == 1:
                    return 'tomorrow'
                return f'in {_EdnDh} days'
            if _EdnDh == 1:
                return 'yesterday'
            return f'{_EdnDh} days ago'
        if _qbMbR.days < 365:
            _EdnDh = round(_qbMbR.days / 30)
            _GiwMa = '' if _EdnDh == 1 else 's'
            if _lpOxR:
                return f'in {_EdnDh} month{_GiwMa}'
            return f'{_EdnDh} month{_GiwMa} ago'
        _EdnDh = round(_qbMbR.days / 365)
        _GiwMa = '' if _EdnDh == 1 else 's'
        if _lpOxR:
            return f'in {_EdnDh} year{_GiwMa}'
        return f'{_EdnDh} year{_GiwMa} ago'

    def _Kg6Hh(var_names):
        assert isinstance(var_names, (list, tuple))
        for _7vkcG in var_names:
            assert isinstance(_7vkcG, str)
            assert _7vkcG != ''
        for _ie6Yn, _zgNgv in [('global', globals()), ('environment', os.environ)]:
            for _brDwY in var_names:
                if _brDwY in _zgNgv:
                    yield (_ie6Yn, _brDwY, _zgNgv[_brDwY])

    def _MsQvA(string, k):
        return '\n'.join((string[_LVMxr:_LVMxr + k] for _LVMxr in range(0, len(string), k)))

    def _rjv4L(string):
        if sys.version_info >= (3, 11):
            return datetime.fromisoformat(string)
        try:
            return datetime.strptime(string, '%Y-%m-%dT%H:%M:%S.%f%z')
        except ValueError:
            return datetime.strptime(string, '%Y-%m-%dT%H:%M:%S%z')

    def _OQDlj(string, prefix):
        if sys.version_info >= (3, 9):
            return string.removeprefix(prefix)
        if string.startswith(prefix):
            return string[len(prefix):]
        return string

    def _3OMhO(*_EQdPt):
        for _RTeYw in _EQdPt:
            yield from _RTeYw

    def _yEHRf(function):

        def _dqpIl(*_lps1I, **_V95NX):
            _lps1I = [tuple(_MTEnR) if isinstance(_MTEnR, list) else _MTEnR for _MTEnR in _lps1I]
            _V95NX = {key: tuple(value) if isinstance(value, list) else value for key, value in _V95NX.items()}
            return function(*_lps1I, **_V95NX)
        _dqpIl.cache_clear = function.cache_clear
        return _dqpIl

    def _cfKjp(gen):
        cache = set()

        def _iZzjM(*_C0L8u, **_ddcoL):
            for _m9jlF in gen(*_C0L8u, **_ddcoL):
                if _m9jlF in cache:
                    continue
                yield _m9jlF
                cache.add(_m9jlF)
        return _iZzjM

    def _q4RXW(key):
        if key.startswith('DEMO'):
            return '1fddcec8-8dd3-4d8d-9b16-215cac0f9b52'
        return '109c23d2-6cdd-4faf-bd8a-96c242733638'
    try:
        from functools import cache
    except ImportError:
        from functools import lru_cache as cache

    @cache
    def _yBOr1():
        if _XlKi3():
            return 'google.colab'
        _QA7sf = _CrRxi()
        if _QA7sf:
            return f'github-actions/{_QA7sf}'
        _2MeJG = _YXTjD()
        if _2MeJG:
            return f'travis-ci/{_2MeJG}'
        _wZOZp = _EEeUM()
        if _wZOZp:
            return f'circle-ci/{_wZOZp}'
        _sIxmd = _yvR01()
        if _sIxmd:
            return 'gitlab-ci/{gitlab_project_namespace}'
        if _bYG1K():
            return 'jenkins'
        if _q2S0K():
            return 'docker'
        return machineid.id().strip()

    def _q2S0K():
        _DNGLu = Path('/proc/self/cgroup')
        return Path('/.dockerenv').is_file() or (_DNGLu.is_file() and 'docker' in _DNGLu.read_text())

    def _XlKi3():
        try:
            _q2Rh5 = find_spec('google.colab')
        except ModuleNotFoundError:
            return False
        return _q2Rh5 is not None

    def _CrRxi():
        if _s2Sy2([('CI', 'true'), ('GITHUB_ACTIONS', 'true'), 'GITHUB_ACTION', 'GITHUB_ACTION_REPOSITORY', 'GITHUB_ACTOR', 'GITHUB_ACTOR_ID', 'GITHUB_API_URL', 'GITHUB_BASE_REF', 'GITHUB_ENV', 'GITHUB_EVENT_NAME', 'GITHUB_EVENT_PATH', 'GITHUB_GRAPHQL_URL', 'GITHUB_HEAD_REF', 'GITHUB_JOB', 'GITHUB_PATH', 'GITHUB_REF', 'GITHUB_REF_NAME', 'GITHUB_REF_PROTECTED', 'GITHUB_REF_TYPE', 'GITHUB_REPOSITORY', 'GITHUB_REPOSITORY_ID', 'GITHUB_REPOSITORY_OWNER', 'GITHUB_REPOSITORY_OWNER_ID', 'GITHUB_RETENTION_DAYS', 'GITHUB_RUN_ATTEMPT', 'GITHUB_RUN_ID', 'GITHUB_RUN_NUMBER', 'GITHUB_SERVER_URL', 'GITHUB_SHA', 'GITHUB_STEP_SUMMARY', 'GITHUB_WORKFLOW', 'GITHUB_WORKFLOW_REF', 'GITHUB_WORKFLOW_SHA', 'GITHUB_WORKSPACE', 'RUNNER_ARCH', 'RUNNER_NAME', 'RUNNER_OS', 'RUNNER_TEMP', 'RUNNER_TOOL_CACHE']):
            return os.environ['GITHUB_REPOSITORY_OWNER']
        return None

    def _YXTjD():
        if _s2Sy2([('CI', 'true'), ('TRAVIS', 'true'), ('CONTINUOUS_INTEGRATION', 'true'), ('HAS_JOSH_K_SEAL_OF_APPROVAL', 'true'), ('USER', 'travis'), ('RAILS_ENV', 'test'), ('RACK_ENV', 'test'), ('MERB_ENV', 'test'), 'TRAVIS_ALLOW_FAILURE', 'TRAVIS_APP_HOST', 'TRAVIS_BRANCH', 'TRAVIS_BUILD_DIR', 'TRAVIS_BUILD_ID', 'TRAVIS_BUILD_NUMBER', 'TRAVIS_BUILD_WEB_URL', 'TRAVIS_COMMIT', 'TRAVIS_COMMIT_MESSAGE', 'TRAVIS_COMMIT_RANGE', 'TRAVIS_COMPILER', 'TRAVIS_DEBUG_MODE', 'TRAVIS_DIST', 'TRAVIS_REPO_SLUG']):
            _SoWqn, _oyT6X = os.environ['TRAVIS_REPO_SLUG'].split('/')
            return _SoWqn
        return None

    def _EEeUM():
        if _s2Sy2([('CI', 'true'), ('CIRCLE', 'true'), 'CIRCLE_BRANCH', 'CIRCLE_BUILD_NUM', 'CIRCLE_BUILD_URL', 'CIRCLE_JOB', 'CIRCLE_NODE_INDEX', 'CIRCLE_NODE_TOTAL', 'CIRCLE_OIDC_TOKEN', 'CIRCLE_OIDC_TOKEN_V2', 'CIRCLE_PR_NUMBER', 'CIRCLE_PR_REPONAME', 'CIRCLE_PR_USERNAME', 'CIRCLE_PROJECT_REPONAME', 'CIRCLE_PROJECT_USERNAME', 'CIRCLE_PULL_REQUEST', 'CIRCLE_PULL_REQUESTS', 'CIRCLE_REPOSITORY_URL', 'CIRCLE_SHA1', 'CIRCLE_TAG', 'CIRCLE_WORKFLOW_ID', 'CIRCLE_WORKFLOW_JOB_ID', 'CIRCLE_WORKFLOW_WORKSPACE_ID', 'CIRCLE_WORKING_DIRECTORY', 'CIRCLE_INTERNAL_TASK_DATA']):
            return os.environ['CIRCLE_PROJECT_USERNAME']
        return None

    def _yvR01():
        if _s2Sy2(['CHAT_CHANNEL', 'CHAT_INPUT', 'CHAT_USER_ID', 'CI', 'CI_API_V4_URL', 'CI_API_GRAPHQL_URL', 'CI_BUILDS_DIR', 'CI_COMMIT_AUTHOR', 'CI_COMMIT_BEFORE_SHA', 'CI_COMMIT_BRANCH', 'CI_COMMIT_DESCRIPTION', 'CI_COMMIT_MESSAGE', 'CI_COMMIT_REF_NAME', 'CI_COMMIT_REF_PROTECTED', 'CI_COMMIT_REF_SLUG', 'CI_COMMIT_SHA', 'CI_COMMIT_SHORT_SHA', 'CI_COMMIT_TIMESTAMP', 'CI_COMMIT_TITLE', 'CI_CONCURRENT_ID', 'CI_CONCURRENT_PROJECT_ID', 'CI_CONFIG_PATH', 'CI_DEBUG_TRACE', 'CI_DEBUG_SERVICES', 'CI_DEFAULT_BRANCH', 'CI_DEPENDENCY_PROXY_GROUP_IMAGE_PREFIX', 'CI_DEPENDENCY_PROXY_DIRECT_GROUP_IMAGE_PREFIX', 'CI_DEPENDENCY_PROXY_PASSWORD', 'CI_DEPENDENCY_PROXY_SERVER', 'CI_DEPENDENCY_PROXY_USER', 'CI_DEPLOY_FREEZE', ('GITLAB_CI', 'true'), 'GITLAB_FEATURES', 'GITLAB_USER_EMAIL', 'GITLAB_USER_ID', 'GITLAB_USER_LOGIN', 'GITLAB_USER_NAME']):
            return os.environ['CI_PROJECT_NAMESPACE']
        return None

    def _bYG1K():
        return _s2Sy2(['BUILD_NUMBER', 'BUILD_ID', 'BUILD_DISPLAY_NAME', 'JOB_NAME', 'BUILD_TAG', 'EXECUTOR_NUMBER', 'NODE_NAME', 'NODE_LABELS', 'WORKSPACE', 'JENKINS_HOME', 'JENKINS_URL', 'BUILD_URL', 'JOB_URL'])

    def _s2Sy2(keys):
        for _9v8JJ in keys:
            if isinstance(_9v8JJ, str):
                if _9v8JJ not in os.environ:
                    return False
            else:
                assert isinstance(_9v8JJ, tuple)
                _avvTS, _3KdhU = _9v8JJ
                if _AjU9I(os.environ, _avvTS) != _3KdhU:
                    return False
        return True

    class _NDyKX(Protocol):
        key_type: str

        @property
        def data(self):
            ...

        @property
        def key(self):
            ...

        @property
        def product_name(self):
            ...

        @property
        def product_id(self):
            ...

        @property
        def vendor_name(self):
            ...

        @property
        def license_id(self):
            ...

        @property
        def user(self):
            ...

        @property
        def created(self):
            ...

        @property
        def expiry(self):
            ...

        @property
        def max_machines(self):
            ...

        @property
        def num_machines(self):
            ...

        @property
        def usage_type(self):
            return None

        @property
        def activations(self):
            return (None, None)

        def list_machines(self):
            ...

        def prettyprint(self, show_key=False):
            ...

        def _prettyprint(self, is_valid, validation_code=None, show_key=False):
            _19090 = Table(box=None, padding=(0, 4, 0, 0), show_header=False)
            if self.product_name:
                _19090.add_row('Product', Text(self.product_name, style='cyan'))
            else:
                _19090.add_row('Product ID', str(self.product_id))
            if self.vendor_name:
                _19090.add_row('Vendor', self.vendor_name)
            if self.license_id:
                _19090.add_row('License ID', str(self.license_id))
            if show_key and self.key:
                _19090.add_row('Key', self.key)
            if self.usage_type:
                _19090.add_row('Usage type', Text(self.usage_type.title(), style='blue'))
            _ytME0 = None
            if is_valid is True:
                _19090.add_row('Valid', Text('True', style='green'))
                _ytME0 = 'green'
            elif is_valid is False:
                _AAqyg = 'False'
                if validation_code:
                    _AAqyg += f' ({validation_code})'
                _19090.add_row('Valid', Text(_AAqyg, style='red'))
                _ytME0 = 'red'
            else:
                assert is_valid == 'unknown'
                _AAqyg = 'Unknown'
                if validation_code:
                    _AAqyg += f' ({validation_code})'
                _19090.add_row('Valid', Text(_AAqyg, style='yellow'))
                _ytME0 = 'bright_black'
            if (email := _AjU9I(self.user, 'email')):
                _19090.add_row('User', email)
            if self.created:
                _19090.add_row('Created', self.created.strftime('%Y-%m-%d'))
            _x0IAZ = datetime.now(tz=timezone.utc)
            if self.expiry:
                _l4tWM = self.expiry - _x0IAZ
                if _l4tWM < timedelta(0):
                    _X435U = 'red'
                    _ytME0 = 'red'
                elif _l4tWM.days < 30:
                    _X435U = 'yellow'
                    if _ytME0 != 'red':
                        _ytME0 = 'yellow'
                else:
                    _X435U = None
                _19090.add_row('Expiry', Text(f"{self.expiry.strftime('%Y-%m-%d')} ({_wIZjh(_l4tWM)})", style=_X435U))
            _ginLT, _B4BMO = self.activations
            if _ginLT is not None:
                _JXdJ6 = None
                _AAqyg = str(_ginLT)
                if _B4BMO is not None:
                    if _ginLT >= _B4BMO:
                        _JXdJ6 = 'yellow'
                    _AAqyg += f'/{_B4BMO}'
                _19090.add_row('Activations', Text(_AAqyg, style=_JXdJ6))
            if self.num_machines is not None:
                _AAqyg = str(self.num_machines)
                if self.max_machines is not None:
                    _AAqyg += f'/{self.max_machines}'
                _19090.add_row('Seats used', _AAqyg)
            for _l5XDX, _M84l3 in enumerate(self.list_machines()):
                assert isinstance(_M84l3, dict)
                _4XPYH = _AjU9I(_M84l3, 'hostname') or f'machine {_l5XDX}'
                _QDbbQ = []
                _oegII = False
                if (fp := _AjU9I(_M84l3, 'fingerprint')):
                    _QDbbQ.append(fp)
                    _oegII = fp == _yBOr1()
                _VpUBW = _4XPYH
                if _oegII:
                    _VpUBW = f'[bold]{_VpUBW}[/]'
                if _QDbbQ:
                    _VpUBW += f" ({', '.join(_QDbbQ)})"
                _19090.add_row('Machines' if _l5XDX == 0 else '', _VpUBW)
            _TqByd = Panel(_19090, title_align='left', border_style=_ytME0)
            _T3LOy(_TqByd)

    class _x1PTq:
        name = 'Monday Tech'
        email = 'support@mondaytech.com'
        products_codes = ('stp01',)
    _cOgVn = {product_code: vendor for vendor in [_x1PTq] for product_code in vendor.products_codes}

    def _gALpv(product_code):
        try:
            return _cOgVn[product_code]
        except KeyError:
            _mso5l = f"Cannot use SLiM with LicenseSpring product code {product_code}... If you'd like to use the Stonefish License Manager, contact support@mondaytech.com"
            raise _IExoO(_mso5l, 'CL_VENDOR_ERROR') from None
    _GRDYc = platformdirs.user_data_path('slim', 'MondayTech') / 'license_spring'
    _qjKii = _C7C50(base64.b64decode('MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAwEt7ZQWSzeBYNBwyi3KW+XU/6I+ju90R5ZpTvSE4VWL8KSgVJ6bWKIhaKTL2hbUpIQQgS5ZKfa4SEEMdIm5kxe0u2F64JFAVQunx/1O/UXsD7ADVt93Q/hxA9Npa16tKepZoyhi79sxpaxyy/WTdsZKuTLApX7bWX6/XPhaPjNyiWeeK2Naka44B+F+PwN/ey3rZUra3pBltShwy2dmKIxJVmprf5ttMYBB+ouqPin3VgDw5Jq1FZwpLBiOe+ogR+sHu7QYWwLq6AgC4e3JqgryEvqfJr/XkvOnAdcAIZm6tK6DdnLWCy6Onrk7t0VQK5nnGF1CKE+jcAByWopcIVCwfYrs1UCSY1YibKXNJoyvEhgLyCC+KAgXKf8omcg1Q18XKu5XSrvrCzXLnRnaFNpFDjcg5AJJab78hX7qGPC+e8PjuBYwh2vtx5mFj7/c+T59JM/vXwwvW9DsnDztDWEDFhzGanU71NgwrZbRoNSyTW0UjbZsyJVSIX6233Ng0y5L9mDe8p8P+u1B0sXAAozEKL/yG4Qu5r4LIw4iv6JVPT1xbWlH4Vc4KaN3toaf4+G0EkFy6ncvBncWifLARSoWpQ5YsygDdQNVYdmMsoQ76UTuNxo3eZ0sQJjbQVBqlkcXrAdtUCpuojPRsl/Xs9zVOJrzZPG0I98E5quNbRkMCAwEAAQ=='))
    _ODxP9 = 'https://api.licensespring.com/api/v4'
    logging.getLogger('requests_cache.session').setLevel(logging.ERROR)
    _YGZnx = requests_cache.CachedSession(cache_name=_zia7O / 'license_spring', expire_after=timedelta(days=3), stale_while_revalidate=timedelta(days=4))

    class _9tsH8(_NDyKX):
        key_type = 'License Spring'

        @classmethod
        def from_file(cls, path):
            with Path(path).open() as _y0Dw2:
                _4vxtc = _y0Dw2.read()
            try:
                _XPGQq = base64.b64decode(_4vxtc)
            except binascii.Error:
                _C6yad = f'Invalid license file {path}'
                raise _IExoO(_C6yad, 'LS_INVALID_FILE') from None
            _SoZCV = json.loads(_XPGQq)
            _lvvSw = base64.b64decode(_SoZCV.pop('license_signature_v2'))
            _OZU5B = json.dumps(_SoZCV, separators=(',', ':')).encode()
            _qjKii.verify(_lvvSw, _OZU5B, padding='pkcs1v15')
            _FdNsk(datetime.strptime(_SoZCV['date'], '%a %b %d %Y %H:%M:%S GMT%z'))
            return cls(_SoZCV)

        @classmethod
        def from_key(cls, product_code, license_key):
            _ovO6U = {'product_details': {'short_code': product_code}, 'license_key': license_key}
            return cls(_ovO6U)

        def __init__(self, data):
            assert isinstance(data, dict)
            assert _AjU9I(data, 'license_key')
            _H2mCq = _AjU9I(data, 'product_details', 'short_code')
            assert _H2mCq
            self.vendor = _gALpv(_H2mCq)
            self._data = data

        @property
        def data(self):
            return self._data

        @property
        def license_id(self):
            return _AjU9I(self.data, 'id')

        @property
        def product_id(self):
            return _AjU9I(self.data, 'product_details', 'product_id')

        @property
        def product_code(self):
            return self.data['product_details']['short_code']

        @property
        def product_name(self):
            return _AjU9I(self.data, 'product_details', 'product_name')

        @property
        def key(self):
            return self.data['license_key']

        @property
        def created(self):
            if (date := _AjU9I(self.data, 'date')):
                return datetime.strptime(date, '%a %b %d %Y %H:%M:%S GMT%z')
            return None

        @property
        def expiry(self):
            if (vp := self.data.get('validity_period')):
                return _rjv4L(vp)
            return None

        @property
        def user(self):
            user = _AjU9I(self.data, 'customer')
            if not user:
                return {}
            _4hFCi = []
            if (fn := user['first_name']):
                _4hFCi.append(fn)
            if (ln := user['last_name']):
                _4hFCi.append(ln)
            return {'name': ' '.join(_4hFCi) if _4hFCi else None, 'email': user['email'] or None}

        @property
        def vendor_name(self):
            return self.vendor.name

        def list_machines(self):
            return []

        def validate(self, shared_key, api_key, activate_if_required=True, raise_on_error=True, cache_force_refresh=False, cache_expire_after=None):
            _I2cio = _YGZnx.get(url=f'{_ODxP9}/check_license', headers=_gQaAW(shared_key, api_key), params={'product': self.product_code, 'hardware_id': _yBOr1(), 'license_key': self.key}, force_refresh=cache_force_refresh, expire_after=cache_expire_after)
            _ylbix(_I2cio)
            _h36lw(_I2cio)
            data = _I2cio.json()
            if data.get('code') in {'license_not_active', 'device_not_found'} and activate_if_required:
                self.activate(shared_key, api_key)
                _9D90X()
                return self.validate(shared_key, api_key, activate_if_required=activate_if_required, raise_on_error=raise_on_error, cache_force_refresh=True)
            if not _I2cio.ok and raise_on_error:
                raise _IExoO(data['message'], 'LS_VALIDATION_ERROR')
            self._data = data
            return data

        def activate(self, shared_key, api_key, app_version=None):
            data = {'product': self.product_code, 'hardware_id': _yBOr1(), 'license_key': self.key, 'os_ver': platform.platform(), 'hostname': socket.gethostname(), 'mac_address': ':'.join((f'{_w4kQo:02x}' for _w4kQo in uuid.getnode().to_bytes(6, byteorder='big')))}
            _sAKVG = _ov8Ie('stonefish-license-manager')
            data['sdk_ver'] = f'Stonefish License Manager {_sAKVG}'
            if app_version:
                data['app_ver'] = app_version
            _AsBha = requests.post(url=f'{_ODxP9}/activate_license', headers=_gQaAW(shared_key, api_key), json=data, timeout=10)
            _ylbix(_AsBha)
            _h36lw(_AsBha)
            json = _AsBha.json()
            if not _AsBha.ok:
                raise _IExoO(json['message'], 'LS_ACTIVATION_ERROR')
            return json

        def deactivate(self, shared_key, api_key):
            _RhJRT = requests.post(url=f'{_ODxP9}/deactivate_license', headers=_gQaAW(shared_key, api_key), json={'product': self.product_code, 'hardware_id': _yBOr1(), 'license_key': self.key}, timeout=10)
            _h36lw(_RhJRT)
            if not _RhJRT.ok:
                json = _RhJRT.json()
                raise _IExoO(json['message'], 'LS_DEACTIVATION_ERROR')
            return

        def prettyprint(self, show_key=False):
            super()._prettyprint(show_key=show_key, is_valid='unknown', validation_code=None)

    def _OCXOm():
        _YGZnx.cache.clear()

    def _9D90X():
        for _Z3rts in _YGZnx.cache.responses.values():
            if _Z3rts.url == f'{_ODxP9}/check_license':
                _YGZnx.cache.delete(_Z3rts.cache_key)

    def _gQaAW(shared_key, api_key):
        _0RjMA = format_date_time(time.time())
        _dobBw = hmac.new(bytes(shared_key, 'utf-8'), f'licenseSpring\ndate: {_0RjMA}'.encode(), hashlib.sha256).digest()
        _5LV3i = base64.b64encode(_dobBw).decode()
        _wOI0k = ','.join(['algorithm="hmac-sha256"', 'headers="date"', f'signature="{_5LV3i}"', f'apiKey="{api_key}"'])
        return {'Content-Type': 'application/json', 'Date': _0RjMA, 'Authorization': _wOI0k}

    def _DxXkN(product_code, shared_key, api_key):
        _v6MOw = _YGZnx.get(url=f'{_ODxP9}/product_details', params={'product': product_code}, headers=_gQaAW(shared_key, api_key), timeout=10)
        _ylbix(_v6MOw)
        _h36lw(_v6MOw)
        _BdcO3 = _v6MOw.json()
        if not _v6MOw.ok:
            raise _IExoO(_BdcO3['message'], 'LS_PRODUCT_ERROR')
        return _BdcO3

    def _ylbix(res):
        if (sig := res.headers.get('LicenseSignature')):
            _qjKii.verify(base64.b64decode(sig), res.content, padding='pkcs1v15')

    @dataclass
    class _ztu27:
        name: str
        email: str | None
        product_ids: tuple[int]
        verify_key: VerifyKey
    _FIsUW = _ztu27('Monday Tech', 'support@mondaytech.com', (21778,), _mgVsN(base64.b64decode('MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxfz7XiRe459sYB/PxgoMR0VKX0aA0rC+FPV8G7h02DHiYYKmtsI3o1kq7w3I6JKHpU8VnCEy2P6+W+8A0fdgTIQZJiKTsuJ7ymtX3hT/TyuIVveOsLBd5OHr0Prh/sshv4kFJTUYAROGtRVR/p/Ut2XTSaQIj02Zv9Yd8v1gMF8BsRgShG3Omyo+TfxA2OvXnlqCcSumyk2pfLtdkuGX0a5gTsG7kqY1e0RWB8LN0Ko7fCPCXuy1i/auwtGt/YALh+vL02RWb7CZSMvPEWJGh6WPwhcvywyRlEgFnKB3Ec1j3DcgUNXVQXHSYrbmveXfMkjpxokDIGWcbD3HY0agGwIDAQAB')))
    _VXTYt = _ztu27('Deecie', None, (23488,), _mgVsN(base64.b64decode('MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArCITfOmahfX98LErjl8C22YRDpJjeQPJACSxBjEOAwjOwFoUNeEwVZyif0thbZVjZh4/Zp/413RoxQgSeWfoaZqsnvTV5iWBk3tN8wILmR4305fpjJHnrobJDyKoz9VUQRzwVtOkT3pbIeP/WrIz+937FO5Z2F76tMmMMlNtWgMCIEc8BT97yZPB5wXSWYozQ6WfNlm9/L2ajMce4P6kX1nKwBYkxY+MBG+7YyF66on7mG3LJUa/H1ZGVLpPNVpbd5WOL7f/vXE/RGYcwfSeQGiLEUxcwtsFhtfbjBivwxMSshOW7WLIgaC3lFKNWnT5sIeRGTeSvbFpVR5ERaiwhwIDAQAB')))
    _OJKpt = {product_id: vendor for vendor in [_FIsUW, _VXTYt] for product_id in vendor.product_ids}

    def _DmagY(product_id):
        assert isinstance(product_id, int)
        try:
            return _OJKpt[product_id]
        except KeyError:
            _JRwTk = f"Cannot use SLiM with Cryptolens product ID {product_id}. If you'd like to use the Stonefish License Manager, contact support@mondaytech.com"
            raise _IExoO(_JRwTk, 'CL_VENDOR_ERROR') from None
    _1Wo24 = 'https://api.cryptolens.io/api'
    logging.getLogger('requests_cache.session').setLevel(logging.ERROR)
    _K73AI = requests_cache.CachedSession(cache_name=_zia7O / 'cryptolens', expire_after=timedelta(days=3), stale_while_revalidate=timedelta(days=4))

    class _Ty7bI(_NDyKX):
        key_type = 'Cryptolens'

        @classmethod
        def from_key(cls, product_id, key):
            assert isinstance(product_id, int)
            return cls({'ProductId': product_id, 'Key': key})

        @classmethod
        def from_file(cls, path, token, update_if_older_than=timedelta(days=30)):
            path = Path(path)
            assert path.suffix == '.skm'
            with path.open() as _j3J7I:
                _bjbR1 = json.load(_j3J7I)
            _NlaoJ = base64.b64decode(_bjbR1['signature'])
            _DgqRQ = base64.b64decode(_bjbR1['licenseKey'])
            _0XvQ2 = json.loads(_DgqRQ)
            _hPFtE = _DmagY(_0XvQ2['ProductId'])
            _hPFtE.verify_key.verify(sig_bytes=_NlaoJ, msg_bytes=_DgqRQ, padding='pkcs1v15')
            _HRray(_0XvQ2['SignDate'])
            _HRray(_0XvQ2['Created'])
            if not token:
                for _X1Wnl in _0XvQ2['DataObjects']:
                    if _X1Wnl['Name'] == 'token':
                        token = _X1Wnl['StringValue']
                        break
            _WSVoG = datetime.now(tz=timezone.utc)
            _ujBg9 = datetime.fromtimestamp(_0XvQ2['SignDate'], tz=timezone.utc)
            if token is not None and update_if_older_than and (_WSVoG > _ujBg9 + update_if_older_than):
                _bjbR1, _0XvQ2 = _aMJCd(_0XvQ2['ProductId'], _0XvQ2['Key'], token, activate=False)
                _HRray(_0XvQ2['SignDate'])
                _HRray(_0XvQ2['Created'])
                with path.open('w') as _rPecC:
                    json.dump(_bjbR1, _rPecC)
            return cls(_0XvQ2)

        def __init__(self, data):
            assert isinstance(data, dict)
            assert isinstance(_AjU9I(data, 'ProductId'), int)
            assert isinstance(_AjU9I(data, 'Key'), str)
            self._data = data
            super().__init__()

        @property
        def data(self):
            return self._data

        @property
        def key(self):
            return self.data['Key']

        @property
        def license_id(self):
            return self.data['GlobalId']

        @property
        def product_id(self):
            return self.data['ProductId']

        @property
        def created(self):
            return datetime.fromtimestamp(self.data['Created'], tz=timezone.utc)

        @property
        def product_name(self):
            for _23GFz in self.data['DataObjects']:
                if _23GFz['Name'] == 'productName':
                    return _23GFz['StringValue']
            return None

        def get_token(self):
            for _5J7NY in self.data['DataObjects']:
                if _5J7NY['Name'] == 'token':
                    return _5J7NY['StringValue']
            return None

        @property
        def expiry(self):
            if not self.data['F1']:
                return None
            if (expiry := _AjU9I(self.data, 'Expires')):
                return datetime.fromtimestamp(expiry, tz=timezone.utc)
            return None

        @property
        def user(self):
            return {'email': _AjU9I(self.data, 'Customer', 'email')}

        @property
        def max_machines(self):
            return self.data['MaxNoOfMachines']

        @property
        def num_machines(self):
            return len(self.data['ActivatedMachines'])

        def list_machines(self):
            return self.data['ActivatedMachines']

        def validate(self, token, activate=True, raise_on_error=True):
            assert isinstance(token, str)
            _n1XfB, data = _aMJCd(self.product_id, self.key, token, activate=activate, raise_on_error=raise_on_error)
            _zHQun = _n1XfB['metadata']['licenseStatus']
            if _n1XfB['result'] != 0:
                raise _IExoO(_n1XfB['message'], 'CL_RESULT_ERROR')
            if raise_on_error:
                if not _zHQun['isValid']:
                    raise _IExoO(*_XVLmH(_zHQun['reasonForInvalidity']))
                expiry = datetime.fromtimestamp(data['Expires'], tz=timezone.utc)
                if datetime.now(tz=timezone.utc) > expiry + timedelta(minutes=5):
                    _UNaJV = f'License has expired on {expiry}'
                    raise _IExoO(_UNaJV, 'CL_EXPIRED')
            _HRray(data['SignDate'])
            _HRray(data['Created'])
            self._data = data
            return _zHQun

        def prettyprint(self, show_key=False):
            _V6MZz: bool | Literal['unknown'] = 'unknown'
            _CWJco: str | None = None
            if (token := self.get_token()):
                _Kel6c = self.validate(token, activate=False, raise_on_error=False)
                _V6MZz = _AjU9I(_Kel6c, 'isValid')
                assert isinstance(_V6MZz, bool)
                if _V6MZz is False:
                    _cOh1X, _CWJco = _XVLmH(_Kel6c['reasonForInvalidity'])
            super()._prettyprint(show_key=show_key, is_valid=_V6MZz, validation_code=_CWJco)

    def _aMJCd(product_id, key, token, activate=True, raise_on_error=True):
        _e4ncO = {'token': token, 'ProductId': product_id, 'Key': key, 'Metadata': True, 'ModelVersion': 3, 'Sign': True, 'SignMethod': 1}
        if activate:
            _jj5W3 = f'{_1Wo24}/key/Activate'
            _e4ncO['MachineCode'] = _yBOr1()
        else:
            _jj5W3 = f'{_1Wo24}/key/GetKey'
        _THhck = _K73AI.get(_jj5W3, params=_e4ncO)
        _1H2Go = _THhck.json()
        if not _THhck.ok:
            _1gdM9 = f"CryptoLens: {_1H2Go['message']}"
            raise _IExoO(_1gdM9, 'CL_REQUEST_ERROR')
        if raise_on_error:
            if _1H2Go['result'] != 0:
                raise _IExoO(_1H2Go['message'], 'CL_RESULT_ERROR')
            _NFovB = _1H2Go['metadata']['licenseStatus']
            if not _NFovB['isValid']:
                raise _IExoO(*_XVLmH(_NFovB['reasonForInvalidity']))
        _Ys3VW = base64.b64decode(_1H2Go['signature'])
        _l0zR8 = base64.b64decode(_1H2Go['licenseKey'])
        _DmagY(product_id).verify_key.verify(sig_bytes=_Ys3VW, msg_bytes=_l0zR8, padding='pkcs1v15')
        _h36lw(_THhck)
        return (_1H2Go, json.loads(_l0zR8))

    def _XVLmH(reason_for_invalidity):
        if reason_for_invalidity == 1:
            return ('License expired', 'CL_EXPIRED')
        if reason_for_invalidity == 2:
            return ('License blocked', 'CL_BLOCKED')
        return ('License validation failed', 'CL_FAILED_VALIDATION')

    def _66o7T():
        _K73AI.cache.clear()
    if TYPE_CHECKING:
        from datetime import timedelta
        from pathlib import Path
    _YMyHP = _wz2g0 / 'cryptolens'

    def _mrjlq(file):
        _TBSS2 = _Ty7bI.from_file(file, update_if_older_than=None, token=None)
        _5rzBD = _TBSS2.data['ProductId']
        _VLLiZ = _TBSS2.data['GlobalId']
        _FIV1c = _YMyHP / str(_5rzBD) / (str(_VLLiZ) + '.skm')
        _FIV1c.parent.mkdir(parents=True, exist_ok=True)
        shutil.copyfile(file, _FIV1c)
        return _TBSS2

    @_cfKjp
    def _b249k(license_keys_or_ids=None, product_id=None, token=None, update_if_older_than=None):
        assert license_keys_or_ids is None or isinstance(license_keys_or_ids, set)
        _frEAK = _YMyHP
        if product_id:
            _frEAK /= str(product_id)
        for _eVnHq in _frEAK.rglob('*.skm'):
            _wIuq6 = _Ty7bI.from_file(_eVnHq, token=token, update_if_older_than=update_if_older_than)
            if license_keys_or_ids is None:
                yield (_eVnHq, _wIuq6)
            else:
                _uvt6T = str(_AjU9I(_wIuq6.data, 'GlobalId'))
                if _uvt6T in license_keys_or_ids:
                    license_keys_or_ids.remove(_uvt6T)
                    yield (_eVnHq, _wIuq6)
                    continue
                _W7NlB = _AjU9I(_wIuq6.data, 'Key')
                if _W7NlB in license_keys_or_ids:
                    license_keys_or_ids.remove(_W7NlB)
                    yield (_eVnHq, _wIuq6)
                    continue
    try:
        from functools import cache
    except ImportError:
        from functools import lru_cache as cache

    @_yEHRf
    @cache
    def _DQbEy(product_id, token, variable_names=()):
        for _mBaqi in _3OMhO(_uGiOh(product_id, variable_names), (lic for _, lic in _b249k(product_id=product_id, token=token, update_if_older_than=timedelta(days=30)))):
            try:
                lic.validate(token)
            except _IExoO:
                continue
            if product_id != lic.product_id:
                continue
            return lic
        _4MUIr = f'Unable to find valid license for product ID {product_id}. \n\nAdd a license with\n\n    slim install <your-license>\n'
        raise _IExoO(_4MUIr, 'CL_NOT_FOUND')

    def _uGiOh(product_id, var_names):
        for _hElTJ, _nPVWr, _HVItR in _Kg6Hh(var_names):
            yield _Ty7bI.from_key(product_id, _HVItR)

    def _rfWGL(license_string):
        assert not license_string.startswith('key/')
        if license_string.startswith('fp/'):
            return (license_string[3:], True)
        return (license_string, False)

    def _tyls6(string, prefix, suffix):
        if sys.version_info >= (3, 9):
            return string.removeprefix(prefix).removesuffix(suffix)
        if string.startswith(prefix):
            string = string[len(prefix):]
        if string.endswith(suffix):
            string = string[:-len(suffix)]
        return string

    @dataclass
    class _95m2g:
        name: str
        email: str | None
        account_id: str
        verify_key: Ed25519
    _hJ6UX = _95m2g(name='Monday Tech', email='support@mondaytech.com', account_id='109c23d2-6cdd-4faf-bd8a-96c242733638', verify_key=_BAF5H.from_hex('cee3f0572684018bd7e4c77ed82c91b6631ebd110ed8cdcf8ecfc8e2d4cf41e1'))
    _HP7Fh = _95m2g(name='Keygen demo', email=None, account_id='1fddcec8-8dd3-4d8d-9b16-215cac0f9b52', verify_key=_BAF5H.from_hex('e8601e48b69383ba520245fd07971e983d06d22c4257cfd82304601479cee788'))
    _XrTmb = {vendor.account_id: vendor for vendor in [_hJ6UX, _HP7Fh]}

    def _ZvcvQ(account_id):
        try:
            return _XrTmb[account_id]
        except KeyError:
            _WVCST = f"Cannot use SLiM with Keygen account_id {account_id}. If you'd like to use the Stonefish License Manager, contact support@mondaytech.com"
            raise _IExoO(_WVCST, 'KG_VENDOR_ERROR') from None

    class _tZ8BM(_NDyKX):
        key_type = 'Keygen offline'

        @classmethod
        def from_file(cls, path):
            assert isinstance(path, (str, Path))
            path = Path(path)
            with path.open() as _zX4Xt:
                _ndaeD = _zX4Xt.read().strip().replace('\n', '')
            assert _ndaeD, f'Empty license file {path}'
            return cls(_ndaeD)

        def __init__(self, key):
            assert isinstance(key, str)
            key = key.strip().replace('\n', '')
            _b9BQb = 'key/'
            if not key.startswith(_b9BQb):
                _sjhrW = f'Expected prefix key/, got {key[:len(_b9BQb)]}...'
                raise ValueError(_sjhrW)
            self._key = key
            _aMcsN, _GHG9U = self._key.split('.')
            _N8FH7 = base64.urlsafe_b64decode(_GHG9U)
            self._data = json.loads(base64.urlsafe_b64decode(_aMcsN[len(_b9BQb):]))
            _rgf05 = _AjU9I(self._data, 'account', 'id')
            if not _rgf05:
                _sjhrW = 'Key lacks account ID'
                raise _IExoO(_sjhrW, 'KG_MISSING_ACCOUNT_ID')
            self.vendor: Vendor = _ZvcvQ(_rgf05)
            _Mcw8A = self.vendor.verify_key
            if isinstance(_Mcw8A, _Gpcpm):
                _Mcw8A.verify(_N8FH7, _aMcsN.encode(), padding='pss')
            else:
                _Mcw8A.verify(_N8FH7, _aMcsN.encode())

        @property
        def data(self):
            return self._data

        @property
        def key(self):
            return self._key

        @property
        def account_id(self):
            return _AjU9I(self.data, 'account', 'id')

        @property
        def product_id(self):
            return self.data['product']['id']

        @property
        def product_name(self):
            return None

        @property
        def license_id(self):
            return self.data['license']['id']

        @property
        def created(self):
            return _rjv4L(self.data['license']['created'])

        @property
        def expiry(self):
            if (expiry := _AjU9I(self.data, 'license', 'expiry')):
                return _rjv4L(expiry)
            return None

        @property
        def max_machines(self):
            return None

        @property
        def num_machines(self):
            return None

        @property
        def vendor_name(self):
            return self.vendor.name

        @property
        def user(self):
            if (user := _AjU9I(self.data, 'user')):
                return {'id': _AjU9I(user, 'id'), 'email': _AjU9I(user, 'email')}
            return {}

        def list_machines(self):
            return []

        def validate(self, raise_on_error=True):
            _0aws2 = datetime.now(tz=timezone.utc)
            created = _AjU9I(self.data, 'license', 'created')
            if created and _0aws2 < _rjv4L(created) - timedelta(minutes=5):
                if raise_on_error:
                    _I00Se = 'Invalid license'
                    raise _IExoO(_I00Se, 'KG_E043')
                return {'valid': False, 'code': 'KG_E043', 'detail': 'Unknown error E043'}
            expiry = _AjU9I(self.data, 'license', 'expiry')
            if expiry and _0aws2 > _rjv4L(expiry) + timedelta(minutes=5):
                if raise_on_error:
                    _I00Se = f'License has expired on {expiry}'
                    raise _IExoO(_I00Se, 'KG_EXPIRED')
                return {'valid': False, 'code': 'KG_EXPIRED', 'detail': 'License has expired'}
            return {'valid': True, 'code': 'VALID', 'detail': 'is valid'}

        def prettyprint(self, show_key=False):
            _XEPRZ = self.validate(raise_on_error=False)
            super()._prettyprint(show_key=show_key, is_valid=_XEPRZ['valid'], validation_code=_XEPRZ['code'])
    logging.getLogger('requests_cache.session').setLevel(logging.ERROR)
    _Z5FuV = '1.3'
    _yykO3 = requests_cache.CachedSession(cache_name=_zia7O / 'keygen', expire_after=timedelta(days=3), stale_while_revalidate=timedelta(days=4), allowable_methods=['GET', 'HEAD', 'POST'])

    class _BPR43(_NDyKX):
        key_type = 'Keygen online'

        @classmethod
        def from_key(cls, account_id, key):
            assert account_id
            assert isinstance(key, str)
            assert not key.startswith('key/')
            return cls({'attributes': {'key': key}, 'relationships': {'account': {'data': {'id': account_id}}}})

        def __init__(self, data):
            assert isinstance(data, dict)
            assert 'data' not in data
            self._data = data
            _aykHI = data['relationships']['account']['data']['id']
            self.base_url = f'https://api.keygen.sh/v1/accounts/{_aykHI}'
            self.vendor = _ZvcvQ(_aykHI)
            self.verify_response = self.vendor.verify_key.verify_response
            super().__init__()

        @property
        def data(self):
            return self._data

        @property
        def key(self):
            return self.data['attributes']['key']

        @property
        def auth(self):
            return f'License {self.key}'

        @property
        def license_id(self):
            return _AjU9I(self.data, 'id')

        @property
        def license_key(self):
            return self.data['attributes']['key']

        @property
        def account_id(self):
            return _AjU9I(self.data, 'relationships', 'account', 'data', 'id')

        @property
        def product_id(self):
            return _AjU9I(self.data, 'relationships', 'product', 'data', 'id')

        @property
        def product_name(self):
            return _AjU9I(self.data, 'attributes', 'metadata', 'productName')

        @property
        def usage_type(self):
            return _AjU9I(self.data, 'attributes', 'metadata', 'usageType')

        @property
        def activations(self):
            _ZliBF = _AjU9I(self.data, 'attributes', 'metadata', 'tokenId')
            if not _ZliBF:
                return (None, None)
            _6DhZB = _yykO3.get(f'{self.base_url}/tokens/{_ZliBF}', headers={'Content-Type': 'application/vnd.api+json', 'Accept': 'application/vnd.api+json', 'Authorization': self.auth, 'Keygen-Version': _Z5FuV}, timeout=10)
            _6DhZB.raise_for_status()
            data = _6DhZB.json()
            _3tLqa = data['data']['attributes']
            return (_3tLqa['activations'], _3tLqa['maxActivations'])

        @property
        def vendor_name(self):
            return self.vendor.name

        @property
        def created(self):
            if (created := _AjU9I(self.data, 'attributes', 'created')):
                return _rjv4L(created)
            return None

        @property
        def expiry(self):
            if (expiry := _AjU9I(self.data, 'attributes', 'expiry')):
                return _rjv4L(expiry)
            return None

        @property
        def num_machines(self):
            return _AjU9I(self.data, 'relationships', 'machines', 'meta', 'count')

        @property
        def max_machines(self):
            return _AjU9I(self.data, 'attributes', 'maxMachines')

        def list_machines(self):
            try:
                _VtYYC = self.get_machines()
            except requests.exceptions.ReadTimeout:
                return []
            _ormg8 = []
            for _OFMup in _VtYYC:
                _XjpnC = _AjU9I(_OFMup, 'attributes', 'fingerprint')
                _R0n5r = {'hostname': _AjU9I(_OFMup, 'attributes', 'hostname'), 'requireHeartbeat': _AjU9I(_OFMup, 'attributes', 'requireHeartbeat'), 'heartbeatStatus': _AjU9I(_OFMup, 'attributes', 'heartbeatStatus'), 'fingerprint': _XjpnC}
                if (lhb := _AjU9I(_OFMup, 'attributes', 'lastHeartbeat')):
                    _R0n5r['lastHeartbeat'] = _rjv4L(lhb)
                if (created := _AjU9I(_OFMup, 'attributes', 'created')):
                    _R0n5r['created'] = _rjv4L(created)
                _ormg8.append(_R0n5r)
            return _ormg8

        @property
        def user(self):
            metadata = self.data['attributes']['metadata']
            _xDcAW = _AjU9I(metadata, 'email') or _AjU9I(metadata, 'user')
            if _xDcAW and _xDcAW not in {'sigma@mondaytech.com', 'meshpro@mondaytech.com', 'texworld@mondaytech.com'}:
                return {'email': _xDcAW}
            return {}

        def validate(self, activate_if_required=False, raise_on_error=True, cache_force_refresh=False, cache_expire_after=None, require_product_id=None):
            if _AjU9I(self.data, 'attributes', 'metadata', 'requireFingerprintScope') is True:
                return self._validate_fingerprinted(activate_if_required, require_product_id=require_product_id, raise_on_error=raise_on_error, cache_force_refresh=cache_force_refresh, cache_expire_after=cache_expire_after)
            _7tHuW = self._validate_cached(with_fingerprint=False, raise_on_error=False, cache_force_refresh=cache_force_refresh, cache_expire_after=cache_expire_after)
            if require_product_id is not None and self.product_id != require_product_id:
                _CmjcR = f'Require product ID {require_product_id}, but license has product ID {self.product_id}'
                raise _IExoO(_CmjcR, 'KG_WRONG_PRODUCT_ID')
            if _AjU9I(_7tHuW, 'valid'):
                return _7tHuW
            _FKhWi = _AjU9I(_7tHuW, 'code')
            if _FKhWi == 'FINGERPRINT_SCOPE_REQUIRED':
                return self._validate_fingerprinted(activate_if_required, raise_on_error=raise_on_error, cache_force_refresh=cache_force_refresh, cache_expire_after=cache_expire_after)
            if raise_on_error:
                _CmjcR = f'License {self.license_id}: Key validation failed'
                raise _IExoO(_CmjcR, _FKhWi)
            return _7tHuW

        def _validate_fingerprinted(self, activate_if_required, require_product_id=None, raise_on_error=True, cache_force_refresh=False, cache_expire_after=None):
            _ykUXV = self._validate_cached(with_fingerprint=True, raise_on_error=False, cache_force_refresh=cache_force_refresh, cache_expire_after=cache_expire_after)
            if require_product_id is not None and self.product_id != require_product_id:
                _sMjRt = f'Require product ID {require_product_id}, but license has product ID {self.product_id}'
                raise _IExoO(_sMjRt, 'KG_WRONG_PRODUCT_ID')
            if _AjU9I(_ykUXV, 'valid'):
                return _ykUXV
            _wYufL = _AjU9I(_ykUXV, 'code')
            if _wYufL == 'HEARTBEAT_NOT_STARTED':
                self._ping_heartbeat_cached(raise_on_error=True, cache_force_refresh=True)
                return self._validate_fingerprinted(activate_if_required, raise_on_error=raise_on_error)
            if activate_if_required and _wYufL in {'NO_MACHINE', 'NO_MACHINES', 'FINGERPRINT_SCOPE_MISMATCH', 'HEARTBEAT_DEAD'}:
                self.activate(raise_on_error=True)
                return self._validate_fingerprinted(activate_if_required, cache_force_refresh=True, cache_expire_after=cache_expire_after, raise_on_error=raise_on_error)
            if raise_on_error:
                _3DQCy = []
                _cOrqZ = _AjU9I(_ykUXV, 'detail')
                _OJv7A = _AjU9I(_ykUXV, 'code')
                if _wYufL and _cOrqZ:
                    _3DQCy.append(f'Validation error {_wYufL}: {_cOrqZ}')
                if _wYufL == 'NOT_FOUND':
                    _3DQCy.append('Did you provide the license ID instead of the key?')
                raise _IExoO('\n'.join(_3DQCy), f'KG_{_OJv7A}')
            return _ykUXV

        def _validate_cached(self, with_fingerprint, raise_on_error=True, cache_force_refresh=False, cache_expire_after=None):
            _rh714: dict[str, Any] = {'key': self.key}
            if with_fingerprint:
                _rh714['scope'] = {'fingerprint': _yBOr1()}
            _aJPWV = _yykO3.post(f'{self.base_url}/licenses/actions/validate-key', headers={'Content-Type': 'application/vnd.api+json', 'Accept': 'application/vnd.api+json', 'Keygen-Version': _Z5FuV}, json={'meta': _rh714}, timeout=10, force_refresh=cache_force_refresh, expire_after=cache_expire_after)
            try:
                self.verify_response(_aJPWV)
            except _grrTa:
                _yykO3.cache.delete(requests=[_aJPWV.request])
                raise
            _h36lw(_aJPWV)
            json = _aJPWV.json()
            if not _aJPWV.ok:
                _bV3cN = _AjU9I(json, 'errors', 0)
                _LuUz9 = f'Validation failed for license {self.license_id}: '
                if _bV3cN:
                    if _bV3cN.get('title') == 'Daily API request limit reached':
                        _Utwr0 = 'KG_RATE_LIMIT'
                        _LuUz9 += 'Daily API rate limit has been reached. Limit will be reset at midnight UTC.'
                    else:
                        _Utwr0 = _AjU9I(_bV3cN, 'code')
                        _LuUz9 += _AjU9I(_bV3cN, 'detail')
                else:
                    _Utwr0 = 'KG_VALIDATION_FAILED'
                    _LuUz9 += 'unknown'
                raise _IExoO(_LuUz9, _Utwr0)
            data = json['data']
            _rh714 = json['meta']
            if not _AjU9I(_rh714, 'valid') and raise_on_error:
                _gir0q = _AjU9I(_rh714, 'code')
                _qATPX = _AjU9I(_rh714, 'detail')
                _WmzIA = []
                if _gir0q and _qATPX:
                    _WmzIA.append(f'Validation error {_gir0q}: {_qATPX}')
                if _gir0q == 'NOT_FOUND':
                    _WmzIA.append('Did you provide the license ID instead of the key?')
                raise _IExoO('\n'.join(_WmzIA), _gir0q)
            if _AjU9I(_rh714, 'valid') and _AjU9I(data, 'attributes', 'requireHeartbeat'):
                self._ping_heartbeat_cached(raise_on_error=True)
            if data:
                self._data = data
            return _rh714

        def activate(self, raise_on_error=True):
            _T3LOy('Activating machine for license...', highlight=False, end='', style='green')
            _vRV3O = _AjU9I(self.data, 'attributes', 'metadata', 'token')
            _d2wGx = _AjU9I(self.data, 'attributes', 'metadata', 'tokenId')
            _fo1QE = _vRV3O and _d2wGx
            auth = f'Bearer {_vRV3O}' if _fo1QE else f'License {self.key}'
            _pl9HU = requests.post(f'{self.base_url}/machines', headers={'Authorization': auth, 'Content-Type': 'application/vnd.api+json', 'Accept': 'application/vnd.api+json', 'Keygen-Version': _Z5FuV}, json={'data': {'type': 'machines', 'attributes': {'cores': multiprocessing.cpu_count(), 'fingerprint': _yBOr1(), 'platform': platform.platform(), 'hostname': socket.gethostname()}, 'relationships': {'license': {'data': {'type': 'licenses', 'id': self.license_id}}}}}, timeout=10)
            self.verify_response(_pl9HU)
            _h36lw(_pl9HU)
            _fBhYg = _pl9HU.json()
            self._clear_validation_cache()
            self._clear_machines_cache()
            if _fo1QE:
                self._clear_tokens_cache(_d2wGx)
            if raise_on_error and 'errors' in _fBhYg:
                _T3LOy(_fBhYg)
                _eKu90 = f'Activation errors with license {self.license_id}:\n' + '\n'.join((f"    {_Oh6Ei['title']}: {_Oh6Ei['detail']}" for _Oh6Ei in _fBhYg['errors']))
                raise _IExoO(_eKu90, 'KG_ACTIVATION_ERROR')
            _T3LOy('done.', style='green')

        def deactivate(self, fingerprints=None):
            _T3LOy('Deactivating machine for license...', highlight=False, end='', style='green')
            _edgtJ = _AjU9I(self.data, 'attributes', 'metadata', 'token')
            _MvEqz = _AjU9I(self.data, 'attributes', 'metadata', 'tokenId')
            _RO69p = _edgtJ and _MvEqz
            auth = f'Bearer {_edgtJ}' if _RO69p else f'License {self.key}'
            if not fingerprints:
                fingerprints = {_yBOr1()}
            for _ZEIaR in fingerprints:
                _7wNxc = self._get_machine_by_fingerprint_cached(_ZEIaR, cache_force_refresh=True)
                _G45fz = _AjU9I(_7wNxc, 'data', 0, 'id')
                if not _G45fz:
                    _hHAZM = f"Couldn't get machine ID for machine {_ZEIaR}. Not activated?"
                    raise _IExoO(_hHAZM, 'KG_MACHINE_NOT_FOUND')
                _QH0hu = requests.delete(f'{self.base_url}/machines/{_G45fz}', headers={'Content-Type': 'application/vnd.api+json', 'Accept': 'application/vnd.api+json', 'Authorization': auth, 'Keygen-Version': _Z5FuV}, timeout=10)
                if not _QH0hu.ok:
                    _iBDzt = _AjU9I(_QH0hu.json(), 'errors', 0)
                    if _iBDzt:
                        _hsb5F = _AjU9I(_iBDzt, 'code')
                        _hHAZM = f"Machined deactivation failed: {_iBDzt['detail']}"
                    elif _QH0hu.status_code == 404:
                        _hsb5F = 'KG_MACHINE_NOT_FOUND'
                        _hHAZM = 'Machine deactivation failed (not found)'
                    else:
                        _hsb5F = 'KG_DEACTIVATION_FAILED'
                        _hHAZM = 'Unsuccessful deactivation request'
                    raise _IExoO(_hHAZM, _hsb5F)
                self.verify_response(_QH0hu)
                _h36lw(_QH0hu)
            self._clear_validation_cache()
            self._clear_machines_cache()
            if _RO69p:
                self._clear_tokens_cache(_MvEqz)
            _T3LOy('done.', style='green')

        def _clear_validation_cache(self):
            _yykO3.cache.delete(requests=[Request(method='POST', url=f'{self.base_url}/licenses/actions/validate-key', json={'meta': {'key': self.key}}), Request(method='POST', url=f'{self.base_url}/licenses/actions/validate-key', json={'meta': {'key': self.key, 'scope': {'fingerprint': _yBOr1()}}})])

        def _clear_machines_cache(self):
            _yykO3.cache.delete(urls=[f'{self.base_url}/licenses/{self.license_id}/machines'])

        def _clear_tokens_cache(self, token_id):
            _yykO3.cache.delete(urls=[f'{self.base_url}/tokens/{token_id}'])

        def get_machines(self, cache_force_refresh=False):
            _F9ocU = _yykO3.get(f'{self.base_url}/licenses/{self.license_id}/machines', headers={'Content-Type': 'application/vnd.api+json', 'Accept': 'application/vnd.api+json', 'Authorization': self.auth, 'Keygen-Version': _Z5FuV}, timeout=10, force_refresh=cache_force_refresh)
            try:
                self.verify_response(_F9ocU)
            except _grrTa:
                _yykO3.cache.delete(requests=[_F9ocU.request])
                raise
            _h36lw(_F9ocU)
            json = _F9ocU.json()
            return _AjU9I(json, 'data', default=[])

        def prettyprint(self, show_key=False):
            _jPMNn: bool | Literal['unknown']
            try:
                _givmm = self.validate(raise_on_error=False)
            except requests.exceptions.ReadTimeout:
                _jPMNn = 'unknown'
                _0jrbD = 'timeout'
            else:
                _jPMNn = _givmm['valid']
                assert isinstance(_jPMNn, bool)
                _0jrbD = _AjU9I(_givmm, 'code')
            super()._prettyprint(show_key=show_key, is_valid=_jPMNn, validation_code=_0jrbD)

        def _get_machine_by_fingerprint_cached(self, fingerprint, cache_force_refresh=False, raise_on_error=False):
            _yc55i = _yykO3.get(url=f'{self.base_url}/machines', params={'fingerprint': quote(fingerprint)}, headers={'Authorization': self.auth, 'Content-Type': 'application/vnd.api+json', 'Accept': 'application/vnd.api+json', 'Keygen-Version': _Z5FuV}, timeout=10, force_refresh=cache_force_refresh)
            self.verify_response(_yc55i)
            _h36lw(_yc55i)
            _RNZD4 = _yc55i.json()
            _3BXOd = _AjU9I(_RNZD4, 'errors')
            if raise_on_error and _3BXOd:
                _56cFU = 'Get-Machine errors:\n' + '\n'.join((f"    {_xI72x['title']}: {_xI72x['detail']}" for _xI72x in _3BXOd))
                raise _IExoO(_56cFU, 'KG_MACHINE_ERROR')
            return _RNZD4

        def _ping_heartbeat_cached(self, raise_on_error, cache_force_refresh=False):
            _uLQxe = _yBOr1()
            _0TAje = self._get_machine_by_fingerprint_cached(_uLQxe, cache_force_refresh=cache_force_refresh)
            _1q9Px = _AjU9I(_0TAje, 'data', 0, 'id')
            if _1q9Px is None:
                _Pver4 = f'Machine with fingerprint {_uLQxe} not found'
                raise _IExoO(_Pver4, 'KG_MACHINE_NOT_FOUND')
            _PXrEI = _yykO3.post(f'{self.base_url}/machines/{_1q9Px}/actions/ping-heartbeat', headers={'Authorization': self.auth, 'Accept': 'application/vnd.api+json', 'Keygen-Version': _Z5FuV}, timeout=10, force_refresh=cache_force_refresh)
            try:
                self.verify_response(_PXrEI)
            except _grrTa:
                _yykO3.cache.delete(requests=[_PXrEI.request])
                raise
            _h36lw(_PXrEI)
            _pPLpl = _PXrEI.json()
            _GuDNt = _AjU9I(_pPLpl, 'errors')
            if _GuDNt and _AjU9I(_GuDNt[0], 'code') == 'NOT_FOUND' and (not cache_force_refresh):
                return self._ping_heartbeat_cached(raise_on_error, cache_force_refresh=True)
            if raise_on_error and _GuDNt:
                _Pver4 = f'License {self.license_id}: Heartbeat errors:\n' + '\n'.join((f"    {_eMGJJ['title']}: {_eMGJJ['detail']}" for _eMGJJ in _GuDNt))
                raise _IExoO(_Pver4, 'KG_HEARTBEAT_ERROR')
            return _pPLpl

    def _dVw0a():
        _yykO3.cache.clear()

    def _wcCZj(cert_data_or_path, update_if_expired=True, override_original=True):
        _VhzMo = None
        if isinstance(cert_data_or_path, Path):
            _VhzMo = cert_data_or_path
            with _VhzMo.open() as _FUMIy:
                _6iib7 = _FUMIy.read()
        else:
            assert isinstance(cert_data_or_path, str)
            _6iib7 = cert_data_or_path
        _TDhvp, _YOBMu = _dP500(_6iib7)
        _lfNAH = datetime.now(tz=timezone.utc)
        if _rjv4L(_YOBMu['issued']) > _lfNAH + timedelta(minutes=5):
            _Lu2RF = 'License error'
            raise _IExoO(_Lu2RF, 'KG_E058')
        if _VhzMo and update_if_expired and (_lfNAH > _rjv4L(_YOBMu['expiry'])):
            _6iib7 = _gb0oR(_TDhvp['relationships']['account']['data']['id'], _TDhvp['id'], auth=f"License {_TDhvp['attributes']['key']}")
            _TDhvp, _YOBMu = _dP500(_6iib7)
            if override_original:
                with _VhzMo.open('w') as _6wJyH:
                    _6wJyH.write(_6iib7)
        _HGyVL = _TDhvp['attributes']['key']
        if _HGyVL.startswith('key/'):
            return _tZ8BM(_HGyVL)
        return _BPR43(_TDhvp)

    def _eQFEJ(path):
        with path.open() as _Zk8P1:
            _6030w = _Zk8P1.read()
        _2OjLj, _hQBFX = _dP500(_6030w)
        _6ry8C = _2OjLj['attributes']['key']
        _6030w = _gb0oR(_2OjLj['relationships']['account']['data']['id'], _2OjLj['id'], auth=f'License {_6ry8C}')
        with path.open('w') as _1CybK:
            _1CybK.write(_6030w)

    def _dP500(content):
        assert isinstance(content, str)
        _ry2Mc = '-----BEGIN LICENSE FILE-----\n'
        _aUt6U = '-----END LICENSE FILE-----'
        content = content.strip()
        if not content.startswith(_ry2Mc) or not content.endswith(_aUt6U):
            _F4Jl1 = f'Error in license file. Expected\n```{_ry2Mc}...\n{_aUt6U}\n```\ngot\n```\n{content}\n```\nTry refreshing the the license file with `slim refresh`.\n'
            raise ValueError(_F4Jl1)
        _0gj07 = base64.b64decode(_tyls6(content, _ry2Mc, _aUt6U))
        try:
            _APSuD = json.loads(_0gj07)
        except UnicodeDecodeError:
            _F4Jl1 = 'Unexpected license data'
            raise RuntimeError(_F4Jl1) from None
        _Qwbvs = json.loads(base64.b64decode(_APSuD['enc']))
        _qUFak = _AjU9I(_Qwbvs, 'data', 'relationships', 'account', 'data', 'id')
        _uRoF7 = _ZvcvQ(_qUFak).verify_key
        _y40v0 = ('license/' + _APSuD['enc']).encode()
        _c979w, _qorl7 = _APSuD['alg'].split('+')
        assert _c979w == 'base64'
        _OsTJn = base64.b64decode(_APSuD['sig'])
        if _uRoF7.alg != _qorl7:
            _F4Jl1 = f'Requested {_qorl7} key, but got {_uRoF7.alg} verify_key'
            raise RuntimeError(_F4Jl1)
        _uRoF7.verify(_OsTJn, _y40v0)
        return (_Qwbvs['data'], _Qwbvs['meta'])

    def _gb0oR(account_id, license_id_or_key, auth, host='api.keygen.sh'):
        _NpxXC = requests.get(f'https://{host}/v1/accounts/{account_id}/licenses/{quote(license_id_or_key)}/actions/check-out', headers={'Accept': 'application/vnd.api+json', 'Authorization': auth, 'Keygen-Version': '1.3'}, timeout=10)
        _NpxXC.raise_for_status()
        _ZvcvQ(account_id).verify_key.verify_response(_NpxXC)
        _h36lw(_NpxXC)
        return _NpxXC.text
    try:
        import tomllib
    except ImportError:
        import tomli as tomllib
    _BEJ2Q = _wz2g0 / 'keygen'

    def _XstWq(file_or_cert):
        _o1wrO = _wcCZj(file_or_cert, update_if_expired=True, override_original=False)
        if isinstance(_o1wrO, _BPR43):
            _o1wrO.validate(activate_if_required=True)
            return _xpREk(_o1wrO, file_or_cert)
        assert isinstance(_o1wrO, _tZ8BM)
        _fDTpS(_o1wrO)
        return _o1wrO

    def _xpREk(lic, cert=None):
        _T3LOy('Installing license...', end='', style='green', highlight=False)
        if cert is None:
            cert = _gb0oR(lic.account_id, lic.license_key, auth=f'License {lic.license_key}')
        elif isinstance(cert, Path):
            with cert.open() as _PsUhG:
                cert = _PsUhG.read()
        assert isinstance(cert, str)
        assert cert.startswith('-----BEGIN LICENSE FILE-----')
        assert lic.product_id, 'Missing product ID'
        assert lic.license_id, 'Missing license ID'
        _xfXRv = _BEJ2Q / lic.product_id / (lic.license_id + '.lic')
        _xfXRv.parent.mkdir(parents=True, exist_ok=True)
        with _xfXRv.open('w') as _szvio:
            _szvio.write(cert)
        _T3LOy('done.', style='green')
        return lic

    def _fDTpS(lic):
        _lfIAw = _BEJ2Q / lic.product_id / (lic.license_id + '.key')
        _lfIAw.parent.mkdir(parents=True, exist_ok=True)
        _FznLl, _sDqfx = lic.key.split('/')
        _e14a6, _og3px = _sDqfx.split('.')
        with _lfIAw.open('w') as _phc4o:
            _phc4o.write(_FznLl + '/\n' + _MsQvA(_e14a6, 60) + '\n.\n' + _MsQvA(_og3px, 60))

    def _dJwg5(toml_file):
        _uiROo = _NNDtx(toml_file)
        if _uiROo.startswith('key/'):
            _cv2Gy = _tZ8BM(_uiROo)
            _fDTpS(_cv2Gy)
            return _cv2Gy
        _uiROo = _OQDlj(_uiROo, 'fp/')
        _Cadje = _BPR43.from_key(_q4RXW(_uiROo), _uiROo)
        _Cadje.validate(activate_if_required=True)
        _xpREk(_Cadje)
        return _Cadje

    def _NNDtx(toml_file):
        with Path(toml_file).open('rb') as _p0rK9:
            _Lz4tG = tomllib.load(_p0rK9)
        assert _Lz4tG, f'Empty license file {toml_file}'
        return _Lz4tG['license_key']

    @_cfKjp
    def _ygeGB(product_id=None, license_keys_or_ids=None):
        _fDgeg = _BEJ2Q
        if product_id:
            _fDgeg /= product_id
        for _fUoSE in _fDgeg.rglob('*.key'):
            _Ka5yy = _tZ8BM.from_file(_fUoSE)
            if license_keys_or_ids is None:
                yield (_fUoSE, _Ka5yy)
            else:
                _jaR50 = _AjU9I(_Ka5yy.data, 'license', 'id')
                if _jaR50 in license_keys_or_ids:
                    license_keys_or_ids.remove(_jaR50)
                    yield (_fUoSE, _Ka5yy)
                    continue
                if _Ka5yy.key in license_keys_or_ids:
                    license_keys_or_ids.remove(_Ka5yy.key)
                    yield (_fUoSE, _Ka5yy)
                    continue

    @_cfKjp
    def _4jwtQ(product_id=None, license_keys_or_ids=None):
        _MqLUQ = _BEJ2Q
        if product_id:
            _MqLUQ /= product_id
        for _LosUf in _MqLUQ.rglob('*.toml'):
            _dJwg5(_LosUf)
            _LosUf.unlink()
        for _oDgr3 in _MqLUQ.rglob('*.lic'):
            _CyYgY = _wcCZj(_oDgr3)
            if license_keys_or_ids is None:
                yield (_oDgr3, _CyYgY)
            else:
                _5u6Yf = _AjU9I(_CyYgY.data, 'id')
                if _5u6Yf in license_keys_or_ids:
                    license_keys_or_ids.remove(_5u6Yf)
                    yield (_oDgr3, _CyYgY)
                    continue
                _nLMhY = _AjU9I(_CyYgY.data, 'attributes', 'key')
                if _nLMhY in license_keys_or_ids:
                    license_keys_or_ids.remove(_nLMhY)
                    yield (_oDgr3, _CyYgY)
                    continue

    def _LX3Sc():
        _WAAev = 0
        for _Q6Vxn in _BEJ2Q.rglob('*.lic'):
            _eQFEJ(_Q6Vxn)
            _WAAev += 1
        return _WAAev
    try:
        from functools import cache
    except ImportError:
        from functools import lru_cache as cache

    @_yEHRf
    @cache
    def _3ELbO(account_id, product_id, variable_names=(), allow_user_input=True, cache_force_refresh=False, cache_expire_after=None):
        assert isinstance(product_id, str)
        _ZvcvQ(account_id)
        for _QxnD6 in _3OMhO(_nJcR9(account_id, list(variable_names)), _mRMob(product_id), _eg0ef(product_id)):
            if isinstance(_QxnD6, _BPR43):
                try:
                    _nC8pR = _QxnD6.validate(activate_if_required=True, require_product_id=product_id, cache_expire_after=cache_expire_after, cache_force_refresh=cache_force_refresh)
                except _IExoO as e:
                    _laFx0(str(e))
                    continue
            elif isinstance(_QxnD6, _tZ8BM):
                try:
                    _nC8pR = _QxnD6.validate()
                except _IExoO as e:
                    _laFx0(str(e))
                    continue
            else:
                continue
            if _QxnD6.account_id != account_id or _QxnD6.product_id != product_id:
                continue
            return (_QxnD6.data, _nC8pR)
        _ghdDB = f'Unable to find valid license for product ID {product_id}.'
        if allow_user_input:
            _laFx0(_ghdDB)
            _Jl9cd = Prompt.ask('Enter license key')
            _QxnD6 = _zTCps(_Jl9cd, account_id)
            if _QxnD6 is None:
                _FKh7s = f'Illegal license key `{_Jl9cd}`. Typo?'
                raise _IExoO(_FKh7s, 'ILLEGAL_KEY')
            if isinstance(_QxnD6, _BPR43):
                _nC8pR = _QxnD6.validate(activate_if_required=True, require_product_id=product_id, cache_expire_after=cache_expire_after, cache_force_refresh=cache_force_refresh)
                _xpREk(_QxnD6)
                return (_QxnD6.data, _nC8pR)
            if isinstance(_QxnD6, _tZ8BM):
                _nC8pR = _QxnD6.validate()
                if _QxnD6.product_id != product_id:
                    _FKh7s = f'Require product ID {product_id}, but license has product ID {_QxnD6.product_id}'
                    raise _IExoO(_FKh7s, 'KG_WRONG_PRODUCT_ID')
                _fDTpS(_QxnD6)
                return (_QxnD6.data, _nC8pR)
        raise _IExoO(_ghdDB, 'KG_NOT_FOUND')

    def _nJcR9(account_id, var_names):
        for _r31DP, _eI3ab, _CQuVS in _Kg6Hh(var_names):
            if _CQuVS.strip() == '':
                _laFx0(f'{_r31DP.title()} variable `{_eI3ab}` is empty.')
                continue
            _kzQPF = _zTCps(_CQuVS, account_id)
            if _kzQPF is None:
                _laFx0(f'{_r31DP.title()} variable `{_eI3ab}` contains value that cannot be converted to a KG license:\n{_CQuVS}')
                continue
            yield _kzQPF

    def _zTCps(value, account_id):
        if value.endswith('-V3'):
            _tzIO4 = _OQDlj(value, 'fp/')
            return _BPR43.from_key(account_id, _tzIO4)
        if value.startswith('key/'):
            return _tZ8BM(value)
        if value.startswith('-----BEGIN LICENSE FILE-----'):
            return _wcCZj(value, update_if_expired=True, override_original=False)
        _oKQsa = Path(value)
        if _oKQsa.is_file():
            with _oKQsa.open() as _eW4aZ:
                _g45Jk = _eW4aZ.read()
            return _zTCps(_g45Jk, account_id)
        return None

    def _mRMob(product_id):
        for _kRi8E, _2CsWM in _ygeGB(product_id=product_id):
            yield _2CsWM

    def _eg0ef(product_id):
        for _eRrka, _qAlzW in _4jwtQ(product_id=product_id):
            try:
                yield _qAlzW
            except _grrTa:
                _laFx0(f'Invalid signature in {_eRrka}. Skipping.')
    try:
        from functools import cache
    except ImportError:
        from functools import lru_cache as cache

    @_yEHRf
    @cache
    def _dCvz8(product_code, shared_key, api_key, variable_names=(), cache_force_refresh=False, cache_expire_after=None):
        for _PR4Kp in _3OMhO(_iCjaM(product_code, variable_names), _hVqFt(product_code)):
            try:
                _PR4Kp.validate(shared_key, api_key, cache_force_refresh=cache_force_refresh, cache_expire_after=cache_expire_after)
            except _IExoO:
                continue
            if product_code != _PR4Kp.product_code:
                continue
            return _PR4Kp
        _UbpM6 = f'Unable to find valid license for product {product_code}. \n\nAdd a license with\n\n    slim install <your-license>\n'
        raise _IExoO(_UbpM6, 'LS_NOT_FOUND')

    def _iCjaM(product_code, var_names):
        for _pMvWP, _9Vscv, _3pBQY in _Kg6Hh(var_names):
            yield _9tsH8.from_key(product_code, _3pBQY)

    def _hVqFt(product_code):
        for _Cb7PR in (_GRDYc / product_code).glob('*.lic'):
            yield _9tsH8.from_file(_Cb7PR)
    if TYPE_CHECKING:
        from pathlib import Path
    _VOdyz = _wz2g0 / 'license_spring'

    def _FpINc(path):
        _Q8eCk = _9tsH8.from_file(path)
        _oqvdl = _Q8eCk.data['product_details']['short_code']
        _1TYB2 = _Q8eCk.data['id']
        _GM5TO = _VOdyz / _oqvdl / (str(_1TYB2) + '.lic')
        _GM5TO.parent.mkdir(parents=True, exist_ok=True)
        shutil.copy(path, _GM5TO)
        return _Q8eCk

    @_cfKjp
    def _kzrm1(license_keys_or_ids=None, product_code=None):
        assert license_keys_or_ids is None or isinstance(license_keys_or_ids, set)
        _uWqzC = _VOdyz
        if product_code:
            _uWqzC /= product_code
        for _53Rmr in _uWqzC.rglob('*.lic'):
            _byisG = _9tsH8.from_file(_53Rmr)
            if license_keys_or_ids is None:
                yield (_53Rmr, _byisG)
            else:
                _b9geP = str(_AjU9I(_byisG.data, 'id'))
                if _b9geP in license_keys_or_ids:
                    license_keys_or_ids.remove(_b9geP)
                    yield (_53Rmr, _byisG)
                    continue
                _bwVSl = _AjU9I(_byisG.data, 'license_key')
                if _bwVSl in license_keys_or_ids:
                    license_keys_or_ids.remove(_bwVSl)
                    yield (_53Rmr, _byisG)
                    continue

    class _rLlMn:
        name = 'Monday Tech'
        email = 'support@mondaytech.com'
        vendor_id = '6697c7f2-ad29-42c6-8b78-8ddb2a56bc0b'
        verify_key = _BAF5H.from_hex('43157566ccbbe4f46fe5f02d6c1d363a3a502c3dbee36c22cf266e4015bdc23e')
    _fLy4i = {vendor.vendor_id: vendor for vendor in [_rLlMn]}

    def _ZrLUE(vendor_id):
        try:
            return _fLy4i[vendor_id]
        except KeyError:
            _kAhl6 = f"Cannot use SLiM with vendor ID {vendor_id}. If you're a vendor and like to use the Stonefish, contact <support@mondaytech.com>."
            raise _IExoO(_kAhl6, 'KG_VENDOR_ERROR') from None

    class _0rSna(_NDyKX):
        key_type = 'Stonefish License Creator'

        @classmethod
        def from_file(cls, path, *_SgV1q, **_4epIr):
            path = Path(path)
            with path.open() as _z9rir:
                _ZccMs = _z9rir.read().strip().replace('\n', '')
            return cls(_ZccMs, *_SgV1q, **_4epIr)

        def __init__(self, key):
            assert isinstance(key, str)
            key = key.strip().replace('\n', '')
            _zYKH3 = 'slicv1/'
            if not key.startswith(_zYKH3):
                _SUpY8 = f'Expected prefix {_zYKH3!r}, got {key[:len(_zYKH3)]!r}...'
                raise ValueError(_SUpY8)
            self._key = key
            self.signing_data, _mAONB = self._key.split('.')
            self.enc_sig = base64.urlsafe_b64decode(_mAONB)
            _mNZFK = self.signing_data[len(_zYKH3):]
            self._data = json.loads(base64.urlsafe_b64decode(_mNZFK))
            _qwBap = _AjU9I(self._data, 'vendor', 'id')
            if not _qwBap:
                _SUpY8 = 'Key lacks vendor ID'
                raise _IExoO(_SUpY8, 'SLIC_MISSING_VENDOR_ID')
            self.vendor = _ZrLUE(_qwBap)
            super().__init__()

        @property
        def data(self):
            return self._data

        @property
        def key(self):
            return self._key

        @property
        def license_id(self):
            return self.data['license']['id']

        @property
        def vendor_name(self):
            return self.vendor.name

        @property
        def created(self):
            return _rjv4L(self.data['license']['created'])

        @property
        def expiry(self):
            if (expiry := _AjU9I(self.data, 'license', 'expiry')):
                return _rjv4L(expiry)
            return None

        def list_machines(self):
            return _AjU9I(self.data, 'machines', default=[])

        @property
        def product_name(self):
            return _AjU9I(self.data, 'product', 'name')

        @property
        def product_id(self):
            return self.data['product']['id']

        @property
        def user(self):
            return _AjU9I(self.data, 'user', default={})

        @property
        def max_machines(self):
            return None

        @property
        def num_machines(self):
            return None

        def validate(self, raise_on_error=True):
            try:
                self.vendor.verify_key.verify(self.enc_sig, self.signing_data.encode())
            except _grrTa:
                if raise_on_error:
                    raise
                return {'valid': False, 'code': 'SIGNATURE_ERROR', 'detail': 'Signature could not be verified'}
            _hatm3 = datetime.now(tz=timezone.utc)
            _WQYXc = _rjv4L(self.data['license']['created'])
            if _WQYXc > _hatm3:
                _WQc3Y = 'SLIC_E043'
                _Wb1r3 = 'Unknown license error'
                if raise_on_error:
                    raise _IExoO(_Wb1r3, _WQc3Y)
                return {'valid': False, 'code': _WQc3Y, 'detail': _Wb1r3}
            _Otjwg = _rjv4L(expiry) if (expiry := _AjU9I(self.data, 'license', 'expiry')) else None
            if _Otjwg:
                if _WQYXc > _Otjwg:
                    _WQc3Y = 'SLIC_E044'
                    _Wb1r3 = 'Unknown license error'
                    if raise_on_error:
                        raise _IExoO(_Wb1r3, _WQc3Y)
                    return {'valid': False, 'code': _WQc3Y, 'detail': _Wb1r3}
                if _hatm3 > _Otjwg:
                    _WQc3Y = 'SLIC_EXPIRED'
                    _Wb1r3 = f'License has expired on {_Otjwg}'
                    if raise_on_error:
                        raise _IExoO(_Wb1r3, _WQc3Y)
                    return {'valid': False, 'code': _WQc3Y, 'detail': _Wb1r3}
            _XNfF2 = _AjU9I(self.data, 'machines')
            if _XNfF2:
                _EhPyr = _yBOr1()
                if _EhPyr not in _XNfF2:
                    _WQc3Y = 'SLIC_MACHINE_ERROR'
                    _Wb1r3 = f'License not valid on this machine (fingerprint {_EhPyr})'
                    if raise_on_error:
                        raise _IExoO(_Wb1r3, _WQc3Y)
                    return {'valid': False, 'code': _WQc3Y, 'detail': _Wb1r3}
            return {'valid': True, 'code': None, 'detail': ''}

        def prettyprint(self, show_key=False):
            _SxRLN = self.validate(raise_on_error=False)
            super()._prettyprint(show_key=show_key, is_valid=_AjU9I(_SxRLN, 'valid'), validation_code=_AjU9I(_SxRLN, 'code'))
    _TsaXi = _wz2g0 / 'slic'

    def _YGWcK(data):
        _iYMmW = _0rSna(data)
        _3ZyLL = _iYMmW.data['product']['id']
        _aG0Wg = _iYMmW.data['license']['id']
        _pEU7Q = _TsaXi / _3ZyLL / (_aG0Wg + '.key')
        _pEU7Q.parent.mkdir(parents=True, exist_ok=True)
        _oo87x, _uGNr3 = _iYMmW.key.split('/')
        data, _sg12I = _uGNr3.split('.')
        with _pEU7Q.open('w') as _tvPk1:
            _tvPk1.write(_oo87x + '/\n' + _MsQvA(data, 60) + '\n.\n' + _MsQvA(_sg12I, 60))
        return _iYMmW

    @_cfKjp
    def _fDauH(license_keys_or_ids=None, product_id=None):
        assert license_keys_or_ids is None or isinstance(license_keys_or_ids, set)
        _Ly2v0 = _TsaXi
        if product_id:
            _Ly2v0 /= product_id
        for _974WH in _Ly2v0.rglob('*.key'):
            _efW9M = _0rSna.from_file(_974WH)
            if license_keys_or_ids is None:
                yield (_974WH, _efW9M)
            else:
                _Lm8PU = _AjU9I(_efW9M.data, 'license', 'id')
                if _Lm8PU in license_keys_or_ids:
                    license_keys_or_ids.remove(_Lm8PU)
                    yield (_974WH, _efW9M)
                    continue
                if _efW9M.key in license_keys_or_ids:
                    license_keys_or_ids.remove(_efW9M.key)
                    yield (_974WH, _efW9M)
                    continue
    try:
        from functools import cache
    except ImportError:
        from functools import lru_cache as cache

    @_yEHRf
    @cache
    def _4TTtt(vendor_id, product_id, variable_names=()):
        _ZrLUE(vendor_id)
        for _U9zHP in _3OMhO(_7acfI(variable_names), _QfQ7K(product_id)):
            try:
                _ZqiHQ = _U9zHP.validate()
            except _IExoO:
                continue
            except _grrTa:
                _laFx0('Invalid signature in SLiC license')
                continue
            if vendor_id != _AjU9I(_U9zHP.data, 'vendor', 'id') or product_id != _AjU9I(_U9zHP.data, 'product', 'id'):
                continue
            return (_U9zHP.data, _ZqiHQ)
        _e2y7w = f'Unable to find valid license for product ID {product_id}. \n\nAdd a license with\n\n    slim install <your-license>\n'
        raise _IExoO(_e2y7w, 'SLIC_NOT_FOUND')

    def _7acfI(var_names):
        for _2BLZY, _eKBdL, _YBT6r in _Kg6Hh(var_names):
            try:
                yield _0rSna(_YBT6r)
            except _grrTa:
                _laFx0(f'Invalid signature in SLiC license in {_YBT6r}')

    def _QfQ7K(product_id):
        for _G2JYk, _F7Rhz in _fDauH(product_id=product_id):
            try:
                yield _F7Rhz
            except _grrTa:
                _laFx0(f'Invalid signature in SLiC license in {_G2JYk}')
    if TYPE_CHECKING:
        pass

    def _XtEVY(ld):
        if isinstance(ld, str):
            ld = ld.strip()
            if ld.startswith('-----BEGIN LICENSE FILE-----'):
                return _XstWq(ld)
            if ld.endswith('-V3'):
                _KHHEg = _OQDlj(ld, 'fp/')
                _yHhDV = keygen.OnlineLicense.from_key(_q4RXW(_KHHEg), _KHHEg)
                _yHhDV.validate(activate_if_required=True)
                return _xpREk(_yHhDV)
            if ld.startswith('key/'):
                _yHhDV = _tZ8BM(ld)
                _fDTpS(_yHhDV)
                return _yHhDV
            if ld.startswith('slicv1/'):
                return _YGWcK(ld)
        if Path(ld).exists():
            return _xmP7P(Path(ld))
        _PpXN4 = f"Don't know how to handle license_data {ld}"
        raise _J6SYl(_PpXN4)

    def _xmP7P(license_file):
        if not license_file.exists():
            _3KMYK = f'File {license_file} not found'
            raise _J6SYl(_3KMYK)
        if license_file.suffix == '.toml':
            return _dJwg5(license_file)
        if license_file.suffix == '.lic':
            with license_file.open() as _wWJcR:
                _Qd0yx = _wWJcR.read()
            if _Qd0yx.startswith('-----BEGIN LICENSE FILE-----'):
                return _XstWq(license_file)
            return _FpINc(license_file)
        if license_file.suffix == '.key':
            _pibNZ = keygen.OfflineLicense.from_file(license_file)
            _fDTpS(_pibNZ)
            return _pibNZ
        if license_file.suffix == '.skm':
            return _mrjlq(license_file)
        _3KMYK = f'Unknown license file format {license_file}'
        raise _J6SYl(_3KMYK)

    def _2kgEb(license_keys_or_ids=None, product_id=None):
        assert isinstance(license_keys_or_ids, set) or license_keys_or_ids is None
        return _3OMhO(_b249k(license_keys_or_ids=license_keys_or_ids, product_id=product_id), _4jwtQ(license_keys_or_ids=license_keys_or_ids, product_id=product_id), _ygeGB(license_keys_or_ids=license_keys_or_ids, product_id=product_id), _kzrm1(license_keys_or_ids=license_keys_or_ids, product_code=product_id), _fDauH(license_keys_or_ids=license_keys_or_ids, product_id=product_id))

    def _4q9B6():
        keygen.refresh()
    _4UdDk = 0
    _TKYkq = 1
    RichHelpFormatter.styles['argparse.args'] = 'cyan'
    RichHelpFormatter.styles['argparse.groups'] = 'yellow'
    RichHelpFormatter.styles['argparse.metavar'] = 'green'

    def _vbEul(license_data):
        if license_data.startswith('key/'):
            return _tZ8BM(license_data)
        if license_data.endswith('-V3'):
            _iaopw = _OQDlj(license_data, 'fp/')
            return keygen.OnlineLicense.from_key(_q4RXW(_iaopw), _iaopw)
        if license_data.startswith('-----BEGIN LICENSE FILE-----'):
            return _wcCZj(license_data, update_if_expired=True, override_original=False)
        if license_data.startswith('slicv1/'):
            return _0rSna(license_data)
        if Path(license_data).exists():
            _6RYKS = Path(license_data)
            if _6RYKS.suffix == '.toml':
                return _vbEul(_NNDtx(_6RYKS))
            if _6RYKS.suffix == '.lic':
                return _wcCZj(_6RYKS, update_if_expired=True, override_original=False)
            if _6RYKS.suffix == '.skm':
                return cryptolens.License.from_file(_6RYKS, token=None)
            _dJBCc = f'Unknown license format in file {_6RYKS}'
            raise RuntimeError(_dJBCc)
        _dJBCc = 'Unknown key type'
        raise RuntimeError(_dJBCc)

    def _IkfeS(_):
        _T3LOy(_yBOr1())
        return _4UdDk

    def _Ot7uR(license_keys_or_ids, raw=False, show_keys=False):
        assert isinstance(license_keys_or_ids, set)
        try:
            _W5GtW = list(_2kgEb(license_keys_or_ids=license_keys_or_ids or None))
        except _J6SYl as e:
            _CltWa(str(e))
            return _TKYkq
        if license_keys_or_ids:
            for _aUyxl in license_keys_or_ids:
                try:
                    _W5GtW.append((None, _vbEul(_aUyxl)))
                except RuntimeError:
                    _CltWa(f'{_aUyxl}: No such license.')
                    return _TKYkq
        try:
            for _tMnPs, _SiwHo in _W5GtW:
                if raw:
                    _T3LOy(_SiwHo.data)
                else:
                    _SiwHo.prettyprint(show_key=show_keys)
        except Exception as e:
            _CltWa(str(e))
            return _TKYkq
        return _4UdDk

    def _gRsXl(license_keys_or_ids, automatic_yes=False):
        license_keys_or_ids = set(license_keys_or_ids)
        if license_keys_or_ids:
            license_keys_or_ids = {k.strip().replace('\n', '') for k in license_keys_or_ids}
        try:
            _y9nfk = list(_2kgEb(license_keys_or_ids=license_keys_or_ids))
        except _J6SYl as e:
            _CltWa(str(e))
            return _TKYkq
        if license_keys_or_ids:
            _w34ID = ', '.join(license_keys_or_ids)
            _pukXo = '' if len(license_keys_or_ids) == 1 else 's'
            _CltWa(f'Could not find the following license{_pukXo}: {_w34ID}')
            return _TKYkq
        for _mCEff, _K3x9H in _y9nfk:
            _K3x9H.prettyprint()
        if not _y9nfk:
            return _4UdDk
        _pukXo = '' if len(_y9nfk) == 1 else 's'
        if automatic_yes or Confirm.ask(f'Uninstall the above license{_pukXo} and deactivate machine?'):
            for _wtHqa, _fWA53 in _y9nfk:
                try:
                    _fWA53.deactivate({_yBOr1()})
                except Exception:
                    pass
            for _M8Y5Z, _cPx86 in _y9nfk:
                _M8Y5Z.unlink()
            if not any(_M8Y5Z.parent.iterdir()):
                _M8Y5Z.parent.rmdir()
            _T3LOy('Removed.', style='green')
            return _4UdDk
        _T3LOy('Abort.')
        return _TKYkq

    def _b6kyr(license_data):
        try:
            _zoics = _XtEVY(license_data)
        except Exception as e:
            _CltWa(str(e))
            return _TKYkq
        _zoics.prettyprint()
        return _4UdDk

    def _HJBED(license_key_or_id, machine_fingerprints, automatic_yes=False):
        assert isinstance(license_key_or_id, str)
        assert isinstance(machine_fingerprints, set)
        try:
            _c2t8W = list(_2kgEb(license_keys_or_ids={license_key_or_id}))
        except _J6SYl as e:
            _CltWa(str(e))
            return _TKYkq
        if not _c2t8W:
            _xOpni = f"Couldn't find license with key or ID {license_key_or_id}"
            _CltWa(_xOpni)
            return _TKYkq
        _SwVyB = _yBOr1()
        if not machine_fingerprints:
            machine_fingerprints = {_SwVyB}
        _T3LOy()
        for _hax2X in machine_fingerprints:
            _T3LOy(_hax2X, style='bold')
        _T3LOy()
        if automatic_yes or Confirm.ask(f'Activate the above machine(s) for license {license_key_or_id}?'):
            for _p0EvE, _afj9D in _c2t8W:
                try:
                    _afj9D.activate()
                except (RuntimeError, _IExoO) as e:
                    _CltWa(str(e))
                    return _TKYkq
                _afj9D.prettyprint()
        return _4UdDk

    def _AByQ2(license_key_or_id, machine_fingerprints, automatic_yes=False):
        assert isinstance(license_key_or_id, str)
        assert isinstance(machine_fingerprints, set)
        try:
            _q2HQK = list(_2kgEb(license_keys_or_ids={license_key_or_id}))
        except _J6SYl as e:
            _CltWa(str(e))
            return _TKYkq
        if not _q2HQK:
            _yHH0A = f"Couldn't find license with key or ID {license_key_or_id}"
            _CltWa(_yHH0A)
            return _TKYkq
        _noglK = _yBOr1()
        if not machine_fingerprints:
            machine_fingerprints = {_noglK}
        _T3LOy()
        for _Sxe7l in machine_fingerprints:
            _T3LOy(_Sxe7l, style='bold')
        _T3LOy()
        if automatic_yes or Confirm.ask(f'Deactivate the above machine(s) for license {license_key_or_id}?'):
            for _HQ3lH, _5ry4H in _q2HQK:
                try:
                    _5ry4H.deactivate(machine_fingerprints)
                except Exception as e:
                    _CltWa(str(e))
                    return _TKYkq
                _5ry4H.prettyprint()
        return _4UdDk

    def _W53WG(argv=None):
        _9uOld = argparse.ArgumentParser(description='Stonefish License Manager.', formatter_class=RichHelpFormatter)
        _9uOld.add_argument('--version', '-v', action='version', version=_mgjbN(), help='display version information')
        _9uOld.add_argument('--versions-all', '-vv', action='version', version=_9cJDc(), help='display version information, including dependencies')
        _e4rgE = _9uOld.add_subparsers(title='subcommands', required=True)
        _WdIkk = _e4rgE.add_parser('list', help='List installed licenses', aliases=['ls', 'show', 'info'], formatter_class=_9uOld.formatter_class)
        _WdIkk.add_argument('-r', '--raw', action='store_true', help='Show raw license data')
        _WdIkk.add_argument('-k', '--show-keys', action='store_true', help='Show license keys')
        _WdIkk.add_argument('license_ids_or_keys', type=str, nargs='*', help='License IDs or keys (optional)')
        _WdIkk.set_defaults(func=lambda _2ZNuw: _Ot7uR(set(_2ZNuw.license_ids_or_keys), _2ZNuw.raw, _2ZNuw.show_keys))
        _uY8u7 = _e4rgE.add_parser('install', help='Install (and activate) licenses', aliases=['add', 'a'], formatter_class=_9uOld.formatter_class)
        _uY8u7.add_argument('license_file', type=str, help='License file')
        _uY8u7.set_defaults(func=lambda _MKAlK: _b6kyr(str(_MKAlK.license_file)))
        _jh63e = _e4rgE.add_parser('uninstall', help='Uninstall (and deactivate) licenses', aliases=['remove', 'rm', 'delete', 'del'], formatter_class=_9uOld.formatter_class)
        _jh63e.add_argument('license_key_or_id', type=str, nargs='+', help='License keys or IDs')
        _jh63e.add_argument('-y', '--yes', action='store_true', help='Automatic yes to prompts')
        _jh63e.set_defaults(func=lambda _xozaB: _gRsXl(_xozaB.license_key_or_id, _xozaB.yes))
        _uY8u7 = _e4rgE.add_parser('activate', help='Activate machine for license', formatter_class=_9uOld.formatter_class)
        _uY8u7.add_argument('license_file_or_id_or_key', type=str, help='License file or ID or key')
        _uY8u7.add_argument('machine_fingerprints', type=str, nargs='*', help='Machine fingerprints (default: this machine)')
        _uY8u7.set_defaults(func=lambda _MuA5V: _HJBED(_MuA5V.license_file_or_id_or_key, set(_MuA5V.machine_fingerprints)))
        _uY8u7 = _e4rgE.add_parser('deactivate', help='Deactivate machine for license', formatter_class=_9uOld.formatter_class)
        _uY8u7.add_argument('license_file_or_id_or_key', type=str, help='License file or ID or key')
        _uY8u7.add_argument('machine_fingerprints', type=str, nargs='*', help='Machine fingerprints (default: this machine)')
        _uY8u7.set_defaults(func=lambda _bTA6c: _AByQ2(_bTA6c.license_file_or_id_or_key, set(_bTA6c.machine_fingerprints)))
        _WdIkk = _e4rgE.add_parser('fingerprint', help='Display machine fingerprint', aliases=['fp'], formatter_class=_9uOld.formatter_class)
        _WdIkk.set_defaults(func=_IkfeS)
        _r0XTD = _e4rgE.add_parser('refresh', help='Refresh license files and cache', formatter_class=_9uOld.formatter_class)
        _r0XTD.set_defaults(func=_iuKGu)
        _DXOec = _e4rgE.add_parser('cache', help='Manage the cache', formatter_class=_9uOld.formatter_class)
        _JS4MV = _DXOec.add_subparsers(title='subcommands', required=True)
        _aYWGv = _JS4MV.add_parser('clear', help='Remove all items from the cache', aliases=['clean'], formatter_class=_9uOld.formatter_class)
        _aYWGv.set_defaults(func=_OAOvw)
        _LVMn5 = _JS4MV.add_parser('dir', help='Show the cache directory', formatter_class=_9uOld.formatter_class)
        _LVMn5.set_defaults(func=_ALofk)
        _bTA6c = _9uOld.parse_args(argv)
        return _bTA6c.func(_bTA6c)

    def _mgjbN():
        _OHgmV = f'{version_info.major}.{version_info.minor}.{version_info.micro}'
        _i48w3 = _ov8Ie('stonefish-license-manager')
        return '\n'.join([f'Stonefish License Manager {_i48w3} [Python {_OHgmV}]'])

    def _9cJDc():
        _JbwDb = Table(show_header=False, box=None)
        _JbwDb.add_column('package')
        _JbwDb.add_column('version')
        _JbwDb.add_row('Stonefish License Manager', _ov8Ie('stonefish-license-manager'))
        _JbwDb.add_row('Python', f'{version_info.major}.{version_info.minor}.{version_info.micro}')
        _Vitic = _xMRD3('stonefish-license-manager')
        if _Vitic:
            _JbwDb.add_row('', '')
            for _7g6hu in _Vitic:
                _JbwDb.add_row(_7g6hu, _ov8Ie(_7g6hu))
        return _JbwDb

    def _xMRD3(name):
        _l47du = [packaging.requirements.Requirement(_OjxkB) for _OjxkB in metadata.metadata(name).get_all('Requires-Dist')]
        return [_xPNJU.name for _xPNJU in _l47du if _xPNJU.marker is None or _xPNJU.marker.evaluate()]

    def _iuKGu(_):
        _vMfmp = _LX3Sc()
        _T3LOy(f'Refreshed {_vMfmp} installed licenses')
        _OAOvw(_)
        return _4UdDk

    def _OAOvw(_):
        _dVw0a()
        _66o7T()
        _OCXOm()
        return _4UdDk

    def _ALofk(_):
        _T3LOy(_zia7O)
        return _4UdDk
_wxMS5()
del _wxMS5
