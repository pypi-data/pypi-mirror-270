def _vrO5M(f):
    def _2m1rn(*args, **kwargs):
        return f(*args, **kwargs)
    _2m1rn.__module__ = f.__module__
    _2m1rn.__name__ = f.__name__
    _2m1rn.__doc__ = f.__doc__
    _2m1rn.__dict__.update(f.__dict__)
    f.__refcalls__ = 0
    return _2m1rn

@_vrO5M
def _k88ln():
    global _MHcgI, _z9TJI, _5C9pn, _h3qEp, _ujNoC, _kxLrP, _Ueqzl, _oOywZ, _KrE77, _dy2fa, _rQ3Nx, _vsSd7, _vJGa4, _oFtwK, _ZA5vs, _SZh7z, _sUiWo, _lM0bz, _0DqB7, _SwVRe, _bNU8V, _9kGgx, _KRWBQ, _pG2cU, _viy45, _xWb3m, _46moL, _pj588, _LHVlu, _4V7GD, _3cG33, _BlMHw, _h4dwd, _9ZF8j, _NJZU0, _PvXrq, _iK4eq, _V1QlJ, _m0p0y, _G6OrA, _v7wXR, _9XLdB, _57u8P, _apE7M, _SVzaC, _Df1ou
    from __future__ import annotations
    from cryptography.exceptions import InvalidSignature
    from cryptography.hazmat.primitives import hashes, serialization
    from cryptography.hazmat.primitives.asymmetric import padding
    from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PublicKey
    from cryptography.hazmat.primitives.asymmetric.rsa import RSAPublicKey
    from dataclasses import dataclass
    from datetime import datetime, timedelta, timezone
    from email.utils import parsedate_to_datetime
    from importlib import metadata
    from importlib.util import find_spec
    from pathlib import Path
    from requests import Request
    from rich.console import Console
    from rich.panel import Panel
    from rich.prompt import Confirm, Prompt
    from rich.table import Table
    from rich.text import Text
    from rich_argparse import RichHelpFormatter
    from sys import version_info
    from typing import Any, Literal, Protocol, TYPE_CHECKING
    from urllib.parse import quote, urlsplit
    from wsgiref.handlers import format_date_time
    import argparse, base64, binascii, hashlib, hmac, json, logging, machineid, multiprocessing, os, packaging.requirements, platform, platformdirs, re, requests, requests_cache, shutil, socket, sys, time, uuid
    _xa9Hj = Console(highlight=True)
    _KUF8r = Console(stderr=True, style='yellow', highlight=False)
    _rreHX = Console(stderr=True, style='red', highlight=False)

    def _MHcgI(msg='', **_slFeC):
        _xa9Hj.print(msg, **_slFeC)

    def _xBJX7(msg):
        _KUF8r.print(f'Warning: {msg}')

    def _kvlDB(msg):
        _rreHX.print(f'\nError: {msg}')

    class _z9TJI(Exception):

        def __init__(self, message, code):
            super().__init__(message)
            self.code = code

        def show(self):
            _kvlDB(f'{self} ({self.code})')

    class _5C9pn(Exception):
        pass

    class _DnXon(Exception):
        pass
    _jlNqE = platformdirs.user_data_path('slim')
    _dH2g9 = platformdirs.user_cache_path('slim')

    def _pw6H3(package, fallback='unknown'):
        try:
            return metadata.version(package)
        except metadata.PackageNotFoundError:
            return fallback

    def _h3qEp(dct, *_ewMPe, default=None):
        for _Lc3Lx in _ewMPe:
            try:
                dct = dct[_Lc3Lx]
            except (KeyError, TypeError, IndexError):
                return default
        return dct

    def _YI6qb(obj, eps=timedelta(minutes=5)):
        if abs(obj - datetime.now(tz=timezone.utc)) > eps:
            _ayyDi = 'Error code E044'
            raise RuntimeError(_ayyDi)

    def _TTFCy(obj, eps=timedelta(minutes=5)):
        if obj > datetime.now(tz=timezone.utc) + eps:
            _sFvnF = 'Error code E045'
            raise RuntimeError(_sFvnF)

    def _he570(ts, **_du6lO):
        _TTFCy(datetime.fromtimestamp(ts, tz=timezone.utc), **_du6lO)

    def _ujNoC(res):
        _GwLzL = parsedate_to_datetime(res.headers['Date'])
        if getattr(res, 'from_cache', False):
            _TTFCy(_GwLzL)
        else:
            _YI6qb(_GwLzL)

    def _Hhx1Q(td):
        _tzNqj = abs(td)
        if _tzNqj < timedelta(seconds=1):
            return 'just now'
        _pWpMF = td > timedelta(0)
        for _VTtYv, _G4vc3, _Fh6nK in [('second', _tzNqj.seconds, timedelta(minutes=1)), ('minute', round(_tzNqj.seconds / 60), timedelta(hours=1)), ('hour', round(_tzNqj.seconds / 3600), timedelta(days=1))]:
            if _tzNqj < _Fh6nK:
                _inmVg = '' if _G4vc3 == 1 else 's'
                return f'in {_G4vc3} {_VTtYv}{_inmVg}' if _pWpMF else f'{_G4vc3} {_VTtYv}{_inmVg} ago'
        if _tzNqj.days < 100:
            _G4vc3 = _tzNqj.days
            if _G4vc3 == 0:
                return 'today'
            if _pWpMF:
                if _G4vc3 == 1:
                    return 'tomorrow'
                return f'in {_G4vc3} days'
            if _G4vc3 == 1:
                return 'yesterday'
            return f'{_G4vc3} days ago'
        if _tzNqj.days < 365:
            _G4vc3 = round(_tzNqj.days / 30)
            _inmVg = '' if _G4vc3 == 1 else 's'
            if _pWpMF:
                return f'in {_G4vc3} month{_inmVg}'
            return f'{_G4vc3} month{_inmVg} ago'
        _G4vc3 = round(_tzNqj.days / 365)
        _inmVg = '' if _G4vc3 == 1 else 's'
        if _pWpMF:
            return f'in {_G4vc3} year{_inmVg}'
        return f'{_G4vc3} year{_inmVg} ago'

    def _ra3g5(var_names):
        assert isinstance(var_names, (list, tuple))
        for _spp63 in var_names:
            assert isinstance(_spp63, str)
            assert _spp63 != ''
        for _LDBNQ, _mNJk7 in [('global', globals()), ('environment', os.environ)]:
            for _pG8DI in var_names:
                if _pG8DI in _mNJk7:
                    yield (_LDBNQ, _pG8DI, _mNJk7[_pG8DI])

    def _0F0EE(string, k):
        return '\n'.join((string[_QIjHj:_QIjHj + k] for _QIjHj in range(0, len(string), k)))

    def _kxLrP(string):
        if sys.version_info >= (3, 11):
            return datetime.fromisoformat(string)
        try:
            return datetime.strptime(string, '%Y-%m-%dT%H:%M:%S.%f%z')
        except ValueError:
            return datetime.strptime(string, '%Y-%m-%dT%H:%M:%S%z')

    def _28DsU(string, prefix):
        if sys.version_info >= (3, 9):
            return string.removeprefix(prefix)
        if string.startswith(prefix):
            return string[len(prefix):]
        return string

    def _rR6kO(*_elyur):
        for _7HHL7 in _elyur:
            yield from _7HHL7

    def _bLtUI(function):

        def _NoC07(*_mq4Sd, **_aQTOP):
            _mq4Sd = [tuple(_KAgPW) if isinstance(_KAgPW, list) else _KAgPW for _KAgPW in _mq4Sd]
            _aQTOP = {key: tuple(value) if isinstance(value, list) else value for key, value in _aQTOP.items()}
            return function(*_mq4Sd, **_aQTOP)
        _NoC07.cache_clear = function.cache_clear
        return _NoC07

    def _LkSbF(gen):
        cache = set()

        def _uphqN(*_W3aUy, **_XacVx):
            for _eAoty in gen(*_W3aUy, **_XacVx):
                if _eAoty in cache:
                    continue
                yield _eAoty
                cache.add(_eAoty)
        return _uphqN

    def _qxK4S(key):
        if key.startswith('DEMO'):
            return '1fddcec8-8dd3-4d8d-9b16-215cac0f9b52'
        return '109c23d2-6cdd-4faf-bd8a-96c242733638'
    try:
        from functools import cache
    except ImportError:
        from functools import lru_cache as cache

    @cache
    def _Ueqzl():
        if _38w6n():
            return 'google.colab'
        _4LAiK = _MArkC()
        if _4LAiK:
            return f'github-actions/{_4LAiK}'
        _NIhZW = _6Td3U()
        if _NIhZW:
            return f'travis-ci/{_NIhZW}'
        _gwlTu = _XRnuz()
        if _gwlTu:
            return f'circle-ci/{_gwlTu}'
        _Stq18 = _jvLNO()
        if _Stq18:
            return 'gitlab-ci/{gitlab_project_namespace}'
        if _hlBYw():
            return 'jenkins'
        if _XGHlv():
            return 'docker'
        return machineid.id().strip()

    def _XGHlv():
        _JpWFr = Path('/proc/self/cgroup')
        return Path('/.dockerenv').is_file() or (_JpWFr.is_file() and 'docker' in _JpWFr.read_text())

    def _38w6n():
        try:
            _LXD1P = find_spec('google.colab')
        except ModuleNotFoundError:
            return False
        return _LXD1P is not None

    def _MArkC():
        if _EzGYK([('CI', 'true'), ('GITHUB_ACTIONS', 'true'), 'GITHUB_ACTION', 'GITHUB_ACTION_REPOSITORY', 'GITHUB_ACTOR', 'GITHUB_ACTOR_ID', 'GITHUB_API_URL', 'GITHUB_BASE_REF', 'GITHUB_ENV', 'GITHUB_EVENT_NAME', 'GITHUB_EVENT_PATH', 'GITHUB_GRAPHQL_URL', 'GITHUB_HEAD_REF', 'GITHUB_JOB', 'GITHUB_PATH', 'GITHUB_REF', 'GITHUB_REF_NAME', 'GITHUB_REF_PROTECTED', 'GITHUB_REF_TYPE', 'GITHUB_REPOSITORY', 'GITHUB_REPOSITORY_ID', 'GITHUB_REPOSITORY_OWNER', 'GITHUB_REPOSITORY_OWNER_ID', 'GITHUB_RETENTION_DAYS', 'GITHUB_RUN_ATTEMPT', 'GITHUB_RUN_ID', 'GITHUB_RUN_NUMBER', 'GITHUB_SERVER_URL', 'GITHUB_SHA', 'GITHUB_STEP_SUMMARY', 'GITHUB_WORKFLOW', 'GITHUB_WORKFLOW_REF', 'GITHUB_WORKFLOW_SHA', 'GITHUB_WORKSPACE', 'RUNNER_ARCH', 'RUNNER_NAME', 'RUNNER_OS', 'RUNNER_TEMP', 'RUNNER_TOOL_CACHE']):
            return os.environ['GITHUB_REPOSITORY_OWNER']
        return None

    def _6Td3U():
        if _EzGYK([('CI', 'true'), ('TRAVIS', 'true'), ('CONTINUOUS_INTEGRATION', 'true'), ('HAS_JOSH_K_SEAL_OF_APPROVAL', 'true'), ('USER', 'travis'), ('RAILS_ENV', 'test'), ('RACK_ENV', 'test'), ('MERB_ENV', 'test'), 'TRAVIS_ALLOW_FAILURE', 'TRAVIS_APP_HOST', 'TRAVIS_BRANCH', 'TRAVIS_BUILD_DIR', 'TRAVIS_BUILD_ID', 'TRAVIS_BUILD_NUMBER', 'TRAVIS_BUILD_WEB_URL', 'TRAVIS_COMMIT', 'TRAVIS_COMMIT_MESSAGE', 'TRAVIS_COMMIT_RANGE', 'TRAVIS_COMPILER', 'TRAVIS_DEBUG_MODE', 'TRAVIS_DIST', 'TRAVIS_REPO_SLUG']):
            _o4G0z, _HSn77 = os.environ['TRAVIS_REPO_SLUG'].split('/')
            return _o4G0z
        return None

    def _XRnuz():
        if _EzGYK([('CI', 'true'), ('CIRCLE', 'true'), 'CIRCLE_BRANCH', 'CIRCLE_BUILD_NUM', 'CIRCLE_BUILD_URL', 'CIRCLE_JOB', 'CIRCLE_NODE_INDEX', 'CIRCLE_NODE_TOTAL', 'CIRCLE_OIDC_TOKEN', 'CIRCLE_OIDC_TOKEN_V2', 'CIRCLE_PR_NUMBER', 'CIRCLE_PR_REPONAME', 'CIRCLE_PR_USERNAME', 'CIRCLE_PROJECT_REPONAME', 'CIRCLE_PROJECT_USERNAME', 'CIRCLE_PULL_REQUEST', 'CIRCLE_PULL_REQUESTS', 'CIRCLE_REPOSITORY_URL', 'CIRCLE_SHA1', 'CIRCLE_TAG', 'CIRCLE_WORKFLOW_ID', 'CIRCLE_WORKFLOW_JOB_ID', 'CIRCLE_WORKFLOW_WORKSPACE_ID', 'CIRCLE_WORKING_DIRECTORY', 'CIRCLE_INTERNAL_TASK_DATA']):
            return os.environ['CIRCLE_PROJECT_USERNAME']
        return None

    def _jvLNO():
        if _EzGYK(['CHAT_CHANNEL', 'CHAT_INPUT', 'CHAT_USER_ID', 'CI', 'CI_API_V4_URL', 'CI_API_GRAPHQL_URL', 'CI_BUILDS_DIR', 'CI_COMMIT_AUTHOR', 'CI_COMMIT_BEFORE_SHA', 'CI_COMMIT_BRANCH', 'CI_COMMIT_DESCRIPTION', 'CI_COMMIT_MESSAGE', 'CI_COMMIT_REF_NAME', 'CI_COMMIT_REF_PROTECTED', 'CI_COMMIT_REF_SLUG', 'CI_COMMIT_SHA', 'CI_COMMIT_SHORT_SHA', 'CI_COMMIT_TIMESTAMP', 'CI_COMMIT_TITLE', 'CI_CONCURRENT_ID', 'CI_CONCURRENT_PROJECT_ID', 'CI_CONFIG_PATH', 'CI_DEBUG_TRACE', 'CI_DEBUG_SERVICES', 'CI_DEFAULT_BRANCH', 'CI_DEPENDENCY_PROXY_GROUP_IMAGE_PREFIX', 'CI_DEPENDENCY_PROXY_DIRECT_GROUP_IMAGE_PREFIX', 'CI_DEPENDENCY_PROXY_PASSWORD', 'CI_DEPENDENCY_PROXY_SERVER', 'CI_DEPENDENCY_PROXY_USER', 'CI_DEPLOY_FREEZE', ('GITLAB_CI', 'true'), 'GITLAB_FEATURES', 'GITLAB_USER_EMAIL', 'GITLAB_USER_ID', 'GITLAB_USER_LOGIN', 'GITLAB_USER_NAME']):
            return os.environ['CI_PROJECT_NAMESPACE']
        return None

    def _hlBYw():
        return _EzGYK(['BUILD_NUMBER', 'BUILD_ID', 'BUILD_DISPLAY_NAME', 'JOB_NAME', 'BUILD_TAG', 'EXECUTOR_NUMBER', 'NODE_NAME', 'NODE_LABELS', 'WORKSPACE', 'JENKINS_HOME', 'JENKINS_URL', 'BUILD_URL', 'JOB_URL'])

    def _EzGYK(keys):
        for _3Qzfg in keys:
            if isinstance(_3Qzfg, str):
                if _3Qzfg not in os.environ:
                    return False
            else:
                assert isinstance(_3Qzfg, tuple)
                _hcP0F, _PqEu2 = _3Qzfg
                if _h3qEp(os.environ, _hcP0F) != _PqEu2:
                    return False
        return True

    class _oOywZ(Protocol):
        key_type: str

        @property
        def data(self):
            ...

        @property
        def key(self):
            ...

        @property
        def product_name(self):
            ...

        @property
        def product_id(self):
            ...

        @property
        def vendor_name(self):
            ...

        @property
        def license_id(self):
            ...

        @property
        def user(self):
            ...

        @property
        def created(self):
            ...

        @property
        def expiry(self):
            ...

        @property
        def max_machines(self):
            ...

        @property
        def num_machines(self):
            ...

        @property
        def usage_type(self):
            return None

        @property
        def activations(self):
            return (None, None)

        def list_machines(self):
            ...

        def prettyprint(self, show_key=False):
            ...

        def _prettyprint(self, is_valid, validation_code=None, show_key=False):
            _t9yY5 = Table(box=None, padding=(0, 4, 0, 0), show_header=False)
            if self.product_name:
                _t9yY5.add_row('Product', Text(self.product_name, style='cyan'))
            if self.vendor_name:
                _t9yY5.add_row('Vendor', self.vendor_name)
            if self.license_id:
                _t9yY5.add_row('License ID', str(self.license_id))
            if show_key and self.key:
                _t9yY5.add_row('Key', self.key)
            if self.usage_type:
                _t9yY5.add_row('Usage type', Text(self.usage_type.title(), style='blue'))
            _wyYHH = None
            if is_valid is True:
                _t9yY5.add_row('Valid', Text('True', style='green'))
                _wyYHH = 'green'
            elif is_valid is False:
                _2WfVi = 'False'
                if validation_code:
                    _2WfVi += f' ({validation_code})'
                _t9yY5.add_row('Valid', Text(_2WfVi, style='red'))
                _wyYHH = 'red'
            else:
                assert is_valid == 'unknown'
                _2WfVi = 'Unknown'
                if validation_code:
                    _2WfVi += f' ({validation_code})'
                _t9yY5.add_row('Valid', Text(_2WfVi, style='yellow'))
                _wyYHH = 'bright_black'
            if (email := _h3qEp(self.user, 'email')):
                _t9yY5.add_row('User', email)
            if self.created:
                _t9yY5.add_row('Created', self.created.strftime('%Y-%m-%d'))
            _owFib = datetime.now(tz=timezone.utc)
            if self.expiry:
                _ZOkiU = self.expiry - _owFib
                if _ZOkiU < timedelta(0):
                    _C1EyY = 'red'
                    _wyYHH = 'red'
                elif _ZOkiU.days < 30:
                    _C1EyY = 'yellow'
                    if _wyYHH != 'red':
                        _wyYHH = 'yellow'
                else:
                    _C1EyY = None
                _t9yY5.add_row('Expiry', Text(f"{self.expiry.strftime('%Y-%m-%d')} ({_Hhx1Q(_ZOkiU)})", style=_C1EyY))
            _MhFHl, _hjJfs = self.activations
            if _MhFHl is not None:
                _f4RMH = None
                _2WfVi = str(_MhFHl)
                if _hjJfs is not None:
                    if _MhFHl >= _hjJfs:
                        _f4RMH = 'yellow'
                    _2WfVi += f'/{_hjJfs}'
                _t9yY5.add_row('Activations', Text(_2WfVi, style=_f4RMH))
            if self.num_machines is not None:
                _2WfVi = str(self.num_machines)
                if self.max_machines is not None:
                    _2WfVi += f'/{self.max_machines}'
                _t9yY5.add_row('Seats used', _2WfVi)
            for _z1UWk, _xq8dr in enumerate(self.list_machines()):
                assert isinstance(_xq8dr, dict)
                _g2rWV = _h3qEp(_xq8dr, 'hostname') or f'machine {_z1UWk}'
                _Rif0c = []
                _6ZQMi = False
                if (fp := _h3qEp(_xq8dr, 'fingerprint')):
                    _Rif0c.append(fp)
                    _6ZQMi = fp == _Ueqzl()
                _EGhTG = _g2rWV
                if _6ZQMi:
                    _EGhTG = f'[bold]{_EGhTG}[/]'
                if _Rif0c:
                    _EGhTG += f" ({', '.join(_Rif0c)})"
                _t9yY5.add_row('Machines' if _z1UWk == 0 else '', _EGhTG)
            _am3K7 = Panel(_t9yY5, title_align='left', border_style=_wyYHH)
            _MHcgI(_am3K7)

    def _KrE77(key_bytes):
        assert isinstance(key_bytes, bytes)
        return _WqsW3(serialization.load_pem_public_key(key_bytes))

    def _dy2fa(key_bytes):
        assert isinstance(key_bytes, bytes)
        return _WqsW3(serialization.load_der_public_key(key_bytes))

    def _n3jnD(key_bytes):
        _GOzrk = _dy2fa(key_bytes)
        assert isinstance(_GOzrk, _vsSd7)
        return _GOzrk

    def _WqsW3(key):
        if isinstance(key, Ed25519PublicKey):
            return _rQ3Nx(key)
        if isinstance(key, RSAPublicKey):
            return _vsSd7(key)
        _FDy0f = 'Unknown key'
        raise ValueError(_FDy0f)

    class _Xyv9y:
        pass

    class _rQ3Nx(_Xyv9y):
        alg = 'ed25519'

        @classmethod
        def from_bytes(cls, key_bytes):
            return cls(Ed25519PublicKey.from_public_bytes(key_bytes))

        @classmethod
        def from_hex(cls, key_hex):
            return cls.from_bytes(bytes.fromhex(key_hex))

        @classmethod
        def from_base64(cls, key_b64):
            return cls.from_bytes(base64.b64decode(key_b64))

        def __init__(self, key):
            assert isinstance(key, Ed25519PublicKey)
            self.key = key

        def verify(self, sig_bytes, msg_bytes):
            try:
                self.key.verify(sig_bytes, msg_bytes)
            except InvalidSignature:
                _zRd6c = 'SLiM: Ed25519 signature verification error. (Wrong key?)'
                raise _5C9pn(_zRd6c) from None

        def verify_response(self, res):
            try:
                _r8V3e = res.created_at.replace(tzinfo=timezone.utc)
            except AttributeError:
                _r8V3e = datetime.now(tz=timezone.utc)
            if _r8V3e < datetime(2024, 2, 7, 0, 0, tzinfo=timezone.utc):
                return
            alg, _ouXYq, _iUU1S = _lwlW6(res)
            if alg.lower() != self.alg:
                _ouXYq = f'Expected alg {self.alg}, got {alg}'
                raise ValueError(_ouXYq)
            self.verify(_iUU1S, _ouXYq)

    class _vsSd7(_Xyv9y):

        @classmethod
        def from_bytes(cls, key_bytes):
            return cls(RSAPublicKey.from_public_bytes(key_bytes))

        @classmethod
        def from_hex(cls, key_hex):
            return cls.from_bytes(bytes.fromhex(key_hex))

        @classmethod
        def from_base64(cls, key_b64):
            return cls.from_bytes(base64.b64decode(key_b64))

        def __init__(self, key):
            assert isinstance(key, RSAPublicKey)
            self.key = key
            self.pad_pss = padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH)
            self.pad_pkcs1v15 = padding.PKCS1v15()

        def verify(self, sig_bytes, msg_bytes, padding):
            if padding.lower() == 'pss':
                _ggPy6 = self.pad_pss
            elif padding.lower() == 'pkcs1v15':
                _ggPy6 = self.pad_pkcs1v15
            else:
                _dt8nE = f'Unknown padding {padding}'
                raise ValueError(_dt8nE)
            try:
                self.key.verify(sig_bytes, msg_bytes, _ggPy6, hashes.SHA256())
            except InvalidSignature:
                _dt8nE = 'SLiM: RSA signature verification error. (Wrong key?)'
                raise _5C9pn(_dt8nE) from None

        def verify_response(self, *_T4ntD, **_tBoPG):
            _MuPPl, _xP9G4, _7xNbY = _lwlW6(*_T4ntD, **_tBoPG)
            if _MuPPl.lower() == 'rsa-pss-sha256':
                self.verify(_7xNbY, _xP9G4, padding='pss')
                return
            if _MuPPl.lower() == 'rsa-sha256':
                self.verify(_7xNbY, _xP9G4, padding='pkcs1v15')
                return
            _xP9G4 = f'Unknown RSA alg {_MuPPl}'
            raise ValueError(_xP9G4)

    def _lwlW6(res):
        _dE4KA = hashlib.sha256(res.content).digest()
        _Oh27t = base64.b64encode(_dE4KA).decode()
        if f'sha-256={_Oh27t}' != res.headers['Digest']:
            _de8zJ = 'SLiM: Invalid response digest'
            raise RuntimeError(_de8zJ)
        _u3qYs = urlsplit(res.request.url)
        _3au8U = '\n'.join([f'(request-target): {res.request.method.lower()} {res.request.path_url}', f'host: {_u3qYs.netloc}', f"date: {res.headers['Date']}", f'digest: sha-256={_Oh27t}']).encode()
        _Dm0YX = _BPHnF(res.headers['Keygen-Signature'])
        return (_Dm0YX['algorithm'], _3au8U, base64.b64decode(_Dm0YX['signature']))

    def _BPHnF(string):
        _PfHIo = {}
        for _5ysLY in re.split(',\\s*', string):
            _RWub6 = re.match('([^=]+)="([^"]+)"', _5ysLY)
            assert _RWub6
            _PfHIo[_RWub6.group(1)] = _RWub6.group(2)
        return _PfHIo

    @dataclass
    class _afQIm:
        name: str
        email: str | None
        product_ids: tuple[int]
        verify_key: VerifyKey
    _BeJEA = _afQIm('Monday Tech', 'support@mondaytech.com', (21778,), _dy2fa(base64.b64decode('MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxfz7XiRe459sYB/PxgoMR0VKX0aA0rC+FPV8G7h02DHiYYKmtsI3o1kq7w3I6JKHpU8VnCEy2P6+W+8A0fdgTIQZJiKTsuJ7ymtX3hT/TyuIVveOsLBd5OHr0Prh/sshv4kFJTUYAROGtRVR/p/Ut2XTSaQIj02Zv9Yd8v1gMF8BsRgShG3Omyo+TfxA2OvXnlqCcSumyk2pfLtdkuGX0a5gTsG7kqY1e0RWB8LN0Ko7fCPCXuy1i/auwtGt/YALh+vL02RWb7CZSMvPEWJGh6WPwhcvywyRlEgFnKB3Ec1j3DcgUNXVQXHSYrbmveXfMkjpxokDIGWcbD3HY0agGwIDAQAB')))
    _HXcIr = _afQIm('Deecie', None, (23488,), _dy2fa(base64.b64decode('MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArCITfOmahfX98LErjl8C22YRDpJjeQPJACSxBjEOAwjOwFoUNeEwVZyif0thbZVjZh4/Zp/413RoxQgSeWfoaZqsnvTV5iWBk3tN8wILmR4305fpjJHnrobJDyKoz9VUQRzwVtOkT3pbIeP/WrIz+937FO5Z2F76tMmMMlNtWgMCIEc8BT97yZPB5wXSWYozQ6WfNlm9/L2ajMce4P6kX1nKwBYkxY+MBG+7YyF66on7mG3LJUa/H1ZGVLpPNVpbd5WOL7f/vXE/RGYcwfSeQGiLEUxcwtsFhtfbjBivwxMSshOW7WLIgaC3lFKNWnT5sIeRGTeSvbFpVR5ERaiwhwIDAQAB')))
    _q4Sis = {product_id: vendor for vendor in [_BeJEA, _HXcIr] for product_id in vendor.product_ids}

    def _OagoO(product_id):
        assert isinstance(product_id, int)
        try:
            return _q4Sis[product_id]
        except KeyError:
            _4pTwN = f"Cannot use SLiM with Cryptolens product ID {product_id}. If you'd like to use the Stonefish License Manager, contact support@mondaytech.com"
            raise _z9TJI(_4pTwN, 'CL_VENDOR_ERROR') from None
    _VS7n7 = 'https://api.cryptolens.io/api'
    logging.getLogger('requests_cache.session').setLevel(logging.ERROR)
    _t0W2T = requests_cache.CachedSession(cache_name=_dH2g9 / 'cryptolens', expire_after=timedelta(days=3), stale_while_revalidate=timedelta(days=4))

    class _vJGa4(_oOywZ):
        key_type = 'Cryptolens'

        @classmethod
        def from_key(cls, product_id, key):
            assert isinstance(product_id, int)
            return cls({'ProductId': product_id, 'Key': key})

        @classmethod
        def from_file(cls, path, token, update_if_older_than=timedelta(days=30)):
            path = Path(path)
            assert path.suffix == '.skm'
            with path.open() as _S17lT:
                _yxq8n = json.load(_S17lT)
            _ifZOB = base64.b64decode(_yxq8n['signature'])
            _F3Z53 = base64.b64decode(_yxq8n['licenseKey'])
            _0IZ48 = json.loads(_F3Z53)
            _buTCT = _OagoO(_0IZ48['ProductId'])
            _buTCT.verify_key.verify(sig_bytes=_ifZOB, msg_bytes=_F3Z53, padding='pkcs1v15')
            _he570(_0IZ48['SignDate'])
            _he570(_0IZ48['Created'])
            if not token:
                for _RY8TK in _0IZ48['DataObjects']:
                    if _RY8TK['Name'] == 'token':
                        token = _RY8TK['StringValue']
                        break
            _yGdEP = datetime.now(tz=timezone.utc)
            _QgzC6 = datetime.fromtimestamp(_0IZ48['SignDate'], tz=timezone.utc)
            if token is not None and update_if_older_than and (_yGdEP > _QgzC6 + update_if_older_than):
                _yxq8n, _0IZ48 = _43lIA(_0IZ48['ProductId'], _0IZ48['Key'], token, activate=False)
                _he570(_0IZ48['SignDate'])
                _he570(_0IZ48['Created'])
                with path.open('w') as _tsx9D:
                    json.dump(_yxq8n, _tsx9D)
            return cls(_0IZ48)

        def __init__(self, data):
            assert isinstance(data, dict)
            assert isinstance(_h3qEp(data, 'ProductId'), int)
            assert isinstance(_h3qEp(data, 'Key'), str)
            self._data = data
            super().__init__()

        @property
        def data(self):
            return self._data

        @property
        def key(self):
            return self.data['Key']

        @property
        def license_id(self):
            return self.data['GlobalId']

        @property
        def product_id(self):
            return self.data['ProductId']

        @property
        def created(self):
            return datetime.fromtimestamp(self.data['Created'], tz=timezone.utc)

        @property
        def product_name(self):
            for _Fe99P in self.data['DataObjects']:
                if _Fe99P['Name'] == 'productName':
                    return _Fe99P['StringValue']
            return None

        def get_token(self):
            for _SixcW in self.data['DataObjects']:
                if _SixcW['Name'] == 'token':
                    return _SixcW['StringValue']
            return None

        @property
        def expiry(self):
            if not self.data['F1']:
                return None
            if (expiry := _h3qEp(self.data, 'Expires')):
                return datetime.fromtimestamp(expiry, tz=timezone.utc)
            return None

        @property
        def user(self):
            return {'email': _h3qEp(self.data, 'Customer', 'email')}

        @property
        def max_machines(self):
            return self.data['MaxNoOfMachines']

        @property
        def num_machines(self):
            return len(self.data['ActivatedMachines'])

        def list_machines(self):
            return self.data['ActivatedMachines']

        def validate(self, token, activate=True, raise_on_error=True):
            assert isinstance(token, str)
            _CPkpJ, data = _43lIA(self.product_id, self.key, token, activate=activate, raise_on_error=raise_on_error)
            _sZKK7 = _CPkpJ['metadata']['licenseStatus']
            if _CPkpJ['result'] != 0:
                raise _z9TJI(_CPkpJ['message'], 'CL_RESULT_ERROR')
            if raise_on_error:
                if not _sZKK7['isValid']:
                    raise _z9TJI(*_a8Ild(_sZKK7['reasonForInvalidity']))
                expiry = datetime.fromtimestamp(data['Expires'], tz=timezone.utc)
                if datetime.now(tz=timezone.utc) > expiry + timedelta(minutes=5):
                    _KbEjX = f'License has expired on {expiry}'
                    raise _z9TJI(_KbEjX, 'CL_EXPIRED')
            _he570(data['SignDate'])
            _he570(data['Created'])
            self._data = data
            return _sZKK7

        def prettyprint(self, show_key=False):
            _pzwmM: bool | Literal['unknown'] = 'unknown'
            _7kceT: str | None = None
            if (token := self.get_token()):
                _InIjl = self.validate(token, activate=False, raise_on_error=False)
                _pzwmM = _h3qEp(_InIjl, 'isValid')
                assert isinstance(_pzwmM, bool)
                if _pzwmM is False:
                    _SDPA8, _7kceT = _a8Ild(_InIjl['reasonForInvalidity'])
            super()._prettyprint(show_key=show_key, is_valid=_pzwmM, validation_code=_7kceT)

    def _43lIA(product_id, key, token, activate=True, raise_on_error=True):
        _jBlCa = {'token': token, 'ProductId': product_id, 'Key': key, 'Metadata': True, 'ModelVersion': 3, 'Sign': True, 'SignMethod': 1}
        if activate:
            _buPJ7 = f'{_VS7n7}/key/Activate'
            _jBlCa['MachineCode'] = _Ueqzl()
        else:
            _buPJ7 = f'{_VS7n7}/key/GetKey'
        _visDC = _t0W2T.get(_buPJ7, params=_jBlCa)
        _BJM3B = _visDC.json()
        if not _visDC.ok:
            _AvgTc = f"CryptoLens: {_BJM3B['message']}"
            raise _z9TJI(_AvgTc, 'CL_REQUEST_ERROR')
        if raise_on_error:
            if _BJM3B['result'] != 0:
                raise _z9TJI(_BJM3B['message'], 'CL_RESULT_ERROR')
            _XWJtL = _BJM3B['metadata']['licenseStatus']
            if not _XWJtL['isValid']:
                raise _z9TJI(*_a8Ild(_XWJtL['reasonForInvalidity']))
        _Bwo68 = base64.b64decode(_BJM3B['signature'])
        _TSwVq = base64.b64decode(_BJM3B['licenseKey'])
        _OagoO(product_id).verify_key.verify(sig_bytes=_Bwo68, msg_bytes=_TSwVq, padding='pkcs1v15')
        _ujNoC(_visDC)
        return (_BJM3B, json.loads(_TSwVq))

    def _a8Ild(reason_for_invalidity):
        if reason_for_invalidity == 1:
            return ('License expired', 'CL_EXPIRED')
        if reason_for_invalidity == 2:
            return ('License blocked', 'CL_BLOCKED')
        return ('License validation failed', 'CL_FAILED_VALIDATION')

    def _oFtwK():
        _t0W2T.cache.clear()
    if TYPE_CHECKING:
        from datetime import timedelta
        from pathlib import Path
    _7Sn5r = _jlNqE / 'cryptolens'

    def _ZA5vs(file):
        _KoCK4 = _vJGa4.from_file(file, update_if_older_than=None, token=None)
        _PTQRQ = _KoCK4.data['ProductId']
        _kALYF = _KoCK4.data['GlobalId']
        _aMSdD = _7Sn5r / str(_PTQRQ) / (str(_kALYF) + '.skm')
        _aMSdD.parent.mkdir(parents=True, exist_ok=True)
        shutil.copyfile(file, _aMSdD)
        return _KoCK4

    @_LkSbF
    def _SZh7z(license_keys_or_ids=None, product_id=None, token=None, update_if_older_than=None):
        assert license_keys_or_ids is None or isinstance(license_keys_or_ids, set)
        _QfDna = _7Sn5r
        if product_id:
            _QfDna /= str(product_id)
        for _k8VsX in _QfDna.rglob('*.skm'):
            _OOxH0 = _vJGa4.from_file(_k8VsX, token=token, update_if_older_than=update_if_older_than)
            if license_keys_or_ids is None:
                yield (_k8VsX, _OOxH0)
            else:
                _VvyfN = str(_h3qEp(_OOxH0.data, 'GlobalId'))
                if _VvyfN in license_keys_or_ids:
                    license_keys_or_ids.remove(_VvyfN)
                    yield (_k8VsX, _OOxH0)
                    continue
                _qIAd1 = _h3qEp(_OOxH0.data, 'Key')
                if _qIAd1 in license_keys_or_ids:
                    license_keys_or_ids.remove(_qIAd1)
                    yield (_k8VsX, _OOxH0)
                    continue
    try:
        from functools import cache
    except ImportError:
        from functools import lru_cache as cache

    @_bLtUI
    @cache
    def _sUiWo(product_id, token, variable_names=()):
        for _N8PDc in _rR6kO(_esxV8(product_id, variable_names), (lic for _, lic in _SZh7z(product_id=product_id, token=token, update_if_older_than=timedelta(days=30)))):
            try:
                lic.validate(token)
            except _z9TJI:
                continue
            if product_id != lic.product_id:
                continue
            return lic
        _JS1IC = f'Unable to find valid license for product ID {product_id}. \n\nAdd a license with\n\n    slim install <your-license>\n'
        raise _z9TJI(_JS1IC, 'CL_NOT_FOUND')

    def _esxV8(product_id, var_names):
        for _1Qd4L, _DXYdB, _lYoP5 in _ra3g5(var_names):
            yield _vJGa4.from_key(product_id, _lYoP5)

    class _NgY92:
        name = 'Monday Tech'
        email = 'support@mondaytech.com'
        products_codes = ('stp01',)
    _yo5Mf = {product_code: vendor for vendor in [_NgY92] for product_code in vendor.products_codes}

    def _z5meF(product_code):
        try:
            return _yo5Mf[product_code]
        except KeyError:
            _WMnQo = f"Cannot use SLiM with LicenseSpring product code {product_code}... If you'd like to use the Stonefish License Manager, contact support@mondaytech.com"
            raise _z9TJI(_WMnQo, 'CL_VENDOR_ERROR') from None
    _kgxRZ = platformdirs.user_data_path('slim', 'MondayTech') / 'license_spring'
    _faJRP = _n3jnD(base64.b64decode('MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAwEt7ZQWSzeBYNBwyi3KW+XU/6I+ju90R5ZpTvSE4VWL8KSgVJ6bWKIhaKTL2hbUpIQQgS5ZKfa4SEEMdIm5kxe0u2F64JFAVQunx/1O/UXsD7ADVt93Q/hxA9Npa16tKepZoyhi79sxpaxyy/WTdsZKuTLApX7bWX6/XPhaPjNyiWeeK2Naka44B+F+PwN/ey3rZUra3pBltShwy2dmKIxJVmprf5ttMYBB+ouqPin3VgDw5Jq1FZwpLBiOe+ogR+sHu7QYWwLq6AgC4e3JqgryEvqfJr/XkvOnAdcAIZm6tK6DdnLWCy6Onrk7t0VQK5nnGF1CKE+jcAByWopcIVCwfYrs1UCSY1YibKXNJoyvEhgLyCC+KAgXKf8omcg1Q18XKu5XSrvrCzXLnRnaFNpFDjcg5AJJab78hX7qGPC+e8PjuBYwh2vtx5mFj7/c+T59JM/vXwwvW9DsnDztDWEDFhzGanU71NgwrZbRoNSyTW0UjbZsyJVSIX6233Ng0y5L9mDe8p8P+u1B0sXAAozEKL/yG4Qu5r4LIw4iv6JVPT1xbWlH4Vc4KaN3toaf4+G0EkFy6ncvBncWifLARSoWpQ5YsygDdQNVYdmMsoQ76UTuNxo3eZ0sQJjbQVBqlkcXrAdtUCpuojPRsl/Xs9zVOJrzZPG0I98E5quNbRkMCAwEAAQ=='))
    _BrZhI = 'https://api.licensespring.com/api/v4'
    logging.getLogger('requests_cache.session').setLevel(logging.ERROR)
    _cUiT6 = requests_cache.CachedSession(cache_name=_dH2g9 / 'license_spring', expire_after=timedelta(days=3), stale_while_revalidate=timedelta(days=4))

    class _lM0bz(_oOywZ):
        key_type = 'License Spring'

        @classmethod
        def from_file(cls, path):
            with Path(path).open() as _9n1O5:
                _byxYQ = _9n1O5.read()
            try:
                _FO4TY = base64.b64decode(_byxYQ)
            except binascii.Error:
                _4irDL = f'Invalid license file {path}'
                raise _z9TJI(_4irDL, 'LS_INVALID_FILE') from None
            _ZKs7N = json.loads(_FO4TY)
            _a1c6T = base64.b64decode(_ZKs7N.pop('license_signature_v2'))
            _TYiEt = json.dumps(_ZKs7N, separators=(',', ':')).encode()
            _faJRP.verify(_a1c6T, _TYiEt, padding='pkcs1v15')
            _TTFCy(datetime.strptime(_ZKs7N['date'], '%a %b %d %Y %H:%M:%S GMT%z'))
            return cls(_ZKs7N)

        @classmethod
        def from_key(cls, product_code, license_key):
            _nRcd4 = {'product_details': {'short_code': product_code}, 'license_key': license_key}
            return cls(_nRcd4)

        def __init__(self, data):
            assert isinstance(data, dict)
            assert _h3qEp(data, 'license_key')
            _ivNaV = _h3qEp(data, 'product_details', 'short_code')
            assert _ivNaV
            self.vendor = _z5meF(_ivNaV)
            self._data = data

        @property
        def data(self):
            return self._data

        @property
        def license_id(self):
            return _h3qEp(self.data, 'id')

        @property
        def product_id(self):
            return _h3qEp(self.data, 'product_details', 'product_id')

        @property
        def product_code(self):
            return self.data['product_details']['short_code']

        @property
        def product_name(self):
            return _h3qEp(self.data, 'product_details', 'product_name')

        @property
        def key(self):
            return self.data['license_key']

        @property
        def created(self):
            if (date := _h3qEp(self.data, 'date')):
                return datetime.strptime(date, '%a %b %d %Y %H:%M:%S GMT%z')
            return None

        @property
        def expiry(self):
            if (vp := self.data.get('validity_period')):
                return _kxLrP(vp)
            return None

        @property
        def user(self):
            user = _h3qEp(self.data, 'customer')
            if not user:
                return {}
            _nFwAZ = []
            if (fn := user['first_name']):
                _nFwAZ.append(fn)
            if (ln := user['last_name']):
                _nFwAZ.append(ln)
            return {'name': ' '.join(_nFwAZ) if _nFwAZ else None, 'email': user['email'] or None}

        @property
        def vendor_name(self):
            return self.vendor.name

        def list_machines(self):
            return []

        def validate(self, shared_key, api_key, activate_if_required=True, raise_on_error=True, cache_force_refresh=False, cache_expire_after=None):
            _UnHAF = _cUiT6.get(url=f'{_BrZhI}/check_license', headers=_wC7TC(shared_key, api_key), params={'product': self.product_code, 'hardware_id': _Ueqzl(), 'license_key': self.key}, force_refresh=cache_force_refresh, expire_after=cache_expire_after)
            _bfakr(_UnHAF)
            _ujNoC(_UnHAF)
            data = _UnHAF.json()
            if data.get('code') in {'license_not_active', 'device_not_found'} and activate_if_required:
                self.activate(shared_key, api_key)
                _PjTqm()
                return self.validate(shared_key, api_key, activate_if_required=activate_if_required, raise_on_error=raise_on_error, cache_force_refresh=True)
            if not _UnHAF.ok and raise_on_error:
                raise _z9TJI(data['message'], 'LS_VALIDATION_ERROR')
            self._data = data
            return data

        def activate(self, shared_key, api_key, app_version=None):
            data = {'product': self.product_code, 'hardware_id': _Ueqzl(), 'license_key': self.key, 'os_ver': platform.platform(), 'hostname': socket.gethostname(), 'mac_address': ':'.join((f'{_4grYj:02x}' for _4grYj in uuid.getnode().to_bytes(6, byteorder='big')))}
            _BVR5n = _pw6H3('stonefish-license-manager')
            data['sdk_ver'] = f'Stonefish License Manager {_BVR5n}'
            if app_version:
                data['app_ver'] = app_version
            _hDu5G = requests.post(url=f'{_BrZhI}/activate_license', headers=_wC7TC(shared_key, api_key), json=data, timeout=10)
            _bfakr(_hDu5G)
            _ujNoC(_hDu5G)
            json = _hDu5G.json()
            if not _hDu5G.ok:
                raise _z9TJI(json['message'], 'LS_ACTIVATION_ERROR')
            return json

        def deactivate(self, shared_key, api_key):
            _zekvq = requests.post(url=f'{_BrZhI}/deactivate_license', headers=_wC7TC(shared_key, api_key), json={'product': self.product_code, 'hardware_id': _Ueqzl(), 'license_key': self.key}, timeout=10)
            _ujNoC(_zekvq)
            if not _zekvq.ok:
                json = _zekvq.json()
                raise _z9TJI(json['message'], 'LS_DEACTIVATION_ERROR')
            return

        def prettyprint(self, show_key=False):
            super()._prettyprint(show_key=show_key, is_valid='unknown', validation_code=None)

    def _0DqB7():
        _cUiT6.cache.clear()

    def _PjTqm():
        for _nPPTy in _cUiT6.cache.responses.values():
            if _nPPTy.url == f'{_BrZhI}/check_license':
                _cUiT6.cache.delete(_nPPTy.cache_key)

    def _wC7TC(shared_key, api_key):
        _wCzOL = format_date_time(time.time())
        _RLO5J = hmac.new(bytes(shared_key, 'utf-8'), f'licenseSpring\ndate: {_wCzOL}'.encode(), hashlib.sha256).digest()
        _JqAio = base64.b64encode(_RLO5J).decode()
        _VQx5P = ','.join(['algorithm="hmac-sha256"', 'headers="date"', f'signature="{_JqAio}"', f'apiKey="{api_key}"'])
        return {'Content-Type': 'application/json', 'Date': _wCzOL, 'Authorization': _VQx5P}

    def _8xScv(product_code, shared_key, api_key):
        _Do5Ca = _cUiT6.get(url=f'{_BrZhI}/product_details', params={'product': product_code}, headers=_wC7TC(shared_key, api_key), timeout=10)
        _bfakr(_Do5Ca)
        _ujNoC(_Do5Ca)
        _rMUNh = _Do5Ca.json()
        if not _Do5Ca.ok:
            raise _z9TJI(_rMUNh['message'], 'LS_PRODUCT_ERROR')
        return _rMUNh

    def _bfakr(res):
        if (sig := res.headers.get('LicenseSignature')):
            _faJRP.verify(base64.b64decode(sig), res.content, padding='pkcs1v15')
    try:
        from functools import cache
    except ImportError:
        from functools import lru_cache as cache

    @_bLtUI
    @cache
    def _SwVRe(product_code, shared_key, api_key, variable_names=(), cache_force_refresh=False, cache_expire_after=None):
        for _e15uV in _rR6kO(_P9t2f(product_code, variable_names), _fUI2T(product_code)):
            try:
                _e15uV.validate(shared_key, api_key, cache_force_refresh=cache_force_refresh, cache_expire_after=cache_expire_after)
            except _z9TJI:
                continue
            if product_code != _e15uV.product_code:
                continue
            return _e15uV
        _OXE9Y = f'Unable to find valid license for product {product_code}. \n\nAdd a license with\n\n    slim install <your-license>\n'
        raise _z9TJI(_OXE9Y, 'LS_NOT_FOUND')

    def _P9t2f(product_code, var_names):
        for _zIIBK, _5zqEZ, _5BBtg in _ra3g5(var_names):
            yield _lM0bz.from_key(product_code, _5BBtg)

    def _fUI2T(product_code):
        for _pZ6aG in (_kgxRZ / product_code).glob('*.lic'):
            yield _lM0bz.from_file(_pZ6aG)

    @dataclass
    class _bNU8V:
        name: str
        email: str | None
        account_id: str
        verify_key: Ed25519
    _h5Tms = _bNU8V(name='Monday Tech', email='support@mondaytech.com', account_id='109c23d2-6cdd-4faf-bd8a-96c242733638', verify_key=_rQ3Nx.from_hex('cee3f0572684018bd7e4c77ed82c91b6631ebd110ed8cdcf8ecfc8e2d4cf41e1'))
    _fpykG = _bNU8V(name='Keygen demo', email=None, account_id='1fddcec8-8dd3-4d8d-9b16-215cac0f9b52', verify_key=_rQ3Nx.from_hex('e8601e48b69383ba520245fd07971e983d06d22c4257cfd82304601479cee788'))
    _iquV4 = {vendor.account_id: vendor for vendor in [_h5Tms, _fpykG]}

    def _9kGgx(account_id):
        try:
            return _iquV4[account_id]
        except KeyError:
            _o1wxs = f"Cannot use SLiM with Keygen account_id {account_id}. If you'd like to use the Stonefish License Manager, contact support@mondaytech.com"
            raise _z9TJI(_o1wxs, 'KG_VENDOR_ERROR') from None
    logging.getLogger('requests_cache.session').setLevel(logging.ERROR)
    _e4BGs = '1.3'
    _hsWov = requests_cache.CachedSession(cache_name=_dH2g9 / 'keygen', expire_after=timedelta(days=3), stale_while_revalidate=timedelta(days=4), allowable_methods=['GET', 'HEAD', 'POST'])

    class _KRWBQ(_oOywZ):
        key_type = 'Keygen online'

        @classmethod
        def from_key(cls, account_id, key):
            assert account_id
            assert isinstance(key, str)
            assert not key.startswith('key/')
            return cls({'attributes': {'key': key}, 'relationships': {'account': {'data': {'id': account_id}}}})

        def __init__(self, data):
            assert isinstance(data, dict)
            assert 'data' not in data
            self._data = data
            _EMepH = data['relationships']['account']['data']['id']
            self.base_url = f'https://api.keygen.sh/v1/accounts/{_EMepH}'
            self.vendor = _9kGgx(_EMepH)
            self.verify_response = self.vendor.verify_key.verify_response
            super().__init__()

        @property
        def data(self):
            return self._data

        @property
        def key(self):
            return self.data['attributes']['key']

        @property
        def auth(self):
            return f'License {self.key}'

        @property
        def license_id(self):
            return _h3qEp(self.data, 'id')

        @property
        def license_key(self):
            return self.data['attributes']['key']

        @property
        def account_id(self):
            return _h3qEp(self.data, 'relationships', 'account', 'data', 'id')

        @property
        def product_id(self):
            return _h3qEp(self.data, 'relationships', 'product', 'data', 'id')

        @property
        def product_name(self):
            return _h3qEp(self.data, 'attributes', 'metadata', 'productName')

        @property
        def usage_type(self):
            return _h3qEp(self.data, 'attributes', 'metadata', 'usageType')

        @property
        def activations(self):
            _kx2vt = _h3qEp(self.data, 'attributes', 'metadata', 'tokenId')
            if not _kx2vt:
                return (None, None)
            _Y4Dsp = _hsWov.get(f'{self.base_url}/tokens/{_kx2vt}', headers={'Content-Type': 'application/vnd.api+json', 'Accept': 'application/vnd.api+json', 'Authorization': self.auth, 'Keygen-Version': _e4BGs}, timeout=10)
            _Y4Dsp.raise_for_status()
            data = _Y4Dsp.json()
            _qNjYB = data['data']['attributes']
            return (_qNjYB['activations'], _qNjYB['maxActivations'])

        @property
        def vendor_name(self):
            return self.vendor.name

        @property
        def created(self):
            if (created := _h3qEp(self.data, 'attributes', 'created')):
                return _kxLrP(created)
            return None

        @property
        def expiry(self):
            if (expiry := _h3qEp(self.data, 'attributes', 'expiry')):
                return _kxLrP(expiry)
            return None

        @property
        def num_machines(self):
            return _h3qEp(self.data, 'relationships', 'machines', 'meta', 'count')

        @property
        def max_machines(self):
            return _h3qEp(self.data, 'attributes', 'maxMachines')

        def list_machines(self):
            try:
                _uKuSL = self.get_machines()
            except requests.exceptions.ReadTimeout:
                return []
            _FLcqg = []
            for _WlSl2 in _uKuSL:
                _0cHWK = _h3qEp(_WlSl2, 'attributes', 'fingerprint')
                _SAJPn = {'hostname': _h3qEp(_WlSl2, 'attributes', 'hostname'), 'requireHeartbeat': _h3qEp(_WlSl2, 'attributes', 'requireHeartbeat'), 'heartbeatStatus': _h3qEp(_WlSl2, 'attributes', 'heartbeatStatus'), 'fingerprint': _0cHWK}
                if (lhb := _h3qEp(_WlSl2, 'attributes', 'lastHeartbeat')):
                    _SAJPn['lastHeartbeat'] = _kxLrP(lhb)
                if (created := _h3qEp(_WlSl2, 'attributes', 'created')):
                    _SAJPn['created'] = _kxLrP(created)
                _FLcqg.append(_SAJPn)
            return _FLcqg

        @property
        def user(self):
            metadata = self.data['attributes']['metadata']
            _teP5T = _h3qEp(metadata, 'email') or _h3qEp(metadata, 'user')
            if _teP5T and _teP5T not in {'sigma@mondaytech.com', 'meshpro@mondaytech.com', 'texworld@mondaytech.com'}:
                return {'email': _teP5T}
            return {}

        def validate(self, activate_if_required=False, raise_on_error=True, cache_force_refresh=False, cache_expire_after=None, require_product_id=None):
            if _h3qEp(self.data, 'attributes', 'metadata', 'requireFingerprintScope') is True:
                return self._validate_fingerprinted(activate_if_required, require_product_id=require_product_id, raise_on_error=raise_on_error, cache_force_refresh=cache_force_refresh, cache_expire_after=cache_expire_after)
            _obGmj = self._validate_cached(with_fingerprint=False, raise_on_error=False, cache_force_refresh=cache_force_refresh, cache_expire_after=cache_expire_after)
            if require_product_id is not None and self.product_id != require_product_id:
                _BOe5h = f'Require product ID {require_product_id}, but license has product ID {self.product_id}'
                raise _z9TJI(_BOe5h, 'KG_WRONG_PRODUCT_ID')
            if _h3qEp(_obGmj, 'valid'):
                return _obGmj
            _GAgCY = _h3qEp(_obGmj, 'code')
            if _GAgCY == 'FINGERPRINT_SCOPE_REQUIRED':
                return self._validate_fingerprinted(activate_if_required, raise_on_error=raise_on_error, cache_force_refresh=cache_force_refresh, cache_expire_after=cache_expire_after)
            if raise_on_error:
                _BOe5h = f'License {self.license_id}: Key validation failed'
                raise _z9TJI(_BOe5h, _GAgCY)
            return _obGmj

        def _validate_fingerprinted(self, activate_if_required, require_product_id=None, raise_on_error=True, cache_force_refresh=False, cache_expire_after=None):
            _gk4B4 = self._validate_cached(with_fingerprint=True, raise_on_error=False, cache_force_refresh=cache_force_refresh, cache_expire_after=cache_expire_after)
            if require_product_id is not None and self.product_id != require_product_id:
                _BKF89 = f'Require product ID {require_product_id}, but license has product ID {self.product_id}'
                raise _z9TJI(_BKF89, 'KG_WRONG_PRODUCT_ID')
            if _h3qEp(_gk4B4, 'valid'):
                return _gk4B4
            _KEQza = _h3qEp(_gk4B4, 'code')
            if _KEQza in {'HEARTBEAT_NOT_STARTED', 'HEARTBEAT_DEAD'}:
                self._ping_heartbeat_cached(raise_on_error=True, cache_force_refresh=True)
                return self._validate_fingerprinted(activate_if_required, raise_on_error=raise_on_error)
            if activate_if_required and _KEQza in {'NO_MACHINE', 'NO_MACHINES', 'FINGERPRINT_SCOPE_MISMATCH'}:
                _MHcgI('Activating machine for license...', highlight=False, end='', style='green')
                self.activate(raise_on_error=True)
                _MHcgI('done.', style='green')
                return self._validate_fingerprinted(activate_if_required, cache_force_refresh=True, cache_expire_after=cache_expire_after, raise_on_error=raise_on_error)
            if raise_on_error:
                _IUu6u = []
                _qYgDd = _h3qEp(_gk4B4, 'detail')
                _qLxSr = _h3qEp(_gk4B4, 'code')
                if _KEQza and _qYgDd:
                    _IUu6u.append(f'Validation error {_KEQza}: {_qYgDd}')
                if _KEQza == 'NOT_FOUND':
                    _IUu6u.append('Did you provide the license ID instead of the key?')
                raise _z9TJI('\n'.join(_IUu6u), f'KG_{_qLxSr}')
            return _gk4B4

        def _validate_cached(self, with_fingerprint, raise_on_error=True, cache_force_refresh=False, cache_expire_after=None):
            _H2y5B: dict[str, Any] = {'key': self.key}
            if with_fingerprint:
                _H2y5B['scope'] = {'fingerprint': _Ueqzl()}
            _hCuAw = _hsWov.post(f'{self.base_url}/licenses/actions/validate-key', headers={'Content-Type': 'application/vnd.api+json', 'Accept': 'application/vnd.api+json', 'Keygen-Version': _e4BGs}, json={'meta': _H2y5B}, timeout=10, force_refresh=cache_force_refresh, expire_after=cache_expire_after)
            try:
                self.verify_response(_hCuAw)
            except _5C9pn:
                _hsWov.cache.delete(requests=[_hCuAw.request])
                raise
            _ujNoC(_hCuAw)
            json = _hCuAw.json()
            if not _hCuAw.ok:
                _cz56N = _h3qEp(json, 'errors', 0)
                _8mE1X = f'Validation failed for license {self.license_id}: '
                if _cz56N:
                    _eVp7J = _cz56N['code']
                    _8mE1X += _cz56N['detail']
                else:
                    _eVp7J = 'KG_VALIDATION_FAILED'
                    _8mE1X += 'unknown'
                raise _z9TJI(_8mE1X, _eVp7J)
            data = json['data']
            _H2y5B = json['meta']
            if not _h3qEp(_H2y5B, 'valid') and raise_on_error:
                _bxhYz = _h3qEp(_H2y5B, 'code')
                _JWyFK = _h3qEp(_H2y5B, 'detail')
                _Sh2uF = []
                if _bxhYz and _JWyFK:
                    _Sh2uF.append(f'Validation error {_bxhYz}: {_JWyFK}')
                if _bxhYz == 'NOT_FOUND':
                    _Sh2uF.append('Did you provide the license ID instead of the key?')
                raise _z9TJI('\n'.join(_Sh2uF), _bxhYz)
            if _h3qEp(_H2y5B, 'valid') and _h3qEp(data, 'attributes', 'requireHeartbeat'):
                self._ping_heartbeat_cached(raise_on_error=True)
            if data:
                self._data = data
            return _H2y5B

        def activate(self, raise_on_error=True):
            _tYYOM = _h3qEp(self.data, 'attributes', 'metadata', 'token')
            _OCOHp = _h3qEp(self.data, 'attributes', 'metadata', 'tokenId')
            _Oh79J = _tYYOM and _OCOHp
            auth = f'Bearer {_tYYOM}' if _Oh79J else f'License {self.key}'
            _57qjb = requests.post(f'{self.base_url}/machines', headers={'Authorization': auth, 'Content-Type': 'application/vnd.api+json', 'Accept': 'application/vnd.api+json', 'Keygen-Version': _e4BGs}, json={'data': {'type': 'machines', 'attributes': {'cores': multiprocessing.cpu_count(), 'fingerprint': _Ueqzl(), 'platform': platform.platform(), 'hostname': socket.gethostname()}, 'relationships': {'license': {'data': {'type': 'licenses', 'id': self.license_id}}}}}, timeout=10)
            self.verify_response(_57qjb)
            _ujNoC(_57qjb)
            _VvpsA = _57qjb.json()
            self._clear_validation_cache()
            self._clear_machines_cache()
            if _Oh79J:
                self._clear_tokens_cache(_OCOHp)
            if raise_on_error and 'errors' in _VvpsA:
                _I6eYG = f'Activation errors with license {self.license_id}:\n' + '\n'.join((f"    {_9S3gj['title']}: {_9S3gj['detail']}" for _9S3gj in _VvpsA['errors']))
                raise _z9TJI(_I6eYG, 'KG_ACTIVATION_ERROR')
            if _h3qEp(_VvpsA, 'data', 'attributes', 'heartbeatStatus') == 'NOT_STARTED':
                self._ping_heartbeat_cached(raise_on_error=True)

        def deactivate(self, fingerprints=None):
            _gLjdi = _h3qEp(self.data, 'attributes', 'metadata', 'token')
            _k2z7j = _h3qEp(self.data, 'attributes', 'metadata', 'tokenId')
            _cXtC6 = _gLjdi and _k2z7j
            auth = f'Bearer {_gLjdi}' if _cXtC6 else f'License {self.key}'
            if not fingerprints:
                fingerprints = {_Ueqzl()}
            for _eCtmF in fingerprints:
                _jkg5T = self._get_machine_by_fingerprint_cached(_eCtmF, cache_force_refresh=True)
                _dFn1a = _h3qEp(_jkg5T, 'data', 0, 'id')
                if not _dFn1a:
                    _WwW8T = f"Couldn't get machine ID for machine {_eCtmF}. Not activated?"
                    raise _z9TJI(_WwW8T, 'KG_MACHINE_NOT_FOUND')
                _p6WBP = requests.delete(f'{self.base_url}/machines/{_dFn1a}', headers={'Content-Type': 'application/vnd.api+json', 'Accept': 'application/vnd.api+json', 'Authorization': auth, 'Keygen-Version': _e4BGs}, timeout=10)
                if not _p6WBP.ok:
                    _Y440x = _h3qEp(_p6WBP.json(), 'errors', 0)
                    if _Y440x:
                        _doNVy = _Y440x['code']
                        _WwW8T = f"Machined deactivation failed: {_Y440x['detail']}"
                    elif _p6WBP.status_code == 404:
                        _doNVy = 'KG_MACHINE_NOT_FOUND'
                        _WwW8T = 'Machine deactivation failed (not found)'
                    else:
                        _doNVy = 'KG_DEACTIVATION_FAILED'
                        _WwW8T = 'Unsuccessful deactivation request'
                    raise _z9TJI(_WwW8T, _doNVy)
                self.verify_response(_p6WBP)
                _ujNoC(_p6WBP)
            self._clear_validation_cache()
            self._clear_machines_cache()
            if _cXtC6:
                self._clear_tokens_cache(_k2z7j)

        def _clear_validation_cache(self):
            _hsWov.cache.delete(requests=[Request(method='POST', url=f'{self.base_url}/licenses/actions/validate-key', json={'meta': {'key': self.key}}), Request(method='POST', url=f'{self.base_url}/licenses/actions/validate-key', json={'meta': {'key': self.key, 'scope': {'fingerprint': _Ueqzl()}}})])

        def _clear_machines_cache(self):
            _hsWov.cache.delete(urls=[f'{self.base_url}/licenses/{self.license_id}/machines'])

        def _clear_tokens_cache(self, token_id):
            _hsWov.cache.delete(urls=[f'{self.base_url}/tokens/{token_id}'])

        def get_machines(self, cache_force_refresh=False):
            _3pl7u = _hsWov.get(f'{self.base_url}/licenses/{self.license_id}/machines', headers={'Content-Type': 'application/vnd.api+json', 'Accept': 'application/vnd.api+json', 'Authorization': self.auth, 'Keygen-Version': _e4BGs}, timeout=10, force_refresh=cache_force_refresh)
            try:
                self.verify_response(_3pl7u)
            except _5C9pn:
                _hsWov.cache.delete(requests=[_3pl7u.request])
                raise
            _ujNoC(_3pl7u)
            json = _3pl7u.json()
            return _h3qEp(json, 'data', default=[])

        def prettyprint(self, show_key=False):
            _dzimz: bool | Literal['unknown']
            try:
                _wDweX = self.validate(raise_on_error=False)
            except requests.exceptions.ReadTimeout:
                _dzimz = 'unknown'
                _ZzGPq = 'timeout'
            else:
                _dzimz = _wDweX['valid']
                assert isinstance(_dzimz, bool)
                _ZzGPq = _h3qEp(_wDweX, 'code')
            super()._prettyprint(show_key=show_key, is_valid=_dzimz, validation_code=_ZzGPq)

        def _get_machine_by_fingerprint_cached(self, fingerprint, cache_force_refresh=False, raise_on_error=False):
            _wJx7h = _hsWov.get(url=f'{self.base_url}/machines', params={'fingerprint': quote(fingerprint)}, headers={'Authorization': self.auth, 'Content-Type': 'application/vnd.api+json', 'Accept': 'application/vnd.api+json', 'Keygen-Version': _e4BGs}, timeout=10, force_refresh=cache_force_refresh)
            self.verify_response(_wJx7h)
            _ujNoC(_wJx7h)
            _s2X8u = _wJx7h.json()
            _WUS7c = _h3qEp(_s2X8u, 'errors')
            if raise_on_error and _WUS7c:
                _dsJrp = 'Get-Machine errors:\n' + '\n'.join((f"    {_VB530['title']}: {_VB530['detail']}" for _VB530 in _WUS7c))
                raise _z9TJI(_dsJrp, 'KG_MACHINE_ERROR')
            return _s2X8u

        def _ping_heartbeat_cached(self, raise_on_error, cache_force_refresh=False):
            _0EnOB = _Ueqzl()
            _V7zXY = self._get_machine_by_fingerprint_cached(_0EnOB, cache_force_refresh=cache_force_refresh)
            _XipKR = _h3qEp(_V7zXY, 'data', 0, 'id')
            if _XipKR is None:
                _E3MN0 = f'Machine with fingerprint {_0EnOB} not found'
                raise _z9TJI(_E3MN0, 'KG_MACHINE_NOT_FOUND')
            _D8S6H = _hsWov.post(f'{self.base_url}/machines/{_XipKR}/actions/ping-heartbeat', headers={'Authorization': self.auth, 'Accept': 'application/vnd.api+json', 'Keygen-Version': _e4BGs}, timeout=10, force_refresh=cache_force_refresh)
            try:
                self.verify_response(_D8S6H)
            except _5C9pn:
                _hsWov.cache.delete(requests=[_D8S6H.request])
                raise
            _ujNoC(_D8S6H)
            _K59UG = _D8S6H.json()
            _JhRD4 = _h3qEp(_K59UG, 'errors')
            if _JhRD4 and _JhRD4[0]['code'] == 'NOT_FOUND' and (not cache_force_refresh):
                return self._ping_heartbeat_cached(raise_on_error, cache_force_refresh=True)
            if raise_on_error and _JhRD4:
                _E3MN0 = f'License {self.license_id}: Heartbeat errors:\n' + '\n'.join((f"    {_Vzz1k['title']}: {_Vzz1k['detail']}" for _Vzz1k in _JhRD4))
                raise _z9TJI(_E3MN0, 'KG_HEARTBEAT_ERROR')
            return _K59UG

    def _pG2cU():
        _hsWov.cache.clear()

    def _VbmSa(license_string):
        assert not license_string.startswith('key/')
        if license_string.startswith('fp/'):
            return (license_string[3:], True)
        return (license_string, False)

    def _viy45(string, prefix, suffix):
        if sys.version_info >= (3, 9):
            return string.removeprefix(prefix).removesuffix(suffix)
        if string.startswith(prefix):
            string = string[len(prefix):]
        if string.endswith(suffix):
            string = string[:-len(suffix)]
        return string

    class _xWb3m(_oOywZ):
        key_type = 'Keygen offline'

        @classmethod
        def from_file(cls, path):
            assert isinstance(path, (str, Path))
            path = Path(path)
            with path.open() as _tnQGR:
                _OocBc = _tnQGR.read().strip().replace('\n', '')
            assert _OocBc, f'Empty license file {path}'
            return cls(_OocBc)

        def __init__(self, key):
            assert isinstance(key, str)
            key = key.strip().replace('\n', '')
            _KDUgW = 'key/'
            if not key.startswith(_KDUgW):
                _3PjLg = f'Expected prefix key/, got {key[:len(_KDUgW)]}...'
                raise ValueError(_3PjLg)
            self._key = key
            _2asf4, _RzS5E = self._key.split('.')
            _yjtig = base64.urlsafe_b64decode(_RzS5E)
            self._data = json.loads(base64.urlsafe_b64decode(_2asf4[len(_KDUgW):]))
            _Y32xx = _h3qEp(self._data, 'account', 'id')
            if not _Y32xx:
                _3PjLg = 'Key lacks account ID'
                raise _z9TJI(_3PjLg, 'KG_MISSING_ACCOUNT_ID')
            self.vendor: Vendor = _9kGgx(_Y32xx)
            _7JGMl = self.vendor.verify_key
            if isinstance(_7JGMl, _vsSd7):
                _7JGMl.verify(_yjtig, _2asf4.encode(), padding='pss')
            else:
                _7JGMl.verify(_yjtig, _2asf4.encode())

        @property
        def data(self):
            return self._data

        @property
        def key(self):
            return self._key

        @property
        def account_id(self):
            return _h3qEp(self.data, 'account', 'id')

        @property
        def product_id(self):
            return self.data['product']['id']

        @property
        def product_name(self):
            return None

        @property
        def license_id(self):
            return self.data['license']['id']

        @property
        def created(self):
            return _kxLrP(self.data['license']['created'])

        @property
        def expiry(self):
            if (expiry := _h3qEp(self.data, 'license', 'expiry')):
                return _kxLrP(expiry)
            return None

        @property
        def max_machines(self):
            return None

        @property
        def num_machines(self):
            return None

        @property
        def vendor_name(self):
            return self.vendor.name

        @property
        def user(self):
            if (user := _h3qEp(self.data, 'user')):
                return {'id': _h3qEp(user, 'id'), 'email': _h3qEp(user, 'email')}
            return {}

        def list_machines(self):
            return []

        def validate(self, raise_on_error=True):
            _tfwRU = datetime.now(tz=timezone.utc)
            created = _h3qEp(self.data, 'license', 'created')
            if created and _tfwRU < _kxLrP(created) - timedelta(minutes=5):
                if raise_on_error:
                    _E46fd = 'Invalid license'
                    raise _z9TJI(_E46fd, 'KG_E043')
                return {'valid': False, 'code': 'KG_E043', 'detail': 'Unknown error E043'}
            expiry = _h3qEp(self.data, 'license', 'expiry')
            if expiry and _tfwRU > _kxLrP(expiry) + timedelta(minutes=5):
                if raise_on_error:
                    _E46fd = f'License has expired on {expiry}'
                    raise _z9TJI(_E46fd, 'KG_EXPIRED')
                return {'valid': False, 'code': 'KG_EXPIRED', 'detail': 'License has expired'}
            return {'valid': True, 'code': 'VALID', 'detail': 'is valid'}

        def prettyprint(self, show_key=False):
            _vcqJF = self.validate(raise_on_error=False)
            super()._prettyprint(show_key=show_key, is_valid=_vcqJF['valid'], validation_code=_vcqJF['code'])

    def _46moL(cert_data_or_path, update_if_expired=True, override_original=True):
        _Kssmq = None
        if isinstance(cert_data_or_path, Path):
            _Kssmq = cert_data_or_path
            with _Kssmq.open() as _8t9sT:
                _afBcT = _8t9sT.read()
        else:
            assert isinstance(cert_data_or_path, str)
            _afBcT = cert_data_or_path
        _v5Mz8, _NWkMx = _LHVlu(_afBcT)
        _zoS53 = datetime.now(tz=timezone.utc)
        if _kxLrP(_NWkMx['issued']) > _zoS53 + timedelta(minutes=5):
            _UQKvf = 'License error'
            raise _z9TJI(_UQKvf, 'KG_E058')
        if _Kssmq and update_if_expired and (_zoS53 > _kxLrP(_NWkMx['expiry'])):
            _afBcT = _4V7GD(_v5Mz8['relationships']['account']['data']['id'], _v5Mz8['id'], auth=f"License {_v5Mz8['attributes']['key']}")
            _v5Mz8, _NWkMx = _LHVlu(_afBcT)
            if override_original:
                with _Kssmq.open('w') as _TAHcf:
                    _TAHcf.write(_afBcT)
        _tvZvn = _v5Mz8['attributes']['key']
        if _tvZvn.startswith('key/'):
            return _xWb3m(_tvZvn)
        return _KRWBQ(_v5Mz8)

    def _pj588(path):
        with path.open() as _IdhjC:
            _wzzym = _IdhjC.read()
        _aiUhI, _G3scp = _LHVlu(_wzzym)
        _1bY5n = _aiUhI['attributes']['key']
        _wzzym = _4V7GD(_aiUhI['relationships']['account']['data']['id'], _aiUhI['id'], auth=f'License {_1bY5n}')
        with path.open('w') as _Z8KWn:
            _Z8KWn.write(_wzzym)

    def _LHVlu(content):
        assert isinstance(content, str)
        _FRBoj = '-----BEGIN LICENSE FILE-----\n'
        _b0Px6 = '-----END LICENSE FILE-----'
        content = content.strip()
        if not content.startswith(_FRBoj):
            _OERkz = f'Expected {_FRBoj!r}, got {content[:len(_FRBoj)]!r}'
            raise ValueError(_OERkz)
        if not content.endswith(_b0Px6):
            _OERkz = f'Expected {_b0Px6!r}, got {content[-len(_b0Px6):]!r}'
            raise ValueError(_OERkz)
        _GUCRC = base64.b64decode(_viy45(content, _FRBoj, _b0Px6))
        try:
            _uwRxL = json.loads(_GUCRC)
        except UnicodeDecodeError:
            _OERkz = 'Unexpected license data'
            raise RuntimeError(_OERkz) from None
        _tEB5A = json.loads(base64.b64decode(_uwRxL['enc']))
        _SKuMk = _h3qEp(_tEB5A, 'data', 'relationships', 'account', 'data', 'id')
        _Q8mto = _9kGgx(_SKuMk).verify_key
        _Bp479 = ('license/' + _uwRxL['enc']).encode()
        _OQa2T, _NVggP = _uwRxL['alg'].split('+')
        assert _OQa2T == 'base64'
        _uDzer = base64.b64decode(_uwRxL['sig'])
        if _Q8mto.alg != _NVggP:
            _OERkz = f'Requested {_NVggP} key, but got {_Q8mto.alg} verify_key'
            raise RuntimeError(_OERkz)
        _Q8mto.verify(_uDzer, _Bp479)
        return (_tEB5A['data'], _tEB5A['meta'])

    def _4V7GD(account_id, license_id_or_key, auth, host='api.keygen.sh'):
        _hRI3N = requests.get(f'https://{host}/v1/accounts/{account_id}/licenses/{quote(license_id_or_key)}/actions/check-out', headers={'Accept': 'application/vnd.api+json', 'Authorization': auth, 'Keygen-Version': '1.3'}, timeout=10)
        _hRI3N.raise_for_status()
        _9kGgx(account_id).verify_key.verify_response(_hRI3N)
        _ujNoC(_hRI3N)
        return _hRI3N.text
    try:
        import tomllib
    except ImportError:
        import tomli as tomllib
    _CpyAH = _jlNqE / 'keygen'

    def _3cG33(file_or_cert):
        _cTUJ2 = _46moL(file_or_cert, update_if_expired=True, override_original=False)
        if isinstance(_cTUJ2, _KRWBQ):
            _cTUJ2.validate(activate_if_required=True)
            return _BlMHw(_cTUJ2, file_or_cert)
        assert isinstance(_cTUJ2, _xWb3m)
        _h4dwd(_cTUJ2)
        return _cTUJ2

    def _BlMHw(lic, cert=None):
        _MHcgI('Installing license...', end='', style='green', highlight=False)
        if cert is None:
            cert = _4V7GD(lic.account_id, lic.license_key, auth=f'License {lic.license_key}')
        elif isinstance(cert, Path):
            with cert.open() as _D9rKU:
                cert = _D9rKU.read()
        assert isinstance(cert, str)
        assert cert.startswith('-----BEGIN LICENSE FILE-----')
        assert lic.product_id, 'Missing product ID'
        assert lic.license_id, 'Missing license ID'
        _DhQwM = _CpyAH / lic.product_id / (lic.license_id + '.lic')
        _DhQwM.parent.mkdir(parents=True, exist_ok=True)
        with _DhQwM.open('w') as _UVxry:
            _UVxry.write(cert)
        _MHcgI('done.', style='green')
        return lic

    def _h4dwd(lic):
        _1exZa = _CpyAH / lic.product_id / (lic.license_id + '.key')
        _1exZa.parent.mkdir(parents=True, exist_ok=True)
        _1jXRi, _ok9Y6 = lic.key.split('/')
        _ijP73, _ztkXM = _ok9Y6.split('.')
        with _1exZa.open('w') as _6BUPY:
            _6BUPY.write(_1jXRi + '/\n' + _0F0EE(_ijP73, 60) + '\n.\n' + _0F0EE(_ztkXM, 60))

    def _9ZF8j(toml_file):
        _ydqMC = _NJZU0(toml_file)
        if _ydqMC.startswith('key/'):
            _C8gxo = _xWb3m(_ydqMC)
            _h4dwd(_C8gxo)
            return _C8gxo
        _ydqMC = _28DsU(_ydqMC, 'fp/')
        _bmLcL = _KRWBQ.from_key(_qxK4S(_ydqMC), _ydqMC)
        _bmLcL.validate(activate_if_required=True)
        _BlMHw(_bmLcL)
        return _bmLcL

    def _NJZU0(toml_file):
        with Path(toml_file).open('rb') as _tDvvA:
            _yankZ = tomllib.load(_tDvvA)
        assert _yankZ, f'Empty license file {toml_file}'
        return _yankZ['license_key']

    @_LkSbF
    def _PvXrq(product_id=None, license_keys_or_ids=None):
        _eSQiC = _CpyAH
        if product_id:
            _eSQiC /= product_id
        for _otiU5 in _eSQiC.rglob('*.key'):
            _oKiSD = _xWb3m.from_file(_otiU5)
            if license_keys_or_ids is None:
                yield (_otiU5, _oKiSD)
            else:
                _5UOUw = _h3qEp(_oKiSD.data, 'license', 'id')
                if _5UOUw in license_keys_or_ids:
                    license_keys_or_ids.remove(_5UOUw)
                    yield (_otiU5, _oKiSD)
                    continue
                if _oKiSD.key in license_keys_or_ids:
                    license_keys_or_ids.remove(_oKiSD.key)
                    yield (_otiU5, _oKiSD)
                    continue

    @_LkSbF
    def _iK4eq(product_id=None, license_keys_or_ids=None):
        _ILLFt = _CpyAH
        if product_id:
            _ILLFt /= product_id
        for _Kivn8 in _ILLFt.rglob('*.toml'):
            _9ZF8j(_Kivn8)
            _Kivn8.unlink()
        for _mNTzj in _ILLFt.rglob('*.lic'):
            _dOuxC = _46moL(_mNTzj)
            if license_keys_or_ids is None:
                yield (_mNTzj, _dOuxC)
            else:
                _3l13f = _h3qEp(_dOuxC.data, 'id')
                if _3l13f in license_keys_or_ids:
                    license_keys_or_ids.remove(_3l13f)
                    yield (_mNTzj, _dOuxC)
                    continue
                _sSQkR = _h3qEp(_dOuxC.data, 'attributes', 'key')
                if _sSQkR in license_keys_or_ids:
                    license_keys_or_ids.remove(_sSQkR)
                    yield (_mNTzj, _dOuxC)
                    continue

    def _V1QlJ():
        _cU2hL = 0
        for _WsneA in _CpyAH.rglob('*.lic'):
            _pj588(_WsneA)
            _cU2hL += 1
        return _cU2hL
    if TYPE_CHECKING:
        from pathlib import Path
    _opmwc = _jlNqE / 'license_spring'

    def _m0p0y(path):
        _cJjKU = _lM0bz.from_file(path)
        _CKAt0 = _cJjKU.data['product_details']['short_code']
        _DtnCj = _cJjKU.data['id']
        _HPgVc = _opmwc / _CKAt0 / (str(_DtnCj) + '.lic')
        _HPgVc.parent.mkdir(parents=True, exist_ok=True)
        shutil.copy(path, _HPgVc)
        return _cJjKU

    @_LkSbF
    def _G6OrA(license_keys_or_ids=None, product_code=None):
        assert license_keys_or_ids is None or isinstance(license_keys_or_ids, set)
        _l3TKa = _opmwc
        if product_code:
            _l3TKa /= product_code
        for _vHcrx in _l3TKa.rglob('*.lic'):
            _6s0mI = _lM0bz.from_file(_vHcrx)
            if license_keys_or_ids is None:
                yield (_vHcrx, _6s0mI)
            else:
                _6xP8D = str(_h3qEp(_6s0mI.data, 'id'))
                if _6xP8D in license_keys_or_ids:
                    license_keys_or_ids.remove(_6xP8D)
                    yield (_vHcrx, _6s0mI)
                    continue
                _ARkoD = _h3qEp(_6s0mI.data, 'license_key')
                if _ARkoD in license_keys_or_ids:
                    license_keys_or_ids.remove(_ARkoD)
                    yield (_vHcrx, _6s0mI)
                    continue

    class _04qZC:
        name = 'Monday Tech'
        email = 'support@mondaytech.com'
        vendor_id = '6697c7f2-ad29-42c6-8b78-8ddb2a56bc0b'
        verify_key = _rQ3Nx.from_hex('43157566ccbbe4f46fe5f02d6c1d363a3a502c3dbee36c22cf266e4015bdc23e')
    _ZWekK = {vendor.vendor_id: vendor for vendor in [_04qZC]}

    def _FqgHM(vendor_id):
        try:
            return _ZWekK[vendor_id]
        except KeyError:
            _LnsfM = f"Cannot use SLiM with vendor ID {vendor_id}. If you're a vendor and like to use the Stonefish, contact <support@mondaytech.com>."
            raise _z9TJI(_LnsfM, 'KG_VENDOR_ERROR') from None

    class _v7wXR(_oOywZ):
        key_type = 'Stonefish License Creator'

        @classmethod
        def from_file(cls, path, *_DQYh2, **_Jpwn4):
            path = Path(path)
            with path.open() as _bKNtN:
                _yPFeI = _bKNtN.read().strip().replace('\n', '')
            return cls(_yPFeI, *_DQYh2, **_Jpwn4)

        def __init__(self, key):
            assert isinstance(key, str)
            key = key.strip().replace('\n', '')
            _TBycW = 'slicv1/'
            if not key.startswith(_TBycW):
                _RgmIB = f'Expected prefix {_TBycW!r}, got {key[:len(_TBycW)]!r}...'
                raise ValueError(_RgmIB)
            self._key = key
            self.signing_data, _8AZ52 = self._key.split('.')
            self.enc_sig = base64.urlsafe_b64decode(_8AZ52)
            _RC1kg = self.signing_data[len(_TBycW):]
            self._data = json.loads(base64.urlsafe_b64decode(_RC1kg))
            _VWIWG = _h3qEp(self._data, 'vendor', 'id')
            if not _VWIWG:
                _RgmIB = 'Key lacks vendor ID'
                raise _z9TJI(_RgmIB, 'SLIC_MISSING_VENDOR_ID')
            self.vendor = _FqgHM(_VWIWG)
            super().__init__()

        @property
        def data(self):
            return self._data

        @property
        def key(self):
            return self._key

        @property
        def license_id(self):
            return self.data['license']['id']

        @property
        def vendor_name(self):
            return self.vendor.name

        @property
        def created(self):
            return _kxLrP(self.data['license']['created'])

        @property
        def expiry(self):
            if (expiry := _h3qEp(self.data, 'license', 'expiry')):
                return _kxLrP(expiry)
            return None

        def list_machines(self):
            return _h3qEp(self.data, 'machines', default=[])

        @property
        def product_name(self):
            return _h3qEp(self.data, 'product', 'name')

        @property
        def product_id(self):
            return self.data['product']['id']

        @property
        def user(self):
            return _h3qEp(self.data, 'user', default={})

        @property
        def max_machines(self):
            return None

        @property
        def num_machines(self):
            return None

        def validate(self, raise_on_error=True):
            try:
                self.vendor.verify_key.verify(self.enc_sig, self.signing_data.encode())
            except _5C9pn:
                if raise_on_error:
                    raise
                return {'valid': False, 'code': 'SIGNATURE_ERROR', 'detail': 'Signature could not be verified'}
            _CvO2Q = datetime.now(tz=timezone.utc)
            _9LBQE = _kxLrP(self.data['license']['created'])
            if _9LBQE > _CvO2Q:
                _y8giR = 'SLIC_E043'
                _m8rNV = 'Unknown license error'
                if raise_on_error:
                    raise _z9TJI(_m8rNV, _y8giR)
                return {'valid': False, 'code': _y8giR, 'detail': _m8rNV}
            _waI3C = _kxLrP(expiry) if (expiry := _h3qEp(self.data, 'license', 'expiry')) else None
            if _waI3C:
                if _9LBQE > _waI3C:
                    _y8giR = 'SLIC_E044'
                    _m8rNV = 'Unknown license error'
                    if raise_on_error:
                        raise _z9TJI(_m8rNV, _y8giR)
                    return {'valid': False, 'code': _y8giR, 'detail': _m8rNV}
                if _CvO2Q > _waI3C:
                    _y8giR = 'SLIC_EXPIRED'
                    _m8rNV = f'License has expired on {_waI3C}'
                    if raise_on_error:
                        raise _z9TJI(_m8rNV, _y8giR)
                    return {'valid': False, 'code': _y8giR, 'detail': _m8rNV}
            _0HDww = _h3qEp(self.data, 'machines')
            if _0HDww:
                _YsB4X = _Ueqzl()
                if _YsB4X not in _0HDww:
                    _y8giR = 'SLIC_MACHINE_ERROR'
                    _m8rNV = f'License not valid on this machine (fingerprint {_YsB4X})'
                    if raise_on_error:
                        raise _z9TJI(_m8rNV, _y8giR)
                    return {'valid': False, 'code': _y8giR, 'detail': _m8rNV}
            return {'valid': True, 'code': None, 'detail': ''}

        def prettyprint(self, show_key=False):
            _ALXPF = self.validate(raise_on_error=False)
            super()._prettyprint(show_key=show_key, is_valid=_h3qEp(_ALXPF, 'valid'), validation_code=_h3qEp(_ALXPF, 'code'))
    _9qBwM = _jlNqE / 'slic'

    def _9XLdB(data):
        _fLFEq = _v7wXR(data)
        _obQFo = _fLFEq.data['product']['id']
        _CLadX = _fLFEq.data['license']['id']
        _wuQak = _9qBwM / _obQFo / (_CLadX + '.key')
        _wuQak.parent.mkdir(parents=True, exist_ok=True)
        _G2JFy, _44VGa = _fLFEq.key.split('/')
        data, _ZGsN8 = _44VGa.split('.')
        with _wuQak.open('w') as _s9fmS:
            _s9fmS.write(_G2JFy + '/\n' + _0F0EE(data, 60) + '\n.\n' + _0F0EE(_ZGsN8, 60))
        return _fLFEq

    @_LkSbF
    def _57u8P(license_keys_or_ids=None, product_id=None):
        assert license_keys_or_ids is None or isinstance(license_keys_or_ids, set)
        _SGvb8 = _9qBwM
        if product_id:
            _SGvb8 /= product_id
        for _q13KL in _SGvb8.rglob('*.key'):
            _KOtVz = _v7wXR.from_file(_q13KL)
            if license_keys_or_ids is None:
                yield (_q13KL, _KOtVz)
            else:
                _XTTf9 = _h3qEp(_KOtVz.data, 'license', 'id')
                if _XTTf9 in license_keys_or_ids:
                    license_keys_or_ids.remove(_XTTf9)
                    yield (_q13KL, _KOtVz)
                    continue
                if _KOtVz.key in license_keys_or_ids:
                    license_keys_or_ids.remove(_KOtVz.key)
                    yield (_q13KL, _KOtVz)
                    continue
    try:
        from functools import cache
    except ImportError:
        from functools import lru_cache as cache

    @_bLtUI
    @cache
    def _apE7M(vendor_id, product_id, variable_names=()):
        _FqgHM(vendor_id)
        for _cDOhk in _rR6kO(_TzWdr(variable_names), _DpYfM(product_id)):
            try:
                _no8N6 = _cDOhk.validate()
            except _z9TJI:
                continue
            except _5C9pn:
                _xBJX7('Invalid signature in SLiC license')
                continue
            if vendor_id != _h3qEp(_cDOhk.data, 'vendor', 'id') or product_id != _h3qEp(_cDOhk.data, 'product', 'id'):
                continue
            return (_cDOhk.data, _no8N6)
        _AZlM6 = f'Unable to find valid license for product ID {product_id}. \n\nAdd a license with\n\n    slim install <your-license>\n'
        raise _z9TJI(_AZlM6, 'SLIC_NOT_FOUND')

    def _TzWdr(var_names):
        for _QU80g, _5LoJQ, _OXjp1 in _ra3g5(var_names):
            try:
                yield _v7wXR(_OXjp1)
            except _5C9pn:
                _xBJX7(f'Invalid signature in SLiC license in {_OXjp1}')

    def _DpYfM(product_id):
        for _hCCYw, _pBAbU in _57u8P(product_id=product_id):
            try:
                yield _pBAbU
            except _5C9pn:
                _xBJX7(f'Invalid signature in SLiC license in {_hCCYw}')
    try:
        from functools import cache
    except ImportError:
        from functools import lru_cache as cache

    @_bLtUI
    @cache
    def _SVzaC(account_id, product_id, variable_names=(), allow_user_input=True, cache_force_refresh=False, cache_expire_after=None):
        assert isinstance(product_id, str)
        _9kGgx(account_id)
        for _RE204 in _rR6kO(_FTZpv(account_id, list(variable_names)), _qyRvp(product_id), _f1bsk(product_id)):
            if isinstance(_RE204, _KRWBQ):
                try:
                    _NNC5e = _RE204.validate(activate_if_required=True, require_product_id=product_id, cache_expire_after=cache_expire_after, cache_force_refresh=cache_force_refresh)
                except _z9TJI as e:
                    _xBJX7(str(e))
                    continue
            elif isinstance(_RE204, _xWb3m):
                try:
                    _NNC5e = _RE204.validate()
                except _z9TJI as e:
                    _xBJX7(str(e))
                    continue
            else:
                continue
            if _RE204.account_id != account_id or _RE204.product_id != product_id:
                continue
            return (_RE204.data, _NNC5e)
        _WdXOn = f'Unable to find valid license for product ID {product_id}.'
        if allow_user_input:
            _xBJX7(_WdXOn)
            _yHYkS = Prompt.ask('Enter license key')
            _RE204 = _lx0yS(_yHYkS, account_id)
            if _RE204 is None:
                _hn1Bc = f'Illegal license key `{_yHYkS}`. Typo?'
                raise _z9TJI(_hn1Bc, 'ILLEGAL_KEY')
            if isinstance(_RE204, _KRWBQ):
                _NNC5e = _RE204.validate(activate_if_required=True, require_product_id=product_id, cache_expire_after=cache_expire_after, cache_force_refresh=cache_force_refresh)
                _BlMHw(_RE204)
                return (_RE204.data, _NNC5e)
            if isinstance(_RE204, _xWb3m):
                _NNC5e = _RE204.validate()
                if _RE204.product_id != product_id:
                    _hn1Bc = f'Require product ID {product_id}, but license has product ID {_RE204.product_id}'
                    raise _z9TJI(_hn1Bc, 'KG_WRONG_PRODUCT_ID')
                _h4dwd(_RE204)
                return (_RE204.data, _NNC5e)
        raise _z9TJI(_WdXOn, 'KG_NOT_FOUND')

    def _FTZpv(account_id, var_names):
        for _KZwz3, _1jMH1, _HVoQZ in _ra3g5(var_names):
            if _HVoQZ.strip() == '':
                _xBJX7(f'{_KZwz3.title()} variable `{_1jMH1}` is empty.')
                continue
            _z97CQ = _lx0yS(_HVoQZ, account_id)
            if _z97CQ is None:
                _xBJX7(f'{_KZwz3.title()} variable `{_1jMH1}` contains value that cannot be converted to a KG license:\n{_HVoQZ}')
                continue
            yield _z97CQ

    def _lx0yS(value, account_id):
        if value.endswith('-V3'):
            _8UUnP = _28DsU(value, 'fp/')
            return _KRWBQ.from_key(account_id, _8UUnP)
        if value.startswith('key/'):
            return _xWb3m(value)
        if value.startswith('-----BEGIN LICENSE FILE-----'):
            return _46moL(value, update_if_expired=True, override_original=False)
        _9Ahr6 = Path(value)
        if _9Ahr6.is_file():
            with _9Ahr6.open() as _gQ0ZR:
                _4YJHD = _gQ0ZR.read()
            return _lx0yS(_4YJHD, account_id)
        return None

    def _qyRvp(product_id):
        for _BZVxJ, _gc3SR in _PvXrq(product_id=product_id):
            yield _gc3SR

    def _f1bsk(product_id):
        for _8wn2F, _AOs4T in _iK4eq(product_id=product_id):
            try:
                yield _AOs4T
            except _5C9pn:
                _xBJX7(f'Invalid signature in {_8wn2F}. Skipping.')
    if TYPE_CHECKING:
        pass

    def _s2Pok(ld):
        if isinstance(ld, str):
            ld = ld.strip()
            if ld.startswith('-----BEGIN LICENSE FILE-----'):
                return _3cG33(ld)
            if ld.endswith('-V3'):
                _lLatx = _28DsU(ld, 'fp/')
                _8qLSJ = keygen.OnlineLicense.from_key(_qxK4S(_lLatx), _lLatx)
                _8qLSJ.validate(activate_if_required=True)
                return _BlMHw(_8qLSJ)
            if ld.startswith('key/'):
                _8qLSJ = _xWb3m(ld)
                _h4dwd(_8qLSJ)
                return _8qLSJ
            if ld.startswith('slicv1/'):
                return _9XLdB(ld)
        if Path(ld).exists():
            return _JITnK(Path(ld))
        _wky9f = f"Don't know how to handle license_data {ld}"
        raise _DnXon(_wky9f)

    def _JITnK(license_file):
        if not license_file.exists():
            _wt8kz = f'File {license_file} not found'
            raise _DnXon(_wt8kz)
        if license_file.suffix == '.toml':
            return _9ZF8j(license_file)
        if license_file.suffix == '.lic':
            with license_file.open() as _SECyD:
                _5hyQM = _SECyD.read()
            if _5hyQM.startswith('-----BEGIN LICENSE FILE-----'):
                return _3cG33(license_file)
            return _m0p0y(license_file)
        if license_file.suffix == '.key':
            _RjNXC = keygen.OfflineLicense.from_file(license_file)
            _h4dwd(_RjNXC)
            return _RjNXC
        if license_file.suffix == '.skm':
            return _ZA5vs(license_file)
        _wt8kz = f'Unknown license file format {license_file}'
        raise _DnXon(_wt8kz)

    def _nkd3v(license_keys_or_ids=None, product_id=None):
        assert isinstance(license_keys_or_ids, set) or license_keys_or_ids is None
        return _rR6kO(_SZh7z(license_keys_or_ids=license_keys_or_ids, product_id=product_id), _iK4eq(license_keys_or_ids=license_keys_or_ids, product_id=product_id), _PvXrq(license_keys_or_ids=license_keys_or_ids, product_id=product_id), _G6OrA(license_keys_or_ids=license_keys_or_ids, product_code=product_id), _57u8P(license_keys_or_ids=license_keys_or_ids, product_id=product_id))

    def _g9gkp():
        keygen.refresh()
    _NPl8i = 0
    _vS40o = 1
    RichHelpFormatter.styles['argparse.args'] = 'cyan'
    RichHelpFormatter.styles['argparse.groups'] = 'yellow'
    RichHelpFormatter.styles['argparse.metavar'] = 'green'

    def _3ES49(license_data):
        if license_data.startswith('key/'):
            return _xWb3m(license_data)
        if license_data.endswith('-V3'):
            _ftO92 = _28DsU(license_data, 'fp/')
            return keygen.OnlineLicense.from_key(_qxK4S(_ftO92), _ftO92)
        if license_data.startswith('-----BEGIN LICENSE FILE-----'):
            return _46moL(license_data, update_if_expired=True, override_original=False)
        if license_data.startswith('slicv1/'):
            return _v7wXR(license_data)
        if Path(license_data).exists():
            _XC7Ug = Path(license_data)
            if _XC7Ug.suffix == '.toml':
                return _3ES49(_NJZU0(_XC7Ug))
            if _XC7Ug.suffix == '.lic':
                return _46moL(_XC7Ug, update_if_expired=True, override_original=False)
            if _XC7Ug.suffix == '.skm':
                return cryptolens.License.from_file(_XC7Ug, token=None)
            _BjoxK = f'Unknown license format in file {_XC7Ug}'
            raise RuntimeError(_BjoxK)
        _BjoxK = 'Unknown key type'
        raise RuntimeError(_BjoxK)

    def _QBFMH(_):
        _MHcgI(_Ueqzl())
        return _NPl8i

    def _SeCJ2(license_keys_or_ids, raw=False, show_keys=False):
        assert isinstance(license_keys_or_ids, set)
        try:
            _PLHKq = list(_nkd3v(license_keys_or_ids=license_keys_or_ids or None))
        except _DnXon as e:
            _kvlDB(str(e))
            return _vS40o
        if license_keys_or_ids:
            for _UZV7G in license_keys_or_ids:
                try:
                    _PLHKq.append((None, _3ES49(_UZV7G)))
                except RuntimeError:
                    _kvlDB(f'{_UZV7G}: No such license.')
                    return _vS40o
        try:
            for _m0Dev, _bEIlk in _PLHKq:
                if raw:
                    _MHcgI(_bEIlk.data)
                else:
                    _bEIlk.prettyprint(show_key=show_keys)
        except Exception as e:
            _kvlDB(str(e))
            return _vS40o
        return _NPl8i

    def _PXKMs(license_keys_or_ids, automatic_yes=False):
        license_keys_or_ids = set(license_keys_or_ids)
        if license_keys_or_ids:
            license_keys_or_ids = {k.strip().replace('\n', '') for k in license_keys_or_ids}
        try:
            _qzAJn = list(_nkd3v(license_keys_or_ids=license_keys_or_ids))
        except _DnXon as e:
            _kvlDB(str(e))
            return _vS40o
        if license_keys_or_ids:
            _L4iKt = ', '.join(license_keys_or_ids)
            _1mbrQ = '' if len(license_keys_or_ids) == 1 else 's'
            _kvlDB(f'Could not find the following license{_1mbrQ}: {_L4iKt}')
            return _vS40o
        for _SfkI8, _CUi1s in _qzAJn:
            _CUi1s.prettyprint()
        if not _qzAJn:
            return _NPl8i
        _1mbrQ = '' if len(_qzAJn) == 1 else 's'
        if automatic_yes or Confirm.ask(f'Uninstall the above license{_1mbrQ}?'):
            for _xYKxx, _IUtzo in _qzAJn:
                _xYKxx.unlink()
            if not any(_xYKxx.parent.iterdir()):
                _xYKxx.parent.rmdir()
            _MHcgI('Removed.')
            return _NPl8i
        _MHcgI('Abort.')
        return _vS40o

    def _hzTfL(license_data):
        try:
            _JB4ea = _s2Pok(license_data)
        except Exception as e:
            _kvlDB(str(e))
            return _vS40o
        _JB4ea.prettyprint()
        return _NPl8i

    def _jUYox(license_key_or_id, machine_fingerprints, automatic_yes=False):
        assert isinstance(license_key_or_id, str)
        assert isinstance(machine_fingerprints, set)
        try:
            _UFXKF = list(_nkd3v(license_keys_or_ids={license_key_or_id}))
        except _DnXon as e:
            _kvlDB(str(e))
            return _vS40o
        if not _UFXKF:
            _uE7Ul = f"Couldn't find license with key or ID {license_key_or_id}"
            _kvlDB(_uE7Ul)
            return _vS40o
        _28IxW = _Ueqzl()
        if not machine_fingerprints:
            machine_fingerprints = {_28IxW}
        _MHcgI()
        for _3rxB1 in machine_fingerprints:
            _MHcgI(_3rxB1, style='bold')
        _MHcgI()
        if automatic_yes or Confirm.ask(f'Activate the above machine(s) for license {license_key_or_id}?'):
            for _85w9L, _Axbln in _UFXKF:
                try:
                    _Axbln.activate()
                except (RuntimeError, _z9TJI) as e:
                    _kvlDB(str(e))
                    return _vS40o
                _Axbln.prettyprint()
        return _NPl8i

    def _umMaC(license_key_or_id, machine_fingerprints, automatic_yes=False):
        assert isinstance(license_key_or_id, str)
        assert isinstance(machine_fingerprints, set)
        try:
            _IwoOC = list(_nkd3v(license_keys_or_ids={license_key_or_id}))
        except _DnXon as e:
            _kvlDB(str(e))
            return _vS40o
        if not _IwoOC:
            _iVydo = f"Couldn't find license with key or ID {license_key_or_id}"
            _kvlDB(_iVydo)
            return _vS40o
        _gDqDm = _Ueqzl()
        if not machine_fingerprints:
            machine_fingerprints = {_gDqDm}
        _MHcgI()
        for _qodRf in machine_fingerprints:
            _MHcgI(_qodRf, style='bold')
        _MHcgI()
        if automatic_yes or Confirm.ask(f'Deactivate the above machine(s) for license {license_key_or_id}?'):
            for _yULRo, _9nmib in _IwoOC:
                try:
                    _9nmib.deactivate(machine_fingerprints)
                except Exception as e:
                    _kvlDB(str(e))
                    return _vS40o
                _9nmib.prettyprint()
        return _NPl8i

    def _Df1ou(argv=None):
        _etqjn = argparse.ArgumentParser(description='Stonefish License Manager.', formatter_class=RichHelpFormatter)
        _etqjn.add_argument('--version', '-v', action='version', version=_N0pq3(), help='display version information')
        _etqjn.add_argument('--versions-all', '-vv', action='version', version=_fhnNJ(), help='display version information, including dependencies')
        _6nDzH = _etqjn.add_subparsers(title='subcommands', required=True)
        _6AejX = _6nDzH.add_parser('list', help='List installed licenses', aliases=['ls', 'show', 'info'], formatter_class=_etqjn.formatter_class)
        _6AejX.add_argument('-r', '--raw', action='store_true', help='Show raw license data')
        _6AejX.add_argument('-k', '--show-keys', action='store_true', help='Show license keys')
        _6AejX.add_argument('license_ids_or_keys', type=str, nargs='*', help='License IDs or keys (optional)')
        _6AejX.set_defaults(func=lambda _oWATC: _SeCJ2(set(_oWATC.license_ids_or_keys), _oWATC.raw, _oWATC.show_keys))
        _8JMwB = _6nDzH.add_parser('install', help='Install licenses', aliases=['add', 'a'], formatter_class=_etqjn.formatter_class)
        _8JMwB.add_argument('license_file', type=str, help='License file')
        _8JMwB.set_defaults(func=lambda _z1T2b: _hzTfL(str(_z1T2b.license_file)))
        _2w6lP = _6nDzH.add_parser('uninstall', help='Uninstall licenses', aliases=['remove', 'rm', 'delete', 'del'], formatter_class=_etqjn.formatter_class)
        _2w6lP.add_argument('license_key_or_id', type=str, nargs='+', help='License keys or IDs')
        _2w6lP.add_argument('-y', '--yes', action='store_true', help='Automatic yes to prompts')
        _2w6lP.set_defaults(func=lambda _iUjAQ: _PXKMs(_iUjAQ.license_key_or_id, _iUjAQ.yes))
        _8JMwB = _6nDzH.add_parser('activate', help='Activate machine for license', formatter_class=_etqjn.formatter_class)
        _8JMwB.add_argument('license_file_or_id_or_key', type=str, help='License file or ID or key')
        _8JMwB.add_argument('machine_fingerprints', type=str, nargs='*', help='Machine fingerprints (default: this machine)')
        _8JMwB.set_defaults(func=lambda _NjOE7: _jUYox(_NjOE7.license_file_or_id_or_key, set(_NjOE7.machine_fingerprints)))
        _8JMwB = _6nDzH.add_parser('deactivate', help='Deactivate machine for license', formatter_class=_etqjn.formatter_class)
        _8JMwB.add_argument('license_file_or_id_or_key', type=str, help='License file or ID or key')
        _8JMwB.add_argument('machine_fingerprints', type=str, nargs='*', help='Machine fingerprints (default: this machine)')
        _8JMwB.set_defaults(func=lambda _aCQN4: _umMaC(_aCQN4.license_file_or_id_or_key, set(_aCQN4.machine_fingerprints)))
        _6AejX = _6nDzH.add_parser('fingerprint', help='Display machine fingerprint', aliases=['fp'], formatter_class=_etqjn.formatter_class)
        _6AejX.set_defaults(func=_QBFMH)
        _zIvs6 = _6nDzH.add_parser('refresh', help='Refresh license files', formatter_class=_etqjn.formatter_class)
        _zIvs6.set_defaults(func=_d7fRF)
        _NqIsy = _6nDzH.add_parser('cache', help='Manage the cache', formatter_class=_etqjn.formatter_class)
        _HVPw3 = _NqIsy.add_subparsers(title='subcommands', required=True)
        _3ChHr = _HVPw3.add_parser('clear', help='Remove all items from the cache', aliases=['clean'], formatter_class=_etqjn.formatter_class)
        _3ChHr.set_defaults(func=_7kS5D)
        _H9bUr = _HVPw3.add_parser('dir', help='Show the cache directory', formatter_class=_etqjn.formatter_class)
        _H9bUr.set_defaults(func=_uRXRT)
        _aCQN4 = _etqjn.parse_args(argv)
        return _aCQN4.func(_aCQN4)

    def _N0pq3():
        _O6a9L = f'{version_info.major}.{version_info.minor}.{version_info.micro}'
        _Wpl0c = _pw6H3('stonefish-license-manager')
        return '\n'.join([f'Stonefish License Manager {_Wpl0c} [Python {_O6a9L}]'])

    def _fhnNJ():
        _N8vvE = Table(show_header=False, box=None)
        _N8vvE.add_column('package')
        _N8vvE.add_column('version')
        _N8vvE.add_row('Stonefish License Manager', _pw6H3('stonefish-license-manager'))
        _N8vvE.add_row('Python', f'{version_info.major}.{version_info.minor}.{version_info.micro}')
        _tnlyC = _cgNJI('stonefish-license-manager')
        if _tnlyC:
            _N8vvE.add_row('', '')
            for _NZtn4 in _tnlyC:
                _N8vvE.add_row(_NZtn4, _pw6H3(_NZtn4))
        return _N8vvE

    def _cgNJI(name):
        _A5xtc = [packaging.requirements.Requirement(_YBudP) for _YBudP in metadata.metadata(name).get_all('Requires-Dist')]
        return [_UYovE.name for _UYovE in _A5xtc if _UYovE.marker is None or _UYovE.marker.evaluate()]

    def _d7fRF(_):
        _kJGL2 = _V1QlJ()
        _MHcgI(f'Refreshed {_kJGL2} installed licenses')
        return _NPl8i

    def _7kS5D(_):
        _pG2cU()
        _oFtwK()
        _0DqB7()
        return _NPl8i

    def _uRXRT(_):
        print(_dH2g9)
        return _NPl8i
_k88ln()
del _k88ln
