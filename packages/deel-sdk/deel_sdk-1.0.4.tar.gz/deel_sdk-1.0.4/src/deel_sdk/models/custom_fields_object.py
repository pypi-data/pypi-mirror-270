# This file was generated by liblab | https://liblab.com/

from enum import Enum
from typing import Union
from typing import List
from .utils.json_map import JsonMap
from .base import BaseModel
from .base import OneOfBaseModel


class Type1Name(Enum):
    """An enumeration representing different categories.

    :cvar TEXT: "text"
    :vartype TEXT: str
    :cvar NUMBER: "number"
    :vartype NUMBER: str
    :cvar DATE: "date"
    :vartype DATE: str
    :cvar PERCENTAGE: "percentage"
    :vartype PERCENTAGE: str
    """

    TEXT = "text"
    NUMBER = "number"
    DATE = "date"
    PERCENTAGE = "percentage"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(map(lambda x: x.value, Type1Name._member_map_.values()))


@JsonMap({})
class Type1(BaseModel):
    """Type1

    :param name: Simple types, defaults to None
    :type name: Type1Name, optional
    """

    def __init__(self, name: Type1Name = None):
        if name is not None:
            self.name = self._enum_matching(name, Type1Name.list(), "name")


class Type2Name(Enum):
    """An enumeration representing different categories.

    :cvar CURRENCY: "currency"
    :vartype CURRENCY: str
    """

    CURRENCY = "currency"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(map(lambda x: x.value, Type2Name._member_map_.values()))


@JsonMap({"is_fixed": "isFixed"})
class Type2(BaseModel):
    """Type2

    :param name: Currency type, defaults to None
    :type name: Type2Name, optional
    :param is_fixed: When currency is fixed, only the amount can be edited by the users, defaults to None
    :type is_fixed: bool, optional
    :param currency: Currency code, defaults to None
    :type currency: str, optional
    """

    def __init__(
        self, name: Type2Name = None, is_fixed: bool = None, currency: str = None
    ):
        if name is not None:
            self.name = self._enum_matching(name, Type2Name.list(), "name")
        if is_fixed is not None:
            self.is_fixed = is_fixed
        if currency is not None:
            self.currency = currency


class Type3Name(Enum):
    """An enumeration representing different categories.

    :cvar LIST: "list"
    :vartype LIST: str
    :cvar MULTISELECT: "multiselect"
    :vartype MULTISELECT: str
    """

    LIST = "list"
    MULTISELECT = "multiselect"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(map(lambda x: x.value, Type3Name._member_map_.values()))


@JsonMap({})
class Type3(BaseModel):
    """Type3

    :param name: List types, defaults to None
    :type name: Type3Name, optional
    :param options: List of options for the custom field, defaults to None
    :type options: List[str], optional
    """

    def __init__(self, name: Type3Name = None, options: List[str] = None):
        if name is not None:
            self.name = self._enum_matching(name, Type3Name.list(), "name")
        if options is not None:
            self.options = options


class CustomFieldsObjectTypeGuard(OneOfBaseModel):
    class_list = {"Type1": Type1, "Type2": Type2, "Type3": Type3}


CustomFieldsObjectType = Union[Type1, Type2, Type3]


class ProvidedBy(Enum):
    """An enumeration representing different categories.

    :cvar ORGANIZATION: "organization"
    :vartype ORGANIZATION: str
    :cvar WORKER: "worker"
    :vartype WORKER: str
    """

    ORGANIZATION = "organization"
    WORKER = "worker"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(map(lambda x: x.value, ProvidedBy._member_map_.values()))


@JsonMap({"provided_by": "providedBy", "is_sensitive": "isSensitive"})
class Access(BaseModel):
    """Access settings for the custom field

    :param provided_by: Entities providing access to the custom field, defaults to None
    :type provided_by: List[ProvidedBy], optional
    :param is_sensitive: Whether the custom field is sensitive, defaults to None
    :type is_sensitive: bool, optional
    """

    def __init__(self, provided_by: List[ProvidedBy] = None, is_sensitive: bool = None):
        if provided_by is not None:
            self.provided_by = self._define_list(provided_by, ProvidedBy)
        if is_sensitive is not None:
            self.is_sensitive = is_sensitive


class WorkerTypes(Enum):
    """An enumeration representing different categories.

    :cvar EOR: "eor"
    :vartype EOR: str
    :cvar CONTRACTOR: "contractor"
    :vartype CONTRACTOR: str
    :cvar HRIS_DIRECT_EMPLOYEE: "hris_direct_employee"
    :vartype HRIS_DIRECT_EMPLOYEE: str
    :cvar DIRECT_EMPLOYEE: "direct_employee"
    :vartype DIRECT_EMPLOYEE: str
    """

    EOR = "eor"
    CONTRACTOR = "contractor"
    HRIS_DIRECT_EMPLOYEE = "hris_direct_employee"
    DIRECT_EMPLOYEE = "direct_employee"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(map(lambda x: x.value, WorkerTypes._member_map_.values()))


@JsonMap({"worker_types": "workerTypes"})
class Settings(BaseModel):
    """Settings

    :param access: Access settings for the custom field, defaults to None
    :type access: Access, optional
    :param required: Whether the custom field is required, defaults to None
    :type required: bool, optional
    :param countries: Countries for which the custom field is applicable., defaults to None
    :type countries: List[str], optional
    :param worker_types: Worker types for which the custom field is applicable, defaults to None
    :type worker_types: List[WorkerTypes], optional
    """

    def __init__(
        self,
        access: Access = None,
        required: bool = None,
        countries: List[str] = None,
        worker_types: List[WorkerTypes] = None,
    ):
        if access is not None:
            self.access = self._define_object(access, Access)
        if required is not None:
            self.required = required
        if countries is not None:
            self.countries = countries
        if worker_types is not None:
            self.worker_types = self._define_list(worker_types, WorkerTypes)


class Placement(Enum):
    """An enumeration representing different categories.

    :cvar PROFILE: "profile"
    :vartype PROFILE: str
    :cvar CONTRACT: "contract"
    :vartype CONTRACT: str
    """

    PROFILE = "profile"
    CONTRACT = "contract"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(map(lambda x: x.value, Placement._member_map_.values()))


@JsonMap({"id_": "id", "type_": "type", "created_at": "createdAt"})
class CustomFieldsObject(BaseModel):
    """CustomFieldsObject

    :param id_: id_, defaults to None
    :type id_: str, optional
    :param name: Name of the custom field, defaults to None
    :type name: str, optional
    :param type_: type_, defaults to None
    :type type_: CustomFieldsObjectType, optional
    :param settings: settings, defaults to None
    :type settings: Settings, optional
    :param created_at: Creation date of the custom field, defaults to None
    :type created_at: str, optional
    :param placement: Valid placements for custom field, defaults to None
    :type placement: Placement, optional
    :param description: Description of the custom field, defaults to None
    :type description: str, optional
    """

    def __init__(
        self,
        id_: str = None,
        name: str = None,
        type_: CustomFieldsObjectType = None,
        settings: Settings = None,
        created_at: str = None,
        placement: Placement = None,
        description: str = None,
    ):
        if id_ is not None:
            self.id_ = id_
        if name is not None:
            self.name = name
        if type_ is not None:
            self.type_ = CustomFieldsObjectTypeGuard.return_one_of(type_)
        if settings is not None:
            self.settings = self._define_object(settings, Settings)
        if created_at is not None:
            self.created_at = created_at
        if placement is not None:
            self.placement = self._enum_matching(
                placement, Placement.list(), "placement"
            )
        if description is not None:
            self.description = description
