#
# DO NOT MODIFY THIS FILE
#
# This file is automatically generated when tests are run
#

from binascii import crc32
from inspect import Parameter, signature
import re
import sys
from typing import Any, List, Optional, Protocol, Union, cast, get_type_hints
from unittest.mock import Mock, call

import pytest

from unpaginate import Pagination, unpaginate

if sys.version_info < (3, 9):  # pragma: no cover
    from typing import Iterable, Iterator
else:  # pragma: no cover
    from collections.abc import Iterable, Iterator

if sys.version_info < (3, 11):  # pragma: no cover
    from typing_extensions import assert_type
else:  # pragma: no cover
    from typing import assert_type


def test_unpaginate_page() -> None:
    mock_range = Mock(side_effect=range)

    @unpaginate
    def fct(pagination: Pagination) -> Iterable[int]:
        page_size = 20
        start = pagination.page * page_size
        stop = start + page_size
        if stop == 100:
            pagination.is_last_page = True
        return cast(range, mock_range(start, stop))

    assert list(fct()) == list(range(100))
    assert mock_range.call_args_list == [
        call(0, 20),
        call(20, 40),
        call(40, 60),
        call(60, 80),
        call(80, 100),
    ]


def test_unpaginate_offset() -> None:
    mock_range = Mock(side_effect=range)

    @unpaginate
    def fct(pagination: Pagination) -> Iterable[int]:
        start = pagination.offset
        stop = start * 2 + 1
        if stop > 100:
            pagination.is_last_page = True
        return cast(range, mock_range(start, stop))

    assert list(fct()) == list(range(127))
    assert mock_range.call_args_list == [
        call(0, 1),
        call(1, 3),
        call(3, 7),
        call(7, 15),
        call(15, 31),
        call(31, 63),
        call(63, 127),
    ]


def test_unpaginate_offset_during_iteration() -> None:
    @unpaginate
    def fct(pagination: Pagination) -> Iterable[int]:
        for _ in range(10):
            yield pagination.offset
            if pagination.offset == 42:
                pagination.is_last_page = True
                break

    assert list(fct()) == list(range(42))


def test_unpaginate_context() -> None:
    @unpaginate
    def fct(pagination: Pagination[Optional[bytes]], /) -> Iterable[str]:
        pagination.context = crc32(
            pagination.context or bytes.fromhex("00000000")
        ).to_bytes(4, "big")
        value = pagination.context.hex()
        if value[0] == "0":
            pagination.is_last_page = True
        yield value

    assert list(fct()) == [
        "2144df1c",
        "5cf8b7c4",
        "2cc573b8",
        "9d6c8aba",
        "c57bfe72",
        "0c479aba",
    ]


def test_unpaginate_stop_when_empty() -> None:
    mock_range = Mock(side_effect=range)
    sizes = [30, 10, 20, 0, 40, 50]

    @unpaginate
    def fct(pagination: Pagination) -> Iterable[int]:
        start = pagination.offset
        try:
            stop = start + sizes[pagination.page]
        except IndexError:
            pagination.is_last_page = True
            return []
        return cast(range, mock_range(start, stop))

    assert list(fct()) == list(range(60))
    assert mock_range.call_args_list == [
        call(0, 30),
        call(30, 40),
        call(40, 60),
        call(60, 60),
    ]


def test_unpaginate_generic_function() -> None:
    @unpaginate
    def fct(
        pagination: Pagination,
        var_a: int,
        /,
        var_b: int,
        *var_c: int,
        var_d: int,
        var_e: int = 42,
        **var_f: int,
    ) -> List[int]:
        """Foobar"""
        if pagination.page == 0:
            return [var_a, var_b, *var_c, var_d, var_e, *var_f.values()]
        return []

    class ExpectedType(Protocol):
        def __call__(
            self,
            var_a: int,
            /,
            var_b: int,
            *var_c: int,
            var_d: int,
            var_e: int = 42,
            **var_f: int,
        ) -> Iterator[int]: ...

    assert_type(fct, ExpectedType)

    assert fct.__name__ == "fct", "name"
    assert fct.__doc__ == "Foobar", "doc"
    sig = signature(fct)
    assert list(sig.parameters.values()) == [
        Parameter("var_a", Parameter.POSITIONAL_ONLY, annotation=int),
        Parameter("var_b", Parameter.POSITIONAL_OR_KEYWORD, annotation=int),
        Parameter("var_c", Parameter.VAR_POSITIONAL, annotation=int),
        Parameter("var_d", Parameter.KEYWORD_ONLY, annotation=int),
        Parameter("var_e", Parameter.KEYWORD_ONLY, annotation=int, default=42),
        Parameter("var_f", Parameter.VAR_KEYWORD, annotation=int),
    ], "signature parameters"
    assert sig.return_annotation == Iterator[Any], "signature return_annotation"
    assert get_type_hints(fct) == {
        "var_a": int,
        "var_b": int,
        "var_c": int,
        "var_d": int,
        "var_e": int,
        "var_f": int,
        "return": Iterator[Any],
    }

    assert list(fct(1, 2, 3, 4, foo=5, bar=6, var_d=7)) == [1, 2, 3, 4, 7, 42, 5, 6]


def test_unpaginate_generic_method() -> None:
    class Klass:
        def __init__(self, value: int) -> None:
            self.value = value

        @unpaginate
        def meth(
            self,
            pagination: Pagination,
            var_a: int,
            *var_b: int,
            var_c: int,
            var_d: int = 42,
            **var_e: int,
        ) -> List[int]:
            """Foobar"""
            if pagination.page == 0:
                return [self.value, var_a, *var_b, var_c, var_d, *var_e.values()]
            return []

    class ExpectedClassMethodType(Protocol):
        def __call__(
            self,
            obj: Klass,
            /,
            var_a: int,
            *var_b: int,
            var_c: int,
            var_d: int = 42,
            **var_e: int,
        ) -> Iterator[int]: ...

    assert_type(Klass.meth, ExpectedClassMethodType)

    assert Klass.meth.__name__ == "meth", "name"
    assert Klass.meth.__doc__ == "Foobar", "doc"
    sig = signature(Klass.meth)
    assert list(sig.parameters.values()) == [
        Parameter("self", Parameter.POSITIONAL_OR_KEYWORD),
        Parameter("var_a", Parameter.POSITIONAL_OR_KEYWORD, annotation=int),
        Parameter("var_b", Parameter.VAR_POSITIONAL, annotation=int),
        Parameter("var_c", Parameter.KEYWORD_ONLY, annotation=int),
        Parameter("var_d", Parameter.KEYWORD_ONLY, annotation=int, default=42),
        Parameter("var_e", Parameter.VAR_KEYWORD, annotation=int),
    ], "signature parameters"
    assert sig.return_annotation == Iterator[Any], "signature return_annotation"
    assert get_type_hints(Klass.meth) == {
        "var_a": int,
        "var_b": int,
        "var_c": int,
        "var_d": int,
        "var_e": int,
        "return": Iterator[Any],
    }

    instance = Klass(1337)

    class ExpectedType(Protocol):
        def __call__(
            self,
            var_a: int,
            *var_b: int,
            var_c: int,
            var_d: int = 42,
            **var_e: int,
        ) -> Iterator[int]: ...

    assert_type(instance.meth, ExpectedType)

    assert instance.meth.__name__ == "meth", "name"
    assert instance.meth.__doc__ == "Foobar", "doc"
    sig = signature(instance.meth)
    assert list(sig.parameters.values()) == [
        Parameter("var_a", Parameter.POSITIONAL_OR_KEYWORD, annotation=int),
        Parameter("var_b", Parameter.VAR_POSITIONAL, annotation=int),
        Parameter("var_c", Parameter.KEYWORD_ONLY, annotation=int),
        Parameter("var_d", Parameter.KEYWORD_ONLY, annotation=int, default=42),
        Parameter("var_e", Parameter.VAR_KEYWORD, annotation=int),
    ], "signature parameters"
    assert sig.return_annotation == Iterator[Any], "signature return_annotation"
    assert get_type_hints(instance.meth) == {
        "var_a": int,
        "var_b": int,
        "var_c": int,
        "var_d": int,
        "var_e": int,
        "return": Iterator[Any],
    }

    assert list(instance.meth(1, 2, 3, foo=4, bar=5, var_c=6)) == [
        1337,
        1,
        2,
        3,
        6,
        42,
        4,
        5,
    ]


def test_unpaginate_generic_staticmethod() -> None:
    class Klass:
        @staticmethod
        @unpaginate
        def meth0(
            pagination: Pagination,
            var_a: int,
            *var_b: int,
            var_c: int,
            var_d: int = 42,
            **var_e: int,
        ) -> List[int]:
            """Foobar"""
            if pagination.page == 0:
                return [var_a, *var_b, var_c, var_d, *var_e.values()]
            return []

        @unpaginate
        @staticmethod
        def meth1(
            pagination: Pagination,
            var_a: int,
            *var_b: int,
            var_c: int,
            var_d: int = 42,
            **var_e: int,
        ) -> List[int]:
            """Foobar"""
            if pagination.page == 0:
                return [var_a, *var_b, var_c, var_d, *var_e.values()]
            return []

    class ExpectedType(Protocol):
        def __call__(
            self,
            var_a: int,
            *var_b: int,
            var_c: int,
            var_d: int = 42,
            **var_e: int,
        ) -> Iterator[int]: ...

    instance = Klass()

    assert_type(Klass.meth0, ExpectedType)
    assert_type(Klass.meth1, ExpectedType)
    assert_type(instance.meth0, ExpectedType)
    assert_type(instance.meth1, ExpectedType)

    assert Klass.meth0.__name__ == "meth0", "name"
    assert Klass.meth1.__name__ == "meth1", "name"
    assert instance.meth0.__name__ == "meth0", "name"
    assert instance.meth1.__name__ == "meth1", "name"

    for meth in (Klass.meth0, Klass.meth1, instance.meth0, instance.meth1):
        assert meth.__doc__ == "Foobar", "doc"
        sig = signature(meth)
        assert list(sig.parameters.values()) == [
            Parameter("var_a", Parameter.POSITIONAL_OR_KEYWORD, annotation=int),
            Parameter("var_b", Parameter.VAR_POSITIONAL, annotation=int),
            Parameter("var_c", Parameter.KEYWORD_ONLY, annotation=int),
            Parameter("var_d", Parameter.KEYWORD_ONLY, annotation=int, default=42),
            Parameter("var_e", Parameter.VAR_KEYWORD, annotation=int),
        ], "signature parameters"
        assert sig.return_annotation == Iterator[Any], "signature return_annotation"
        assert get_type_hints(meth) == {
            "var_a": int,
            "var_b": int,
            "var_c": int,
            "var_d": int,
            "var_e": int,
            "return": Iterator[Any],
        }

        assert list(meth(1, 2, 3, foo=4, bar=5, var_c=6)) == [1, 2, 3, 6, 42, 4, 5]


def test_unpaginate_generic_classmethod() -> None:
    class Klass:
        value = 1337

        @classmethod
        @unpaginate
        def meth0(
            cls,
            pagination: Pagination,
            var_a: int,
            *var_b: int,
            var_c: int,
            var_d: int = 42,
            **var_e: int,
        ) -> List[int]:
            """Foobar"""
            if pagination.page == 0:
                return [cls.value, var_a, *var_b, var_c, var_d, *var_e.values()]
            return []

        @unpaginate
        @classmethod
        def meth1(
            cls,
            pagination: Pagination,
            var_a: int,
            *var_b: int,
            var_c: int,
            var_d: int = 42,
            **var_e: int,
        ) -> List[int]:
            """Foobar"""
            if pagination.page == 0:
                return [cls.value, var_a, *var_b, var_c, var_d, *var_e.values()]
            return []

    class ExpectedType(Protocol):
        def __call__(
            self,
            var_a: int,
            *var_b: int,
            var_c: int,
            var_d: int = 42,
            **var_e: int,
        ) -> Iterator[int]: ...

    assert_type(Klass.meth0, ExpectedType)
    assert_type(Klass.meth1, ExpectedType)

    assert Klass.meth0.__name__ == "meth0", "name"
    assert Klass.meth1.__name__ == "meth1", "name"

    for meth in (Klass.meth0, Klass.meth1):
        assert meth.__doc__ == "Foobar", "doc"
        sig = signature(meth)
        assert list(sig.parameters.values()) == [
            Parameter("var_a", Parameter.POSITIONAL_OR_KEYWORD, annotation=int),
            Parameter("var_b", Parameter.VAR_POSITIONAL, annotation=int),
            Parameter("var_c", Parameter.KEYWORD_ONLY, annotation=int),
            Parameter("var_d", Parameter.KEYWORD_ONLY, annotation=int, default=42),
            Parameter("var_e", Parameter.VAR_KEYWORD, annotation=int),
        ], "signature parameters"
        assert sig.return_annotation == Iterator[Any], "signature return_annotation"
        assert get_type_hints(meth) == {
            "var_a": int,
            "var_b": int,
            "var_c": int,
            "var_d": int,
            "var_e": int,
            "return": Iterator[Any],
        }

        assert list(meth(1, 2, 3, foo=4, bar=5, var_c=6)) == [
            1337,
            1,
            2,
            3,
            6,
            42,
            4,
            5,
        ]


def test_unpaginate_not_iterable() -> None:
    @unpaginate  # type: ignore[arg-type]
    def fct(pagination: Pagination) -> Union[Iterable[int], int]:
        if pagination.page < 10:
            return [pagination.page]
        return 42

    output = fct()

    with pytest.raises(TypeError, match=re.escape("'int' object is not iterable")):
        list(output)


def test_unpaginate_no_param() -> None:
    with pytest.raises(
        TypeError,
        match=re.escape(
            "Function 'fct' to unpaginate must have 'pagination' as first parameter"
        ),
    ):

        @unpaginate  # type: ignore[arg-type]
        def fct() -> Iterable[int]:
            yield 42


def test_unpaginate_wrong_param_name() -> None:
    with pytest.raises(
        TypeError,
        match=re.escape(
            "Function 'fct' to unpaginate must have 'pagination' as first parameter"
        ),
    ):

        @unpaginate
        def fct(
            # pylint: disable=unused-argument
            param0: Pagination,  # noqa: ARG001
            param1: int,  # noqa: ARG001
        ) -> Iterable[int]:
            yield 42


def test_unpaginate_wrong_param_kind() -> None:
    with pytest.raises(
        TypeError,
        match=re.escape(
            "Function 'fct' to unpaginate must have 'pagination' as first parameter"
        ),
    ):

        @unpaginate  # type: ignore[arg-type]
        def fct(
            # pylint: disable=unused-argument
            *,
            pagination: Pagination,  # noqa: ARG001
        ) -> Iterable[int]:
            yield 42


def test_unpaginate_called_with_pagination_param() -> None:
    @unpaginate
    def fct(
        # pylint: disable=unused-argument
        pagination: Pagination,
        *args: int,  # noqa: ARG001
        **kwargs: int,  # noqa: ARG001
    ) -> Iterable[int]:
        if pagination.page == 0:
            yield 42

    assert list(fct(13, param=37)) == [42]

    with pytest.raises(
        TypeError,
        match=re.escape(
            "Function 'fct' to unpaginate cannot be called with a 'pagination' parameter"
        ),
    ):
        list(fct(13, pagination=37))


def test_unpaginate_no_type_hint() -> None:
    @unpaginate
    def fct(pagination):  # type: ignore[no-untyped-def]  # noqa: ANN001,ANN202
        if pagination.page == 4:
            pagination.is_last_page = True
        return range(pagination.offset, pagination.offset + 10)

    assert list(fct()) == list(range(50))
