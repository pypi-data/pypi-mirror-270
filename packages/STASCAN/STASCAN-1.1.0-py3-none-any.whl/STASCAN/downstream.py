from sklearn.cluster import KMeans
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.axisartist.axislines import SubplotZero
from sklearn import manifold
from matplotlib.colors import LinearSegmentedColormap
import os
import matplotlib.image as imgplt





class FindNiche():

    def __init__(self, output_path):

        """
        FindNiche.

        Parameters
        ----------
        output_path
            Path of the output folder.

        """

        self.name = "FindNiche"
        self.output_path = output_path

        if not os.path.exists(self.output_path + "/Downstream/"):
            os.makedirs(self.output_path + "/Downstream/")



    def Kmeans(self, predicted_raw, predicted_imputed, n_kmeans=8):

        """
        Visualization of loss curve and accuracy curve.

        Parameters
        ----------
        predicted_raw
            Path of predicted raw spots with detailed probabilities.
        predicted_imputed
            Path of predicted imputed spots with detailed probabilities.
        n_kmeans
            Numbers of clusters generated by Kmeans.
        """

        predict = []

        with open(predicted_raw) as f:
            for line in f.readlines():
                temp = line.split()
                predict.append(temp)
        print(len(predict))

        with open(predicted_imputed) as f:
            for line in f.readlines():
                temp = line.split()
                predict.append(temp)
        print(len(predict))

        data = []
        for each in predict:
            data.append(each[1:-2])

        data = np.array(data, dtype='float')

        kmeans = KMeans(n_clusters=n_kmeans).fit(data)
        n_labels = kmeans.labels_

        for i in range(len(predict)):
            predict[i].append(n_labels[i])

        np.savetxt(self.output_path + "/Downstream/kmeans_label.txt", predict, fmt='%s', delimiter='\t')



    def TSNE_Plot(self, path, kmeans_file, label_number, cmap="tab10", s=5):


        """
        Visualization of TSNE plot.

        Parameters
        ----------
        path
            Path of predicted files with detailed probabilities.
        kmeans_file
            Path of files with kmeans labels.
        label_number
            The number of predicted labels.
        colormap
            Colors for labels.
        s
            the size of ploted points
        """

        barcode, predict_data, cell_label, kmeans_label = [], [], [], []

        with open(path + "/Imputedpredict_detail.txt") as f:
            for line in f.readlines():
                temp = line.split()
                barcode.append(temp[0])
                predict_data.append(temp[1:-2])

        with open(path + "/Imputed_predict.txt") as f:
            for line in f.readlines():
                temp = line.split()
                cell_label.append(temp[1])

        with open(path + "/Rawpredict_detail.txt") as f:
            for line in f.readlines():
                temp = line.split()
                barcode.append(temp[0])
                predict_data.append(temp[1:-2])

        with open(path + "/Raw_predict.txt") as f:
            for line in f.readlines():
                temp = line.split()
                cell_label.append(temp[1])

        with open(kmeans_file) as f:
            for line in f.readlines():
                temp = line.split()
                kmeans_label.append(temp[-1])

        data = np.array(predict_data, dtype='float')
        clabel = np.array(cell_label, dtype='int')
        klabel = np.array(kmeans_label, dtype='int')

        tsne = manifold.TSNE(n_components=2, random_state=24)
        embedding = tsne.fit_transform(data)
        print(embedding.shape)

        true_label = np.unique(clabel)
        print(true_label)
        
        plt.clf()

        plt.scatter(embedding[:, 0], embedding[:, 1], c=clabel, cmap=cmap, s=s)
        plt.gca().set_aspect('equal', 'datalim')
        plt.colorbar(boundaries=np.arange(label_number + 1) - 0.5).set_ticks(np.arange(label_number))
        plt.title('tSNE ' + str(true_label))
        plt.savefig(self.output_path + "/Downstream/tsne_celltype.pdf")
        plt.clf()

        plt.scatter(embedding[:, 0], embedding[:, 1], c=klabel, cmap=cmap, s=s)
        plt.gca().set_aspect('equal', 'datalim')
        plt.colorbar(boundaries=np.arange(label_number + 1) - 0.5).set_ticks(np.arange(label_number))
        plt.title('tSNE')
        plt.savefig(self.output_path + "/Downstream/tsne_kmeans.pdf")
        plt.clf()



    def SpatialNiche(self, kmeans_file, image_path, colormap, pointsize=5, back_image=False):

        """
        Spatial plot of cell-type niches.

        Parameters
        ----------
        kmeans_file
            Path of files with kmeans labels.
        image_path
            Path of the original H&E staining image.
        colormap
            Dictionary of colors for labels.
        output_path
            Path of output files.
        pointsize
            Size of scatter points.
        back_image
            Shown of the original H&E staining image.
        """

        Image = imgplt.imread(image_path)
        h, w, _ = Image.shape

        predict = []
        with open(kmeans_file) as f:
            for line in f.readlines():
                temp = line.split()
                predict.append(temp)

        fig = plt.figure(figsize=(10, 10))
        ax = SubplotZero(fig, 1, 1, 1)
        fig.add_subplot(ax)
        ax.set_xlim(left=0, right=int(max(h, w)))
        ax.set_ylim(bottom=int(max(h, w)), top=0)

        if back_image == True:
            plt.imshow(Image)

        for each in predict:
            plt.scatter(float(each[-3]), float(each[-2]), c=colormap[int(each[-1])], s=pointsize, marker='o')
        plt.savefig(self.output_path + "/Downstream/kmeans_spatial.pdf")



    def SpatialNiche_dbit(self, kmeans_file, colormap, pointsize=10, xylim=1500):

        """
        Spatial plot of cell-type niches.

        Parameters
        ----------
        kmeans_file
            Path of files with kmeans labels.
        image_path
            Path of the original H&E staining image.
        colormap
            Dictionary of colors for labels.
        output_path
            Path of output files.
        pointsize
            Size of scatter points.
        back_image
            Shown of the original H&E staining image.
        """

        predict = []
        with open(kmeans_file) as f:
            for line in f.readlines():
                temp = line.split()
                temp[0] = temp[0].split("-")[-2] + "-" + temp[0].split("-")[-1]
                predict.append(temp)
                
        all_xy = {}
        with open(self.output_path + "/Downstream/raw_xy.txt") as f:
            for line in f.readlines():
                temp = line.split()
                all_xy[temp[0]] = temp[1:]

        with open(self.output_path + "/Downstream/fill_xy.txt") as f:
            for line in f.readlines():
                temp = line.split()
                all_xy[temp[0]] = temp[1:]

        fig = plt.figure(figsize=(6, 6))
        ax = SubplotZero(fig, 1, 1, 1)
        fig.add_subplot(ax)
        ax.set_xlim(left=0, right=xylim)
        ax.set_ylim(bottom=xylim, top=0)

        xlist = [float(all_xy[k[0]][-1]) for k in predict]
        ylist = [float(all_xy[k[0]][-2]) for k in predict]
        clabel = [k[-1] for k in predict]
        
        colormap=colormap
        
        for i in range(len(xlist)):
            plt.scatter(float(xlist[i]), float(ylist[i]), c=colormap[clabel[i]], s=pointsize, marker='s')

        plt.savefig(self.output_path + "/Downstream/kmeans_spatial.pdf")
    
    
    
    def process_xy_dbit(self, origin_set, gap_length, raw_pixel_array, fill_dict_path):
        
        """
        Spatial plot of cell-type niches.

        Parameters
        ----------
        origin_set
            Setted location for the original spot.
        gap_length
            Setted width of the gaps between channels.
        raw_pixel_array
            Path of raw pixel files.
        fill_dict_path
            Path of fill dict.
        """
        
        xy_array = []
        
        for i in range(50):
            for j in range(50):
                xy_array.append([str(i+1)+'x'+str(j+1), origin_set[0]+j*gap_length, origin_set[0]+i*gap_length])

        xy_array_dict = {}
        for each in xy_array:
            xy_array_dict[each[0]] = each[1:]
            
        pixel_array = {}
        with open(raw_pixel_array) as f:
            next(f)
            for line in f.readlines():
                temp = line.split(',')
                temp[-1] = temp[-1].split('\n')[0]
                pixel_array[temp[0]] = temp[1] + 'x' + temp[2]

        raw_xy = []
        for each in pixel_array.keys():
            temp = [each, pixel_array[each]]
            temp.extend(xy_array_dict[pixel_array[each]])
            raw_xy.append(temp)

        np.savetxt(self.output_path + "/Downstream/raw_xy.txt", raw_xy, fmt='%s', delimiter='\t')

        fill_dict = {}
        with open(fill_dict_path) as f:
            for line in f.readlines():
                temp = line.split()
                fill_dict[temp[0]] = temp[1:]

        fill_xy = []
        for each in pixel_array.keys():
            temp1 = [each + '_1', pixel_array[each] + '_1']
            temp1.extend(fill_dict[pixel_array[each] + '_1'])
            temp2 = [each + '_2', pixel_array[each] + '_2']
            temp2.extend(fill_dict[pixel_array[each] + '_2'])
            temp3 = [each + '_3', pixel_array[each] + '_3']
            temp3.extend(fill_dict[pixel_array[each] + '_3'])
            fill_xy.append(temp1)
            fill_xy.append(temp2)
            fill_xy.append(temp3)

        np.savetxt(self.output_path + "/Downstream/fill_xy.txt", fill_xy, fmt='%s', delimiter='\t')

        





