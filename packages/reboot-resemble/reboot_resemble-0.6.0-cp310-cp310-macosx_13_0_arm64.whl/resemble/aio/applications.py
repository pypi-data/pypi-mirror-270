import aiofiles.os
import asyncio
import colorama
import os
import sys
from colorama import Fore, Style
from resemble.aio.auth.token_verifiers import TokenVerifier
from resemble.aio.internals.contextvars import use_application_id
from resemble.aio.servers import Server
from resemble.aio.servicers import Servicer
from resemble.aio.tests import Resemble
from resemble.aio.workflows import Workflow
from resemble.controller.exceptions import InputError
from resemble.controller.settings import USER_CONTAINER_GRPC_PORT
from resemble.inspect.servicer import InspectServicer
from resemble.run_environments import (
    InvalidRunEnvironment,
    RunEnvironment,
    _detect_run_environment,
)
from resemble.settings import (
    DEFAULT_SECURE_PORT,
    ENVVAR_RSM_DEV_INSPECT_PORT,
    ENVVAR_RSM_DEV_LOCAL_ENVOY,
    ENVVAR_RSM_DEV_LOCAL_ENVOY_PORT,
    ENVVAR_RSM_DEV_NAME,
    ENVVAR_RSM_DOT_RSM_DEV_DIRECTORY,
    SIDECAR_SUFFIX,
)
from respect.logging import get_logger
from typing import Awaitable, Callable, Optional

logger = get_logger(__name__)


class Application:
    """Entry point for all resemble applications."""

    def __init__(
        self,
        *,
        servicers: Optional[list[type[Servicer]]] = None,
        # A legacy gRPC servicer type can't be more specific than `type`,
        # because legacy gRPC servicers (as generated by the gRPC `protoc`
        # plugin) do not share any common base class other than `object`.
        legacy_grpc_servicers: Optional[list[type]] = None,
        initialize: Optional[Callable[[Workflow], Awaitable[None]]] = None,
        initialize_bearer_token: Optional[str] = None,
        token_verifier: Optional[TokenVerifier] = None,
    ):
        """
        :param servicers: the types of Resemble-powered servicers that this
                          Application will serve.
        :param legacy_grpc_servicers: the types of legacy gRPC servicers (not
                                      using Resemble libraries) that this
                                      Application will serve.

        :param initialize: will be called after the Application's servicers have
                       started for the first time, so that it can perform
                       initialization logic (e.g., creating some well-known
                       actors, loading some data, etc. It must do so in the
                       context of the given Workflow.

        :param initialize_bearer_token: a Bearer token that will be used to construct
            the `Workflow` passed to `initialize`.

        :param token_verifier: a TokenVerifier that will be used to verify
            authorization bearer tokens passed to the application.

        TODO(benh): update the initialize function to be run in a transaction
        and ensure that the transaction has finished before serving any other
        calls on the servicers.
        """
        self._servicers = servicers
        self._legacy_grpc_servicers = legacy_grpc_servicers
        self._initialize = initialize
        self._token_verifier = token_verifier
        self._initialize_bearer_token = initialize_bearer_token

        self._rsm: Optional[Resemble] = None

        try:
            run_environment = _detect_run_environment()
        except InvalidRunEnvironment:
            # Bail out. The user will be given a helpful error message at
            # run-time and the application will exit with a non-0 exit
            # code without a distracting stack trace.
            return

        if run_environment == RunEnvironment.RSM_DEV:
            # Only when running as part of `rsm dev run` do we need to bring up
            # a Resemble cluster instance in-memory.
            #
            # NOTE: we construct a 'Resemble' instance here so that it can
            # perform any process wide initialization as early as possible
            # (e.g., initializing multiprocessing before any threads are
            # created)
            self._rsm = Resemble()

    async def _run_rsm_dev(self) -> int:
        """Runs the application and returns a status code indicating success
        or failure."""
        assert self._rsm is not None
        await self._rsm.start()

        name: Optional[str] = os.environ.get(ENVVAR_RSM_DEV_NAME)

        directory: Optional[str] = os.environ.get(
            ENVVAR_RSM_DOT_RSM_DEV_DIRECTORY
        )

        local_envoy: bool = os.environ.get(
            ENVVAR_RSM_DEV_LOCAL_ENVOY,
            'false',
        ).lower() == 'true'

        local_envoy_port: int = int(
            os.environ.get(
                ENVVAR_RSM_DEV_LOCAL_ENVOY_PORT, str(DEFAULT_SECURE_PORT)
            )
        )

        inspect_port: int = int(
            os.environ.get(ENVVAR_RSM_DEV_INSPECT_PORT, '9992')
        )

        # We only want to initialize if this is the first time we're bringing up
        # this application. That's definitely the case if 'name' is None, since
        # we'll be creating a temporary directory. Otherwise, we determine below
        # based on whether or not a directory already exists for this 'name'.
        initialize = name is None

        if name is not None:
            assert directory is not None

            # Check if this is the first time we're bringing up an
            # application with this name and thus need to initialize.
            initialize = not await aiofiles.os.path.isdir(
                os.path.join(directory, f'{name}{SIDECAR_SUFFIX}')
            )

            try:
                await aiofiles.os.makedirs(directory)
            except FileExistsError:
                # Directory likely already exists since that's the
                # whole purpose of '--name' in the first place!
                pass

        inspect_static_server_task: Optional[asyncio.Task] = None
        try:
            config = await self._rsm.up(
                servicers=self._servicers,
                legacy_grpc_servicers=self._legacy_grpc_servicers,
                token_verifier=self._token_verifier,
                local_envoy=local_envoy,
                local_envoy_port=local_envoy_port,
                directory=directory,
                name=name,
            )
        except InputError as e:
            print(e.reason, file=sys.stderr)
            return 1
        else:
            if initialize and self._initialize is not None:
                # Need to set the application ID asyncio context
                # variable so `initialize` can make calls to other
                # servicers.
                with use_application_id(config.application_id()):
                    await self._initialize(
                        self._rsm.create_workflow(
                            name='initialize',
                            bearer_token=self._initialize_bearer_token,
                        )
                    )

            # Serve the 'inspect' web app.
            #
            # TODO(benh): abstract/replace 'localhost.direct' once we
            # support running applications in K8s.
            inspect_static_server_task = asyncio.create_task(
                InspectServicer.run_static_server(
                    port=inspect_port,
                    uri=f'https://localhost.direct:{local_envoy_port}',
                )
            )

            # Wait forever unless we get cancelled!
            #
            # TODO(benh): have 'rsm.up()' return a tuple of (config,
            # future) so we can watch the future and if that ever
            # fails we should exit and return an error to the user.
            #
            # TODO(benh): also have 'rsm.up()' fail the future that it
            # returns to us if the local envoy that got started
            # happened to fail.
            forever = asyncio.Event()
            await forever.wait()
        finally:
            await self._rsm.stop()

            try:
                if inspect_static_server_task is not None:
                    inspect_static_server_task.cancel()
                    await inspect_static_server_task
            except:
                pass

        return 0

    async def _run_kubernetes(self) -> int:
        """Runs a single consensus in a Kubernetes-appropriate way.

        Blocks until cancelled, then returns a status code indicating success
        or failure.
        """

        try:
            # ISSUE(https://github.com/reboot-dev/respect/issues/2175): support
            # legacy gRPC servicers on Kubernetes.
            if self._legacy_grpc_servicers is not None:
                raise NotImplementedError(
                    "Legacy gRPC servicers are not yet supported on Kubernetes"
                )
            if self._servicers is None:
                raise ValueError(
                    "No servicers were provided to the Application"
                )
            server = Server.create_on_k8s(
                servicers=self._servicers,
                listen_address=f'0.0.0.0:{USER_CONTAINER_GRPC_PORT}',
                initialize=self._initialize,
                initialize_bearer_token=self._initialize_bearer_token,
                token_verifier=self._token_verifier,
            )
            server_run_task = asyncio.create_task(server.run())

        except Exception as e:
            logger.error(f"Unexpected error while starting: {e}")
            # An unexpected error, by definition, is something that we didn't
            # see coming. It may have been caused by the user's code. Help them
            # (and us, if they file a bug report) debug it by printing the stack
            # trace.
            logger.error("Stack trace:", exc_info=True)
            return 1

        # Wait forever, or at least until the server gets shut down.
        await server_run_task

        return 0

    async def run(self) -> int:
        """Runs the application and returns a status code indicating success
        or failure."""

        colorama.init()

        try:
            run_environment = _detect_run_environment()
        except InvalidRunEnvironment:
            # We can't detect the run environment. Assume that the user is trying to
            # run the application locally, but doing it in a way we don't support.
            # Give a helpful error message pointing them to `rsm dev run`.
            #
            # TODO(benh): factor this and similar code in 'rsm.py' out into helpers.
            message = "Please use 'rsm dev run' to run your application locally"
            if sys.stderr.isatty():
                print(
                    Fore.RED + Style.BRIGHT + message + Style.RESET_ALL,
                    file=sys.stderr,
                )
            else:
                print(message, file=sys.stderr)
            return 1

        if run_environment == RunEnvironment.RSM_DEV:
            return await self._run_rsm_dev()

        return await self._run_kubernetes()
